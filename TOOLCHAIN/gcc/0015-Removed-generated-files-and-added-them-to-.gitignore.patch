From 3362ec859c959b4cca98d9fbb7ad1d16c22ef18b Mon Sep 17 00:00:00 2001
From: Guillermo Vidal <guillermo.vidal@continental-corporation.com>
Date: Sun, 11 Jan 2015 14:19:34 -0600
Subject: [PATCH 15/15] Removed generated files and added them to .gitignore

---
 .gitignore             |   10 +-
 gmp/doc/gmp.info       |  178 --
 gmp/doc/gmp.info-1     | 7084 ------------------------------------------------
 gmp/doc/gmp.info-2     | 3514 ------------------------
 mpc/doc/mpc.info       | 1322 ---------
 mpfr/doc/mpfr.info     | 4255 -----------------------------
 mpfr/src/get_patches.c |   29 -
 7 files changed, 6 insertions(+), 16386 deletions(-)
 delete mode 100644 gmp/doc/gmp.info
 delete mode 100644 gmp/doc/gmp.info-1
 delete mode 100644 gmp/doc/gmp.info-2
 delete mode 100644 mpc/doc/mpc.info
 delete mode 100644 mpfr/doc/mpfr.info
 delete mode 100644 mpfr/src/get_patches.c

diff --git a/.gitignore b/.gitignore
index dbcef05..fb4cfb5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,7 @@
-build-static/
-build-full/
 autom4te.cache/
-
-
+build-full/
+build-static/
+gmp/doc/gmp.info
+mpc/doc/mpc.info
+mpfr/doc/mpfr.info
+mpfr/src/get_patches.c
diff --git a/gmp/doc/gmp.info b/gmp/doc/gmp.info
deleted file mode 100644
index 7e33763..0000000
--- a/gmp/doc/gmp.info
+++ /dev/null
@@ -1,178 +0,0 @@
-This is ../../gmp/doc/gmp.info, produced by makeinfo version 4.8 from
-../../gmp/doc/gmp.texi.
-
-   This manual describes how to install and use the GNU multiple
-precision arithmetic library, version 5.0.2.
-
-   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this
-document under the terms of the GNU Free Documentation License, Version
-1.3 or any later version published by the Free Software Foundation;
-with no Invariant Sections, with the Front-Cover Texts being "A GNU
-Manual", and with the Back-Cover Texts being "You have freedom to copy
-and modify this GNU Manual, like GNU software".  A copy of the license
-is included in *Note GNU Free Documentation License::.
-
-INFO-DIR-SECTION GNU libraries
-START-INFO-DIR-ENTRY
-* gmp: (gmp).                   GNU Multiple Precision Arithmetic Library.
-END-INFO-DIR-ENTRY
-
-
-Indirect:
-gmp.info-1: 987
-gmp.info-2: 300718
-
-Tag Table:
-(Indirect)
-Node: Top987
-Node: Copying3223
-Node: Introduction to GMP5074
-Node: Installing GMP7785
-Node: Build Options8517
-Node: ABI and ISA24585
-Node: Notes for Package Builds34271
-Node: Notes for Particular Systems37358
-Node: Known Build Problems43915
-Node: Performance optimization47449
-Node: GMP Basics48578
-Node: Headers and Libraries49226
-Node: Nomenclature and Types50650
-Node: Function Classes52647
-Node: Variable Conventions54340
-Node: Parameter Conventions55949
-Node: Memory Management58005
-Node: Reentrancy59133
-Node: Useful Macros and Constants61006
-Node: Compatibility with older versions62004
-Node: Demonstration Programs62965
-Node: Efficiency64830
-Node: Debugging72454
-Node: Profiling79012
-Node: Autoconf83003
-Node: Emacs84782
-Node: Reporting Bugs85388
-Node: Integer Functions87931
-Node: Initializing Integers88707
-Node: Assigning Integers90854
-Node: Simultaneous Integer Init & Assign92441
-Node: Converting Integers94066
-Node: Integer Arithmetic96988
-Node: Integer Division98574
-Node: Integer Exponentiation104884
-Node: Integer Roots106324
-Node: Number Theoretic Functions107998
-Node: Integer Comparisons114141
-Node: Integer Logic and Bit Fiddling115519
-Node: I/O of Integers118066
-Node: Integer Random Numbers121035
-Node: Integer Import and Export123646
-Node: Miscellaneous Integer Functions127656
-Node: Integer Special Functions129516
-Node: Rational Number Functions132603
-Node: Initializing Rationals133796
-Node: Rational Conversions136257
-Node: Rational Arithmetic137988
-Node: Comparing Rationals139292
-Node: Applying Integer Functions140659
-Node: I/O of Rationals142142
-Node: Floating-point Functions144184
-Node: Initializing Floats147069
-Node: Assigning Floats151156
-Node: Simultaneous Float Init & Assign153723
-Node: Converting Floats155251
-Node: Float Arithmetic158499
-Node: Float Comparison160512
-Node: I/O of Floats162093
-Node: Miscellaneous Float Functions164776
-Node: Low-level Functions166718
-Node: Random Number Functions190930
-Node: Random State Initialization191998
-Node: Random State Seeding194856
-Node: Random State Miscellaneous196245
-Node: Formatted Output196886
-Node: Formatted Output Strings197131
-Node: Formatted Output Functions202345
-Node: C++ Formatted Output206420
-Node: Formatted Input209102
-Node: Formatted Input Strings209338
-Node: Formatted Input Functions213990
-Node: C++ Formatted Input216959
-Node: C++ Class Interface218862
-Node: C++ Interface General219863
-Node: C++ Interface Integers222933
-Node: C++ Interface Rationals226278
-Node: C++ Interface Floats229865
-Node: C++ Interface Random Numbers235575
-Node: C++ Interface Limitations237981
-Node: BSD Compatible Functions240801
-Node: Custom Allocation245512
-Node: Language Bindings249830
-Node: Algorithms253809
-Node: Multiplication Algorithms254509
-Node: Basecase Multiplication255481
-Node: Karatsuba Multiplication257389
-Node: Toom 3-Way Multiplication261014
-Node: Toom 4-Way Multiplication267428
-Node: FFT Multiplication268800
-Node: Other Multiplication274136
-Node: Unbalanced Multiplication276610
-Node: Division Algorithms277398
-Node: Single Limb Division277777
-Node: Basecase Division280668
-Node: Divide and Conquer Division281871
-Node: Block-Wise Barrett Division283940
-Node: Exact Division284592
-Node: Exact Remainder287757
-Node: Small Quotient Division289984
-Node: Greatest Common Divisor Algorithms291582
-Node: Binary GCD291879
-Node: Lehmer's Algorithm294728
-Node: Subquadratic GCD296947
-Node: Extended GCD299406
-Node: Jacobi Symbol300718
-Node: Powering Algorithms301634
-Node: Normal Powering Algorithm301897
-Node: Modular Powering Algorithm302425
-Node: Root Extraction Algorithms303205
-Node: Square Root Algorithm303520
-Node: Nth Root Algorithm305661
-Node: Perfect Square Algorithm306446
-Node: Perfect Power Algorithm308532
-Node: Radix Conversion Algorithms309153
-Node: Binary to Radix309529
-Node: Radix to Binary313458
-Node: Other Algorithms315546
-Node: Prime Testing Algorithm315898
-Node: Factorial Algorithm317082
-Node: Binomial Coefficients Algorithm318485
-Node: Fibonacci Numbers Algorithm319379
-Node: Lucas Numbers Algorithm321853
-Node: Random Number Algorithms322574
-Node: Assembly Coding324695
-Node: Assembly Code Organisation325655
-Node: Assembly Basics326622
-Node: Assembly Carry Propagation327772
-Node: Assembly Cache Handling329603
-Node: Assembly Functional Units331764
-Node: Assembly Floating Point333377
-Node: Assembly SIMD Instructions337155
-Node: Assembly Software Pipelining338137
-Node: Assembly Loop Unrolling339199
-Node: Assembly Writing Guide341414
-Node: Internals344179
-Node: Integer Internals344691
-Node: Rational Internals346947
-Node: Float Internals348185
-Node: Raw Output Internals355599
-Node: C++ Interface Internals356793
-Node: Contributors360079
-Node: References365037
-Node: GNU Free Documentation License370780
-Node: Concept Index395949
-Node: Function Index442131
-
-End Tag Table
diff --git a/gmp/doc/gmp.info-1 b/gmp/doc/gmp.info-1
deleted file mode 100644
index 1574e0e..0000000
--- a/gmp/doc/gmp.info-1
+++ /dev/null
@@ -1,7084 +0,0 @@
-This is ../../gmp/doc/gmp.info, produced by makeinfo version 4.8 from
-../../gmp/doc/gmp.texi.
-
-   This manual describes how to install and use the GNU multiple
-precision arithmetic library, version 5.0.2.
-
-   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this
-document under the terms of the GNU Free Documentation License, Version
-1.3 or any later version published by the Free Software Foundation;
-with no Invariant Sections, with the Front-Cover Texts being "A GNU
-Manual", and with the Back-Cover Texts being "You have freedom to copy
-and modify this GNU Manual, like GNU software".  A copy of the license
-is included in *Note GNU Free Documentation License::.
-
-INFO-DIR-SECTION GNU libraries
-START-INFO-DIR-ENTRY
-* gmp: (gmp).                   GNU Multiple Precision Arithmetic Library.
-END-INFO-DIR-ENTRY
-
-
-File: gmp.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)
-
-GNU MP
-******
-
-   This manual describes how to install and use the GNU multiple
-precision arithmetic library, version 5.0.2.
-
-   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this
-document under the terms of the GNU Free Documentation License, Version
-1.3 or any later version published by the Free Software Foundation;
-with no Invariant Sections, with the Front-Cover Texts being "A GNU
-Manual", and with the Back-Cover Texts being "You have freedom to copy
-and modify this GNU Manual, like GNU software".  A copy of the license
-is included in *Note GNU Free Documentation License::.
-
-
-* Menu:
-
-* Copying::                    GMP Copying Conditions (LGPL).
-* Introduction to GMP::        Brief introduction to GNU MP.
-* Installing GMP::             How to configure and compile the GMP library.
-* GMP Basics::                 What every GMP user should know.
-* Reporting Bugs::             How to usefully report bugs.
-* Integer Functions::          Functions for arithmetic on signed integers.
-* Rational Number Functions::  Functions for arithmetic on rational numbers.
-* Floating-point Functions::   Functions for arithmetic on floats.
-* Low-level Functions::        Fast functions for natural numbers.
-* Random Number Functions::    Functions for generating random numbers.
-* Formatted Output::           `printf' style output.
-* Formatted Input::            `scanf' style input.
-* C++ Class Interface::        Class wrappers around GMP types.
-* BSD Compatible Functions::   All functions found in BSD MP.
-* Custom Allocation::          How to customize the internal allocation.
-* Language Bindings::          Using GMP from other languages.
-* Algorithms::                 What happens behind the scenes.
-* Internals::                  How values are represented behind the scenes.
-
-* Contributors::               Who brings you this library?
-* References::                 Some useful papers and books to read.
-* GNU Free Documentation License::
-* Concept Index::
-* Function Index::
-
-
-File: gmp.info,  Node: Copying,  Next: Introduction to GMP,  Prev: Top,  Up: Top
-
-GNU MP Copying Conditions
-*************************
-
-This library is "free"; this means that everyone is free to use it and
-free to redistribute it on a free basis.  The library is not in the
-public domain; it is copyrighted and there are restrictions on its
-distribution, but these restrictions are designed to permit everything
-that a good cooperating citizen would want to do.  What is not allowed
-is to try to prevent others from further sharing any version of this
-library that they might get from you.
-
-   Specifically, we want to make sure that you have the right to give
-away copies of the library, that you receive source code or else can
-get it if you want it, that you can change this library or use pieces
-of it in new free programs, and that you know you can do these things.
-
-   To make sure that everyone has such rights, we have to forbid you to
-deprive anyone else of these rights.  For example, if you distribute
-copies of the GNU MP library, you must give the recipients all the
-rights that you have.  You must make sure that they, too, receive or
-can get the source code.  And you must tell them their rights.
-
-   Also, for our own protection, we must make certain that everyone
-finds out that there is no warranty for the GNU MP library.  If it is
-modified by someone else and passed on, we want their recipients to
-know that what they have is not what we distributed, so that any
-problems introduced by others will not reflect on our reputation.
-
-   The precise conditions of the license for the GNU MP library are
-found in the Lesser General Public License version 3 that accompanies
-the source code, see `COPYING.LIB'.  Certain demonstration programs are
-provided under the terms of the plain General Public License version 3,
-see `COPYING'.
-
-
-File: gmp.info,  Node: Introduction to GMP,  Next: Installing GMP,  Prev: Copying,  Up: Top
-
-1 Introduction to GNU MP
-************************
-
-GNU MP is a portable library written in C for arbitrary precision
-arithmetic on integers, rational numbers, and floating-point numbers.
-It aims to provide the fastest possible arithmetic for all applications
-that need higher precision than is directly supported by the basic C
-types.
-
-   Many applications use just a few hundred bits of precision; but some
-applications may need thousands or even millions of bits.  GMP is
-designed to give good performance for both, by choosing algorithms
-based on the sizes of the operands, and by carefully keeping the
-overhead at a minimum.
-
-   The speed of GMP is achieved by using fullwords as the basic
-arithmetic type, by using sophisticated algorithms, by including
-carefully optimized assembly code for the most common inner loops for
-many different CPUs, and by a general emphasis on speed (as opposed to
-simplicity or elegance).
-
-   There is assembly code for these CPUs: ARM, DEC Alpha 21064, 21164,
-and 21264, AMD 29000, AMD K6, K6-2, Athlon, and Athlon64, Hitachi
-SuperH and SH-2, HPPA 1.0, 1.1 and 2.0, Intel Pentium, Pentium
-Pro/II/III, Pentium 4, generic x86, Intel IA-64, i960, Motorola
-MC68000, MC68020, MC88100, and MC88110, Motorola/IBM PowerPC 32 and 64,
-National NS32000, IBM POWER, MIPS R3000, R4000, SPARCv7, SuperSPARC,
-generic SPARCv8, UltraSPARC, DEC VAX, and Zilog Z8000.  Some
-optimizations also for Cray vector systems, Clipper, IBM ROMP (RT), and
-Pyramid AP/XP.
-
-For up-to-date information on GMP, please see the GMP web pages at
-
-     `http://gmplib.org/'
-
-The latest version of the library is available at
-
-     `ftp://ftp.gnu.org/gnu/gmp/'
-
-   Many sites around the world mirror `ftp.gnu.org', please use a mirror
-near you, see `http://www.gnu.org/order/ftp.html' for a full list.
-
-   There are three public mailing lists of interest.  One for release
-announcements, one for general questions and discussions about usage of
-the GMP library and one for bug reports.  For more information, see
-
-     `http://gmplib.org/mailman/listinfo/'.
-
-   The proper place for bug reports is <gmp-bugs@gmplib.org>.  See
-*Note Reporting Bugs:: for information about reporting bugs.
-
-
-1.1 How to use this Manual
-==========================
-
-Everyone should read *Note GMP Basics::.  If you need to install the
-library yourself, then read *Note Installing GMP::.  If you have a
-system with multiple ABIs, then read *Note ABI and ISA::, for the
-compiler options that must be used on applications.
-
-   The rest of the manual can be used for later reference, although it
-is probably a good idea to glance through it.
-
-
-File: gmp.info,  Node: Installing GMP,  Next: GMP Basics,  Prev: Introduction to GMP,  Up: Top
-
-2 Installing GMP
-****************
-
-GMP has an autoconf/automake/libtool based configuration system.  On a
-Unix-like system a basic build can be done with
-
-     ./configure
-     make
-
-Some self-tests can be run with
-
-     make check
-
-And you can install (under `/usr/local' by default) with
-
-     make install
-
-   If you experience problems, please report them to
-<gmp-bugs@gmplib.org>.  See *Note Reporting Bugs::, for information on
-what to include in useful bug reports.
-
-* Menu:
-
-* Build Options::
-* ABI and ISA::
-* Notes for Package Builds::
-* Notes for Particular Systems::
-* Known Build Problems::
-* Performance optimization::
-
-
-File: gmp.info,  Node: Build Options,  Next: ABI and ISA,  Prev: Installing GMP,  Up: Installing GMP
-
-2.1 Build Options
-=================
-
-All the usual autoconf configure options are available, run `./configure
---help' for a summary.  The file `INSTALL.autoconf' has some generic
-installation information too.
-
-Tools
-     `configure' requires various Unix-like tools.  See *Note Notes for
-     Particular Systems::, for some options on non-Unix systems.
-
-     It might be possible to build without the help of `configure',
-     certainly all the code is there, but unfortunately you'll be on
-     your own.
-
-Build Directory
-     To compile in a separate build directory, `cd' to that directory,
-     and prefix the configure command with the path to the GMP source
-     directory.  For example
-
-          cd /my/build/dir
-          /my/sources/gmp-5.0.2/configure
-
-     Not all `make' programs have the necessary features (`VPATH') to
-     support this.  In particular, SunOS and Slowaris `make' have bugs
-     that make them unable to build in a separate directory.  Use GNU
-     `make' instead.
-
-`--prefix' and `--exec-prefix'
-     The `--prefix' option can be used in the normal way to direct GMP
-     to install under a particular tree.  The default is `/usr/local'.
-
-     `--exec-prefix' can be used to direct architecture-dependent files
-     like `libgmp.a' to a different location.  This can be used to share
-     architecture-independent parts like the documentation, but
-     separate the dependent parts.  Note however that `gmp.h' and
-     `mp.h' are architecture-dependent since they encode certain
-     aspects of `libgmp', so it will be necessary to ensure both
-     `$prefix/include' and `$exec_prefix/include' are available to the
-     compiler.
-
-`--disable-shared', `--disable-static'
-     By default both shared and static libraries are built (where
-     possible), but one or other can be disabled.  Shared libraries
-     result in smaller executables and permit code sharing between
-     separate running processes, but on some CPUs are slightly slower,
-     having a small cost on each function call.
-
-Native Compilation, `--build=CPU-VENDOR-OS'
-     For normal native compilation, the system can be specified with
-     `--build'.  By default `./configure' uses the output from running
-     `./config.guess'.  On some systems `./config.guess' can determine
-     the exact CPU type, on others it will be necessary to give it
-     explicitly.  For example,
-
-          ./configure --build=ultrasparc-sun-solaris2.7
-
-     In all cases the `OS' part is important, since it controls how
-     libtool generates shared libraries.  Running `./config.guess' is
-     the simplest way to see what it should be, if you don't know
-     already.
-
-Cross Compilation, `--host=CPU-VENDOR-OS'
-     When cross-compiling, the system used for compiling is given by
-     `--build' and the system where the library will run is given by
-     `--host'.  For example when using a FreeBSD Athlon system to build
-     GNU/Linux m68k binaries,
-
-          ./configure --build=athlon-pc-freebsd3.5 --host=m68k-mac-linux-gnu
-
-     Compiler tools are sought first with the host system type as a
-     prefix.  For example `m68k-mac-linux-gnu-ranlib' is tried, then
-     plain `ranlib'.  This makes it possible for a set of
-     cross-compiling tools to co-exist with native tools.  The prefix
-     is the argument to `--host', and this can be an alias, such as
-     `m68k-linux'.  But note that tools don't have to be setup this
-     way, it's enough to just have a `PATH' with a suitable
-     cross-compiling `cc' etc.
-
-     Compiling for a different CPU in the same family as the build
-     system is a form of cross-compilation, though very possibly this
-     would merely be special options on a native compiler.  In any case
-     `./configure' avoids depending on being able to run code on the
-     build system, which is important when creating binaries for a
-     newer CPU since they very possibly won't run on the build system.
-
-     In all cases the compiler must be able to produce an executable
-     (of whatever format) from a standard C `main'.  Although only
-     object files will go to make up `libgmp', `./configure' uses
-     linking tests for various purposes, such as determining what
-     functions are available on the host system.
-
-     Currently a warning is given unless an explicit `--build' is used
-     when cross-compiling, because it may not be possible to correctly
-     guess the build system type if the `PATH' has only a
-     cross-compiling `cc'.
-
-     Note that the `--target' option is not appropriate for GMP.  It's
-     for use when building compiler tools, with `--host' being where
-     they will run, and `--target' what they'll produce code for.
-     Ordinary programs or libraries like GMP are only interested in the
-     `--host' part, being where they'll run.  (Some past versions of
-     GMP used `--target' incorrectly.)
-
-CPU types
-     In general, if you want a library that runs as fast as possible,
-     you should configure GMP for the exact CPU type your system uses.
-     However, this may mean the binaries won't run on older members of
-     the family, and might run slower on other members, older or newer.
-     The best idea is always to build GMP for the exact machine type
-     you intend to run it on.
-
-     The following CPUs have specific support.  See `configure.in' for
-     details of what code and compiler options they select.
-
-        * Alpha: alpha, alphaev5, alphaev56, alphapca56, alphapca57,
-          alphaev6, alphaev67, alphaev68 alphaev7
-
-        * Cray: c90, j90, t90, sv1
-
-        * HPPA: hppa1.0, hppa1.1, hppa2.0, hppa2.0n, hppa2.0w, hppa64
-
-        * IA-64: ia64, itanium, itanium2
-
-        * MIPS: mips, mips3, mips64
-
-        * Motorola: m68k, m68000, m68010, m68020, m68030, m68040,
-          m68060, m68302, m68360, m88k, m88110
-
-        * POWER: power, power1, power2, power2sc
-
-        * PowerPC: powerpc, powerpc64, powerpc401, powerpc403,
-          powerpc405, powerpc505, powerpc601, powerpc602, powerpc603,
-          powerpc603e, powerpc604, powerpc604e, powerpc620, powerpc630,
-          powerpc740, powerpc7400, powerpc7450, powerpc750, powerpc801,
-          powerpc821, powerpc823, powerpc860, powerpc970
-
-        * SPARC: sparc, sparcv8, microsparc, supersparc, sparcv9,
-          ultrasparc, ultrasparc2, ultrasparc2i, ultrasparc3, sparc64
-
-        * x86 family: i386, i486, i586, pentium, pentiummmx, pentiumpro,
-          pentium2, pentium3, pentium4, k6, k62, k63, athlon, amd64,
-          viac3, viac32
-
-        * Other: a29k, arm, clipper, i960, ns32k, pyramid, sh, sh2, vax,
-          z8k
-
-     CPUs not listed will use generic C code.
-
-Generic C Build
-     If some of the assembly code causes problems, or if otherwise
-     desired, the generic C code can be selected with CPU `none'.  For
-     example,
-
-          ./configure --host=none-unknown-freebsd3.5
-
-     Note that this will run quite slowly, but it should be portable
-     and should at least make it possible to get something running if
-     all else fails.
-
-Fat binary, `--enable-fat'
-     Using `--enable-fat' selects a "fat binary" build on x86, where
-     optimized low level subroutines are chosen at runtime according to
-     the CPU detected.  This means more code, but gives good
-     performance on all x86 chips.  (This option might become available
-     for more architectures in the future.)
-
-`ABI'
-     On some systems GMP supports multiple ABIs (application binary
-     interfaces), meaning data type sizes and calling conventions.  By
-     default GMP chooses the best ABI available, but a particular ABI
-     can be selected.  For example
-
-          ./configure --host=mips64-sgi-irix6 ABI=n32
-
-     See *Note ABI and ISA::, for the available choices on relevant
-     CPUs, and what applications need to do.
-
-`CC', `CFLAGS'
-     By default the C compiler used is chosen from among some likely
-     candidates, with `gcc' normally preferred if it's present.  The
-     usual `CC=whatever' can be passed to `./configure' to choose
-     something different.
-
-     For various systems, default compiler flags are set based on the
-     CPU and compiler.  The usual `CFLAGS="-whatever"' can be passed to
-     `./configure' to use something different or to set good flags for
-     systems GMP doesn't otherwise know.
-
-     The `CC' and `CFLAGS' used are printed during `./configure', and
-     can be found in each generated `Makefile'.  This is the easiest way
-     to check the defaults when considering changing or adding
-     something.
-
-     Note that when `CC' and `CFLAGS' are specified on a system
-     supporting multiple ABIs it's important to give an explicit
-     `ABI=whatever', since GMP can't determine the ABI just from the
-     flags and won't be able to select the correct assembly code.
-
-     If just `CC' is selected then normal default `CFLAGS' for that
-     compiler will be used (if GMP recognises it).  For example
-     `CC=gcc' can be used to force the use of GCC, with default flags
-     (and default ABI).
-
-`CPPFLAGS'
-     Any flags like `-D' defines or `-I' includes required by the
-     preprocessor should be set in `CPPFLAGS' rather than `CFLAGS'.
-     Compiling is done with both `CPPFLAGS' and `CFLAGS', but
-     preprocessing uses just `CPPFLAGS'.  This distinction is because
-     most preprocessors won't accept all the flags the compiler does.
-     Preprocessing is done separately in some configure tests, and in
-     the `ansi2knr' support for K&R compilers.
-
-`CC_FOR_BUILD'
-     Some build-time programs are compiled and run to generate
-     host-specific data tables.  `CC_FOR_BUILD' is the compiler used
-     for this.  It doesn't need to be in any particular ABI or mode, it
-     merely needs to generate executables that can run.  The default is
-     to try the selected `CC' and some likely candidates such as `cc'
-     and `gcc', looking for something that works.
-
-     No flags are used with `CC_FOR_BUILD' because a simple invocation
-     like `cc foo.c' should be enough.  If some particular options are
-     required they can be included as for instance `CC_FOR_BUILD="cc
-     -whatever"'.
-
-C++ Support, `--enable-cxx'
-     C++ support in GMP can be enabled with `--enable-cxx', in which
-     case a C++ compiler will be required.  As a convenience
-     `--enable-cxx=detect' can be used to enable C++ support only if a
-     compiler can be found.  The C++ support consists of a library
-     `libgmpxx.la' and header file `gmpxx.h' (*note Headers and
-     Libraries::).
-
-     A separate `libgmpxx.la' has been adopted rather than having C++
-     objects within `libgmp.la' in order to ensure dynamic linked C
-     programs aren't bloated by a dependency on the C++ standard
-     library, and to avoid any chance that the C++ compiler could be
-     required when linking plain C programs.
-
-     `libgmpxx.la' will use certain internals from `libgmp.la' and can
-     only be expected to work with `libgmp.la' from the same GMP
-     version.  Future changes to the relevant internals will be
-     accompanied by renaming, so a mismatch will cause unresolved
-     symbols rather than perhaps mysterious misbehaviour.
-
-     In general `libgmpxx.la' will be usable only with the C++ compiler
-     that built it, since name mangling and runtime support are usually
-     incompatible between different compilers.
-
-`CXX', `CXXFLAGS'
-     When C++ support is enabled, the C++ compiler and its flags can be
-     set with variables `CXX' and `CXXFLAGS' in the usual way.  The
-     default for `CXX' is the first compiler that works from a list of
-     likely candidates, with `g++' normally preferred when available.
-     The default for `CXXFLAGS' is to try `CFLAGS', `CFLAGS' without
-     `-g', then for `g++' either `-g -O2' or `-O2', or for other
-     compilers `-g' or nothing.  Trying `CFLAGS' this way is convenient
-     when using `gcc' and `g++' together, since the flags for `gcc' will
-     usually suit `g++'.
-
-     It's important that the C and C++ compilers match, meaning their
-     startup and runtime support routines are compatible and that they
-     generate code in the same ABI (if there's a choice of ABIs on the
-     system).  `./configure' isn't currently able to check these things
-     very well itself, so for that reason `--disable-cxx' is the
-     default, to avoid a build failure due to a compiler mismatch.
-     Perhaps this will change in the future.
-
-     Incidentally, it's normally not good enough to set `CXX' to the
-     same as `CC'.  Although `gcc' for instance recognises `foo.cc' as
-     C++ code, only `g++' will invoke the linker the right way when
-     building an executable or shared library from C++ object files.
-
-Temporary Memory, `--enable-alloca=<choice>'
-     GMP allocates temporary workspace using one of the following three
-     methods, which can be selected with for instance
-     `--enable-alloca=malloc-reentrant'.
-
-        * `alloca' - C library or compiler builtin.
-
-        * `malloc-reentrant' - the heap, in a re-entrant fashion.
-
-        * `malloc-notreentrant' - the heap, with global variables.
-
-     For convenience, the following choices are also available.
-     `--disable-alloca' is the same as `no'.
-
-        * `yes' - a synonym for `alloca'.
-
-        * `no' - a synonym for `malloc-reentrant'.
-
-        * `reentrant' - `alloca' if available, otherwise
-          `malloc-reentrant'.  This is the default.
-
-        * `notreentrant' - `alloca' if available, otherwise
-          `malloc-notreentrant'.
-
-     `alloca' is reentrant and fast, and is recommended.  It actually
-     allocates just small blocks on the stack; larger ones use
-     malloc-reentrant.
-
-     `malloc-reentrant' is, as the name suggests, reentrant and thread
-     safe, but `malloc-notreentrant' is faster and should be used if
-     reentrancy is not required.
-
-     The two malloc methods in fact use the memory allocation functions
-     selected by `mp_set_memory_functions', these being `malloc' and
-     friends by default.  *Note Custom Allocation::.
-
-     An additional choice `--enable-alloca=debug' is available, to help
-     when debugging memory related problems (*note Debugging::).
-
-FFT Multiplication, `--disable-fft'
-     By default multiplications are done using Karatsuba, 3-way Toom,
-     and Fermat FFT.  The FFT is only used on large to very large
-     operands and can be disabled to save code size if desired.
-
-Berkeley MP, `--enable-mpbsd'
-     The Berkeley MP compatibility library (`libmp') and header file
-     (`mp.h') are built and installed only if `--enable-mpbsd' is used.
-     *Note BSD Compatible Functions::.
-
-Assertion Checking, `--enable-assert'
-     This option enables some consistency checking within the library.
-     This can be of use while debugging, *note Debugging::.
-
-Execution Profiling, `--enable-profiling=prof/gprof/instrument'
-     Enable profiling support, in one of various styles, *note
-     Profiling::.
-
-`MPN_PATH'
-     Various assembly versions of each mpn subroutines are provided.
-     For a given CPU, a search is made though a path to choose a
-     version of each.  For example `sparcv8' has
-
-          MPN_PATH="sparc32/v8 sparc32 generic"
-
-     which means look first for v8 code, then plain sparc32 (which is
-     v7), and finally fall back on generic C.  Knowledgeable users with
-     special requirements can specify a different path.  Normally this
-     is completely unnecessary.
-
-Documentation
-     The source for the document you're now reading is `doc/gmp.texi',
-     in Texinfo format, see *Note Texinfo: (texinfo)Top.
-
-     Info format `doc/gmp.info' is included in the distribution.  The
-     usual automake targets are available to make PostScript, DVI, PDF
-     and HTML (these will require various TeX and Texinfo tools).
-
-     DocBook and XML can be generated by the Texinfo `makeinfo' program
-     too, see *Note Options for `makeinfo': (texinfo)makeinfo options.
-
-     Some supplementary notes can also be found in the `doc'
-     subdirectory.
-
-
-
-File: gmp.info,  Node: ABI and ISA,  Next: Notes for Package Builds,  Prev: Build Options,  Up: Installing GMP
-
-2.2 ABI and ISA
-===============
-
-ABI (Application Binary Interface) refers to the calling conventions
-between functions, meaning what registers are used and what sizes the
-various C data types are.  ISA (Instruction Set Architecture) refers to
-the instructions and registers a CPU has available.
-
-   Some 64-bit ISA CPUs have both a 64-bit ABI and a 32-bit ABI
-defined, the latter for compatibility with older CPUs in the family.
-GMP supports some CPUs like this in both ABIs.  In fact within GMP
-`ABI' means a combination of chip ABI, plus how GMP chooses to use it.
-For example in some 32-bit ABIs, GMP may support a limb as either a
-32-bit `long' or a 64-bit `long long'.
-
-   By default GMP chooses the best ABI available for a given system,
-and this generally gives significantly greater speed.  But an ABI can
-be chosen explicitly to make GMP compatible with other libraries, or
-particular application requirements.  For example,
-
-     ./configure ABI=32
-
-   In all cases it's vital that all object code used in a given program
-is compiled for the same ABI.
-
-   Usually a limb is implemented as a `long'.  When a `long long' limb
-is used this is encoded in the generated `gmp.h'.  This is convenient
-for applications, but it does mean that `gmp.h' will vary, and can't be
-just copied around.  `gmp.h' remains compiler independent though, since
-all compilers for a particular ABI will be expected to use the same
-limb type.
-
-   Currently no attempt is made to follow whatever conventions a system
-has for installing library or header files built for a particular ABI.
-This will probably only matter when installing multiple builds of GMP,
-and it might be as simple as configuring with a special `libdir', or it
-might require more than that.  Note that builds for different ABIs need
-to done separately, with a fresh `./configure' and `make' each.
-
-
-AMD64 (`x86_64')
-     On AMD64 systems supporting both 32-bit and 64-bit modes for
-     applications, the following ABI choices are available.
-
-    `ABI=64'
-          The 64-bit ABI uses 64-bit limbs and pointers and makes full
-          use of the chip architecture.  This is the default.
-          Applications will usually not need special compiler flags,
-          but for reference the option is
-
-               gcc  -m64
-
-    `ABI=32'
-          The 32-bit ABI is the usual i386 conventions.  This will be
-          slower, and is not recommended except for inter-operating
-          with other code not yet 64-bit capable.  Applications must be
-          compiled with
-
-               gcc  -m32
-
-          (In GCC 2.95 and earlier there's no `-m32' option, it's the
-          only mode.)
-
-
-HPPA 2.0 (`hppa2.0*', `hppa64')
-
-    `ABI=2.0w'
-          The 2.0w ABI uses 64-bit limbs and pointers and is available
-          on HP-UX 11 or up.  Applications must be compiled with
-
-               gcc [built for 2.0w]
-               cc  +DD64
-
-    `ABI=2.0n'
-          The 2.0n ABI means the 32-bit HPPA 1.0 ABI and all its normal
-          calling conventions, but with 64-bit instructions permitted
-          within functions.  GMP uses a 64-bit `long long' for a limb.
-          This ABI is available on hppa64 GNU/Linux and on HP-UX 10 or
-          higher.  Applications must be compiled with
-
-               gcc [built for 2.0n]
-               cc  +DA2.0 +e
-
-          Note that current versions of GCC (eg. 3.2) don't generate
-          64-bit instructions for `long long' operations and so may be
-          slower than for 2.0w.  (The GMP assembly code is the same
-          though.)
-
-    `ABI=1.0'
-          HPPA 2.0 CPUs can run all HPPA 1.0 and 1.1 code in the 32-bit
-          HPPA 1.0 ABI.  No special compiler options are needed for
-          applications.
-
-     All three ABIs are available for CPU types `hppa2.0w', `hppa2.0'
-     and `hppa64', but for CPU type `hppa2.0n' only 2.0n or 1.0 are
-     considered.
-
-     Note that GCC on HP-UX has no options to choose between 2.0n and
-     2.0w modes, unlike HP `cc'.  Instead it must be built for one or
-     the other ABI.  GMP will detect how it was built, and skip to the
-     corresponding `ABI'.
-
-
-IA-64 under HP-UX (`ia64*-*-hpux*', `itanium*-*-hpux*')
-     HP-UX supports two ABIs for IA-64.  GMP performance is the same in
-     both.
-
-    `ABI=32'
-          In the 32-bit ABI, pointers, `int's and `long's are 32 bits
-          and GMP uses a 64 bit `long long' for a limb.  Applications
-          can be compiled without any special flags since this ABI is
-          the default in both HP C and GCC, but for reference the flags
-          are
-
-               gcc  -milp32
-               cc   +DD32
-
-    `ABI=64'
-          In the 64-bit ABI, `long's and pointers are 64 bits and GMP
-          uses a `long' for a limb.  Applications must be compiled with
-
-               gcc  -mlp64
-               cc   +DD64
-
-     On other IA-64 systems, GNU/Linux for instance, `ABI=64' is the
-     only choice.
-
-
-MIPS under IRIX 6 (`mips*-*-irix[6789]')
-     IRIX 6 always has a 64-bit MIPS 3 or better CPU, and supports ABIs
-     o32, n32, and 64.  n32 or 64 are recommended, and GMP performance
-     will be the same in each.  The default is n32.
-
-    `ABI=o32'
-          The o32 ABI is 32-bit pointers and integers, and no 64-bit
-          operations.  GMP will be slower than in n32 or 64, this
-          option only exists to support old compilers, eg. GCC 2.7.2.
-          Applications can be compiled with no special flags on an old
-          compiler, or on a newer compiler with
-
-               gcc  -mabi=32
-               cc   -32
-
-    `ABI=n32'
-          The n32 ABI is 32-bit pointers and integers, but with a
-          64-bit limb using a `long long'.  Applications must be
-          compiled with
-
-               gcc  -mabi=n32
-               cc   -n32
-
-    `ABI=64'
-          The 64-bit ABI is 64-bit pointers and integers.  Applications
-          must be compiled with
-
-               gcc  -mabi=64
-               cc   -64
-
-     Note that MIPS GNU/Linux, as of kernel version 2.2, doesn't have
-     the necessary support for n32 or 64 and so only gets a 32-bit limb
-     and the MIPS 2 code.
-
-
-PowerPC 64 (`powerpc64', `powerpc620', `powerpc630', `powerpc970', `power4', `power5')
-
-    `ABI=aix64'
-          The AIX 64 ABI uses 64-bit limbs and pointers and is the
-          default on PowerPC 64 `*-*-aix*' systems.  Applications must
-          be compiled with
-
-               gcc  -maix64
-               xlc  -q64
-
-    `ABI=mode64'
-          The `mode64' ABI uses 64-bit limbs and pointers, and is the
-          default on 64-bit GNU/Linux, BSD, and Mac OS X/Darwin
-          systems.  Applications must be compiled with
-
-               gcc  -m64
-
-    `ABI=mode32'
-          The `mode32' ABI uses a 64-bit `long long' limb but with the
-          chip still in 32-bit mode and using 32-bit calling
-          conventions.  This is the default for systems where the true
-          64-bit ABI is unavailable.  No special compiler options are
-          typically needed for applications.
-
-    `ABI=32'
-          This is the basic 32-bit PowerPC ABI, with a 32-bit limb.  No
-          special compiler options are needed for applications.
-
-     GMP's speed is greatest for `aix64' and `mode64'.  In `ABI=32'
-     only the 32-bit ISA is used and this doesn't make full use of a
-     64-bit chip.  On a suitable system we could perhaps use more of
-     the ISA, but there are no plans to do so.
-
-
-Sparc V9 (`sparc64', `sparcv9', `ultrasparc*')
-
-    `ABI=64'
-          The 64-bit V9 ABI is available on the various BSD sparc64
-          ports, recent versions of Sparc64 GNU/Linux, and Solaris 2.7
-          and up (when the kernel is in 64-bit mode).  GCC 3.2 or
-          higher, or Sun `cc' is required.  On GNU/Linux, depending on
-          the default `gcc' mode, applications must be compiled with
-
-               gcc  -m64
-
-          On Solaris applications must be compiled with
-
-               gcc  -m64 -mptr64 -Wa,-xarch=v9 -mcpu=v9
-               cc   -xarch=v9
-
-          On the BSD sparc64 systems no special options are required,
-          since 64-bits is the only ABI available.
-
-    `ABI=32'
-          For the basic 32-bit ABI, GMP still uses as much of the V9
-          ISA as it can.  In the Sun documentation this combination is
-          known as "v8plus".  On GNU/Linux, depending on the default
-          `gcc' mode, applications may need to be compiled with
-
-               gcc  -m32
-
-          On Solaris, no special compiler options are required for
-          applications, though using something like the following is
-          recommended.  (`gcc' 2.8 and earlier only support `-mv8'
-          though.)
-
-               gcc  -mv8plus
-               cc   -xarch=v8plus
-
-     GMP speed is greatest in `ABI=64', so it's the default where
-     available.  The speed is partly because there are extra registers
-     available and partly because 64-bits is considered the more
-     important case and has therefore had better code written for it.
-
-     Don't be confused by the names of the `-m' and `-x' compiler
-     options, they're called `arch' but effectively control both ABI
-     and ISA.
-
-     On Solaris 2.6 and earlier, only `ABI=32' is available since the
-     kernel doesn't save all registers.
-
-     On Solaris 2.7 with the kernel in 32-bit mode, a normal native
-     build will reject `ABI=64' because the resulting executables won't
-     run.  `ABI=64' can still be built if desired by making it look
-     like a cross-compile, for example
-
-          ./configure --build=none --host=sparcv9-sun-solaris2.7 ABI=64
-
-
-File: gmp.info,  Node: Notes for Package Builds,  Next: Notes for Particular Systems,  Prev: ABI and ISA,  Up: Installing GMP
-
-2.3 Notes for Package Builds
-============================
-
-GMP should present no great difficulties for packaging in a binary
-distribution.
-
-   Libtool is used to build the library and `-version-info' is set
-appropriately, having started from `3:0:0' in GMP 3.0 (*note Library
-interface versions: (libtool)Versioning.).
-
-   The GMP 4 series will be upwardly binary compatible in each release
-and will be upwardly binary compatible with all of the GMP 3 series.
-Additional function interfaces may be added in each release, so on
-systems where libtool versioning is not fully checked by the loader an
-auxiliary mechanism may be needed to express that a dynamic linked
-application depends on a new enough GMP.
-
-   An auxiliary mechanism may also be needed to express that
-`libgmpxx.la' (from `--enable-cxx', *note Build Options::) requires
-`libgmp.la' from the same GMP version, since this is not done by the
-libtool versioning, nor otherwise.  A mismatch will result in
-unresolved symbols from the linker, or perhaps the loader.
-
-   When building a package for a CPU family, care should be taken to use
-`--host' (or `--build') to choose the least common denominator among
-the CPUs which might use the package.  For example this might mean plain
-`sparc' (meaning V7) for SPARCs.
-
-   For x86s, `--enable-fat' sets things up for a fat binary build,
-making a runtime selection of optimized low level routines.  This is a
-good choice for packaging to run on a range of x86 chips.
-
-   Users who care about speed will want GMP built for their exact CPU
-type, to make best use of the available optimizations.  Providing a way
-to suitably rebuild a package may be useful.  This could be as simple
-as making it possible for a user to omit `--build' (and `--host') so
-`./config.guess' will detect the CPU.  But a way to manually specify a
-`--build' will be wanted for systems where `./config.guess' is inexact.
-
-   On systems with multiple ABIs, a packaged build will need to decide
-which among the choices is to be provided, see *Note ABI and ISA::.  A
-given run of `./configure' etc will only build one ABI.  If a second
-ABI is also required then a second run of `./configure' etc must be
-made, starting from a clean directory tree (`make distclean').
-
-   As noted under "ABI and ISA", currently no attempt is made to follow
-system conventions for install locations that vary with ABI, such as
-`/usr/lib/sparcv9' for `ABI=64' as opposed to `/usr/lib' for `ABI=32'.
-A package build can override `libdir' and other standard variables as
-necessary.
-
-   Note that `gmp.h' is a generated file, and will be architecture and
-ABI dependent.  When attempting to install two ABIs simultaneously it
-will be important that an application compile gets the correct `gmp.h'
-for its desired ABI.  If compiler include paths don't vary with ABI
-options then it might be necessary to create a `/usr/include/gmp.h'
-which tests preprocessor symbols and chooses the correct actual `gmp.h'.
-
-
-File: gmp.info,  Node: Notes for Particular Systems,  Next: Known Build Problems,  Prev: Notes for Package Builds,  Up: Installing GMP
-
-2.4 Notes for Particular Systems
-================================
-
-AIX 3 and 4
-     On systems `*-*-aix[34]*' shared libraries are disabled by
-     default, since some versions of the native `ar' fail on the
-     convenience libraries used.  A shared build can be attempted with
-
-          ./configure --enable-shared --disable-static
-
-     Note that the `--disable-static' is necessary because in a shared
-     build libtool makes `libgmp.a' a symlink to `libgmp.so',
-     apparently for the benefit of old versions of `ld' which only
-     recognise `.a', but unfortunately this is done even if a fully
-     functional `ld' is available.
-
-ARM
-     On systems `arm*-*-*', versions of GCC up to and including 2.95.3
-     have a bug in unsigned division, giving wrong results for some
-     operands.  GMP `./configure' will demand GCC 2.95.4 or later.
-
-Compaq C++
-     Compaq C++ on OSF 5.1 has two flavours of `iostream', a standard
-     one and an old pre-standard one (see `man iostream_intro').  GMP
-     can only use the standard one, which unfortunately is not the
-     default but must be selected by defining `__USE_STD_IOSTREAM'.
-     Configure with for instance
-
-          ./configure --enable-cxx CPPFLAGS=-D__USE_STD_IOSTREAM
-
-Floating Point Mode
-     On some systems, the hardware floating point has a control mode
-     which can set all operations to be done in a particular precision,
-     for instance single, double or extended on x86 systems (x87
-     floating point).  The GMP functions involving a `double' cannot be
-     expected to operate to their full precision when the hardware is
-     in single precision mode.  Of course this affects all code,
-     including application code, not just GMP.
-
-MS-DOS and MS Windows
-     On an MS-DOS system DJGPP can be used to build GMP, and on an MS
-     Windows system Cygwin, DJGPP and MINGW can be used.  All three are
-     excellent ports of GCC and the various GNU tools.
-
-          `http://www.cygwin.com/'
-          `http://www.delorie.com/djgpp/'
-          `http://www.mingw.org/'
-
-     Microsoft also publishes an Interix "Services for Unix" which can
-     be used to build GMP on Windows (with a normal `./configure'), but
-     it's not free software.
-
-MS Windows DLLs
-     On systems `*-*-cygwin*', `*-*-mingw*' and `*-*-pw32*' by default
-     GMP builds only a static library, but a DLL can be built instead
-     using
-
-          ./configure --disable-static --enable-shared
-
-     Static and DLL libraries can't both be built, since certain export
-     directives in `gmp.h' must be different.
-
-     A MINGW DLL build of GMP can be used with Microsoft C.  Libtool
-     doesn't install a `.lib' format import library, but it can be
-     created with MS `lib' as follows, and copied to the install
-     directory.  Similarly for `libmp' and `libgmpxx'.
-
-          cd .libs
-          lib /def:libgmp-3.dll.def /out:libgmp-3.lib
-
-     MINGW uses the C runtime library `msvcrt.dll' for I/O, so
-     applications wanting to use the GMP I/O routines must be compiled
-     with `cl /MD' to do the same.  If one of the other C runtime
-     library choices provided by MS C is desired then the suggestion is
-     to use the GMP string functions and confine I/O to the application.
-
-Motorola 68k CPU Types
-     `m68k' is taken to mean 68000.  `m68020' or higher will give a
-     performance boost on applicable CPUs.  `m68360' can be used for
-     CPU32 series chips.  `m68302' can be used for "Dragonball" series
-     chips, though this is merely a synonym for `m68000'.
-
-OpenBSD 2.6
-     `m4' in this release of OpenBSD has a bug in `eval' that makes it
-     unsuitable for `.asm' file processing.  `./configure' will detect
-     the problem and either abort or choose another m4 in the `PATH'.
-     The bug is fixed in OpenBSD 2.7, so either upgrade or use GNU m4.
-
-Power CPU Types
-     In GMP, CPU types `power*' and `powerpc*' will each use
-     instructions not available on the other, so it's important to
-     choose the right one for the CPU that will be used.  Currently GMP
-     has no assembly code support for using just the common instruction
-     subset.  To get executables that run on both, the current
-     suggestion is to use the generic C code (CPU `none'), possibly
-     with appropriate compiler options (like `-mcpu=common' for `gcc').
-     CPU `rs6000' (which is not a CPU but a family of workstations) is
-     accepted by `config.sub', but is currently equivalent to `none'.
-
-Sparc CPU Types
-     `sparcv8' or `supersparc' on relevant systems will give a
-     significant performance increase over the V7 code selected by plain
-     `sparc'.
-
-Sparc App Regs
-     The GMP assembly code for both 32-bit and 64-bit Sparc clobbers the
-     "application registers" `g2', `g3' and `g4', the same way that the
-     GCC default `-mapp-regs' does (*note SPARC Options: (gcc)SPARC
-     Options.).
-
-     This makes that code unsuitable for use with the special V9
-     `-mcmodel=embmedany' (which uses `g4' as a data segment pointer),
-     and for applications wanting to use those registers for special
-     purposes.  In these cases the only suggestion currently is to
-     build GMP with CPU `none' to avoid the assembly code.
-
-SunOS 4
-     `/usr/bin/m4' lacks various features needed to process `.asm'
-     files, and instead `./configure' will automatically use
-     `/usr/5bin/m4', which we believe is always available (if not then
-     use GNU m4).
-
-x86 CPU Types
-     `i586', `pentium' or `pentiummmx' code is good for its intended P5
-     Pentium chips, but quite slow when run on Intel P6 class chips
-     (PPro, P-II, P-III).  `i386' is a better choice when making
-     binaries that must run on both.
-
-x86 MMX and SSE2 Code
-     If the CPU selected has MMX code but the assembler doesn't support
-     it, a warning is given and non-MMX code is used instead.  This
-     will be an inferior build, since the MMX code that's present is
-     there because it's faster than the corresponding plain integer
-     code.  The same applies to SSE2.
-
-     Old versions of `gas' don't support MMX instructions, in particular
-     version 1.92.3 that comes with FreeBSD 2.2.8 or the more recent
-     OpenBSD 3.1 doesn't.
-
-     Solaris 2.6 and 2.7 `as' generate incorrect object code for
-     register to register `movq' instructions, and so can't be used for
-     MMX code.  Install a recent `gas' if MMX code is wanted on these
-     systems.
-
-
-File: gmp.info,  Node: Known Build Problems,  Next: Performance optimization,  Prev: Notes for Particular Systems,  Up: Installing GMP
-
-2.5 Known Build Problems
-========================
-
-You might find more up-to-date information at `http://gmplib.org/'.
-
-Compiler link options
-     The version of libtool currently in use rather aggressively strips
-     compiler options when linking a shared library.  This will
-     hopefully be relaxed in the future, but for now if this is a
-     problem the suggestion is to create a little script to hide them,
-     and for instance configure with
-
-          ./configure CC=gcc-with-my-options
-
-DJGPP (`*-*-msdosdjgpp*')
-     The DJGPP port of `bash' 2.03 is unable to run the `configure'
-     script, it exits silently, having died writing a preamble to
-     `config.log'.  Use `bash' 2.04 or higher.
-
-     `make all' was found to run out of memory during the final
-     `libgmp.la' link on one system tested, despite having 64Mb
-     available.  Running `make libgmp.la' directly helped, perhaps
-     recursing into the various subdirectories uses up memory.
-
-GNU binutils `strip' prior to 2.12
-     `strip' from GNU binutils 2.11 and earlier should not be used on
-     the static libraries `libgmp.a' and `libmp.a' since it will
-     discard all but the last of multiple archive members with the same
-     name, like the three versions of `init.o' in `libgmp.a'.  Binutils
-     2.12 or higher can be used successfully.
-
-     The shared libraries `libgmp.so' and `libmp.so' are not affected by
-     this and any version of `strip' can be used on them.
-
-`make' syntax error
-     On certain versions of SCO OpenServer 5 and IRIX 6.5 the native
-     `make' is unable to handle the long dependencies list for
-     `libgmp.la'.  The symptom is a "syntax error" on the following
-     line of the top-level `Makefile'.
-
-          libgmp.la: $(libgmp_la_OBJECTS) $(libgmp_la_DEPENDENCIES)
-
-     Either use GNU Make, or as a workaround remove
-     `$(libgmp_la_DEPENDENCIES)' from that line (which will make the
-     initial build work, but if any recompiling is done `libgmp.la'
-     might not be rebuilt).
-
-MacOS X (`*-*-darwin*')
-     Libtool currently only knows how to create shared libraries on
-     MacOS X using the native `cc' (which is a modified GCC), not a
-     plain GCC.  A static-only build should work though
-     (`--disable-shared').
-
-NeXT prior to 3.3
-     The system compiler on old versions of NeXT was a massacred and
-     old GCC, even if it called itself `cc'.  This compiler cannot be
-     used to build GMP, you need to get a real GCC, and install that.
-     (NeXT may have fixed this in release 3.3 of their system.)
-
-POWER and PowerPC
-     Bugs in GCC 2.7.2 (and 2.6.3) mean it can't be used to compile GMP
-     on POWER or PowerPC.  If you want to use GCC for these machines,
-     get GCC 2.7.2.1 (or later).
-
-Sequent Symmetry
-     Use the GNU assembler instead of the system assembler, since the
-     latter has serious bugs.
-
-Solaris 2.6
-     The system `sed' prints an error "Output line too long" when
-     libtool builds `libgmp.la'.  This doesn't seem to cause any
-     obvious ill effects, but GNU `sed' is recommended, to avoid any
-     doubt.
-
-Sparc Solaris 2.7 with gcc 2.95.2 in `ABI=32'
-     A shared library build of GMP seems to fail in this combination,
-     it builds but then fails the tests, apparently due to some
-     incorrect data relocations within `gmp_randinit_lc_2exp_size'.
-     The exact cause is unknown, `--disable-shared' is recommended.
-
-
-File: gmp.info,  Node: Performance optimization,  Prev: Known Build Problems,  Up: Installing GMP
-
-2.6 Performance optimization
-============================
-
-For optimal performance, build GMP for the exact CPU type of the target
-computer, see *Note Build Options::.
-
-   Unlike what is the case for most other programs, the compiler
-typically doesn't matter much, since GMP uses assembly language for the
-most critical operation.
-
-   In particular for long-running GMP applications, and applications
-demanding extremely large numbers, building and running the `tuneup'
-program in the `tune' subdirectory, can be important.  For example,
-
-     cd tune
-     make tuneup
-     ./tuneup
-
-   will generate better contents for the `gmp-mparam.h' parameter file.
-
-   To use the results, put the output in the file indicated in the
-`Parameters for ...' header.  Then recompile from scratch.
-
-   The `tuneup' program takes one useful parameter, `-f NNN', which
-instructs the program how long to check FFT multiply parameters.  If
-you're going to use GMP for extremely large numbers, you may want to
-run `tuneup' with a large NNN value.
-
-
-File: gmp.info,  Node: GMP Basics,  Next: Reporting Bugs,  Prev: Installing GMP,  Up: Top
-
-3 GMP Basics
-************
-
-*Using functions, macros, data types, etc. not documented in this
-manual is strongly discouraged.  If you do so your application is
-guaranteed to be incompatible with future versions of GMP.*
-
-* Menu:
-
-* Headers and Libraries::
-* Nomenclature and Types::
-* Function Classes::
-* Variable Conventions::
-* Parameter Conventions::
-* Memory Management::
-* Reentrancy::
-* Useful Macros and Constants::
-* Compatibility with older versions::
-* Demonstration Programs::
-* Efficiency::
-* Debugging::
-* Profiling::
-* Autoconf::
-* Emacs::
-
-
-File: gmp.info,  Node: Headers and Libraries,  Next: Nomenclature and Types,  Prev: GMP Basics,  Up: GMP Basics
-
-3.1 Headers and Libraries
-=========================
-
-All declarations needed to use GMP are collected in the include file
-`gmp.h'.  It is designed to work with both C and C++ compilers.
-
-     #include <gmp.h>
-
-   Note however that prototypes for GMP functions with `FILE *'
-parameters are only provided if `<stdio.h>' is included too.
-
-     #include <stdio.h>
-     #include <gmp.h>
-
-   Likewise `<stdarg.h>' (or `<varargs.h>') is required for prototypes
-with `va_list' parameters, such as `gmp_vprintf'.  And `<obstack.h>'
-for prototypes with `struct obstack' parameters, such as
-`gmp_obstack_printf', when available.
-
-   All programs using GMP must link against the `libgmp' library.  On a
-typical Unix-like system this can be done with `-lgmp', for example
-
-     gcc myprogram.c -lgmp
-
-   GMP C++ functions are in a separate `libgmpxx' library.  This is
-built and installed if C++ support has been enabled (*note Build
-Options::).  For example,
-
-     g++ mycxxprog.cc -lgmpxx -lgmp
-
-   GMP is built using Libtool and an application can use that to link
-if desired, *note GNU Libtool: (libtool)Top.
-
-   If GMP has been installed to a non-standard location then it may be
-necessary to use `-I' and `-L' compiler options to point to the right
-directories, and some sort of run-time path for a shared library.
-
-
-File: gmp.info,  Node: Nomenclature and Types,  Next: Function Classes,  Prev: Headers and Libraries,  Up: GMP Basics
-
-3.2 Nomenclature and Types
-==========================
-
-In this manual, "integer" usually means a multiple precision integer, as
-defined by the GMP library.  The C data type for such integers is
-`mpz_t'.  Here are some examples of how to declare such integers:
-
-     mpz_t sum;
-
-     struct foo { mpz_t x, y; };
-
-     mpz_t vec[20];
-
-   "Rational number" means a multiple precision fraction.  The C data
-type for these fractions is `mpq_t'.  For example:
-
-     mpq_t quotient;
-
-   "Floating point number" or "Float" for short, is an arbitrary
-precision mantissa with a limited precision exponent.  The C data type
-for such objects is `mpf_t'.  For example:
-
-     mpf_t fp;
-
-   The floating point functions accept and return exponents in the C
-type `mp_exp_t'.  Currently this is usually a `long', but on some
-systems it's an `int' for efficiency.
-
-   A "limb" means the part of a multi-precision number that fits in a
-single machine word.  (We chose this word because a limb of the human
-body is analogous to a digit, only larger, and containing several
-digits.)  Normally a limb is 32 or 64 bits.  The C data type for a limb
-is `mp_limb_t'.
-
-   Counts of limbs of a multi-precision number represented in the C type
-`mp_size_t'.  Currently this is normally a `long', but on some systems
-it's an `int' for efficiency, and on some systems it will be `long
-long' in the future.
-
-   Counts of bits of a multi-precision number are represented in the C
-type `mp_bitcnt_t'.  Currently this is always an `unsigned long', but on
-some systems it will be an `unsigned long long' in the future .
-
-   "Random state" means an algorithm selection and current state data.
-The C data type for such objects is `gmp_randstate_t'.  For example:
-
-     gmp_randstate_t rstate;
-
-   Also, in general `mp_bitcnt_t' is used for bit counts and ranges, and
-`size_t' is used for byte or character counts.
-
-
-File: gmp.info,  Node: Function Classes,  Next: Variable Conventions,  Prev: Nomenclature and Types,  Up: GMP Basics
-
-3.3 Function Classes
-====================
-
-There are six classes of functions in the GMP library:
-
-  1. Functions for signed integer arithmetic, with names beginning with
-     `mpz_'.  The associated type is `mpz_t'.  There are about 150
-     functions in this class.  (*note Integer Functions::)
-
-  2. Functions for rational number arithmetic, with names beginning with
-     `mpq_'.  The associated type is `mpq_t'.  There are about 40
-     functions in this class, but the integer functions can be used for
-     arithmetic on the numerator and denominator separately.  (*note
-     Rational Number Functions::)
-
-  3. Functions for floating-point arithmetic, with names beginning with
-     `mpf_'.  The associated type is `mpf_t'.  There are about 60
-     functions is this class.  (*note Floating-point Functions::)
-
-  4. Functions compatible with Berkeley MP, such as `itom', `madd', and
-     `mult'.  The associated type is `MINT'.  (*note BSD Compatible
-     Functions::)
-
-  5. Fast low-level functions that operate on natural numbers.  These
-     are used by the functions in the preceding groups, and you can
-     also call them directly from very time-critical user programs.
-     These functions' names begin with `mpn_'.  The associated type is
-     array of `mp_limb_t'.  There are about 30 (hard-to-use) functions
-     in this class.  (*note Low-level Functions::)
-
-  6. Miscellaneous functions.  Functions for setting up custom
-     allocation and functions for generating random numbers.  (*note
-     Custom Allocation::, and *note Random Number Functions::)
-
-
-File: gmp.info,  Node: Variable Conventions,  Next: Parameter Conventions,  Prev: Function Classes,  Up: GMP Basics
-
-3.4 Variable Conventions
-========================
-
-GMP functions generally have output arguments before input arguments.
-This notation is by analogy with the assignment operator.  The BSD MP
-compatibility functions are exceptions, having the output arguments
-last.
-
-   GMP lets you use the same variable for both input and output in one
-call.  For example, the main function for integer multiplication,
-`mpz_mul', can be used to square `x' and put the result back in `x' with
-
-     mpz_mul (x, x, x);
-
-   Before you can assign to a GMP variable, you need to initialize it
-by calling one of the special initialization functions.  When you're
-done with a variable, you need to clear it out, using one of the
-functions for that purpose.  Which function to use depends on the type
-of variable.  See the chapters on integer functions, rational number
-functions, and floating-point functions for details.
-
-   A variable should only be initialized once, or at least cleared
-between each initialization.  After a variable has been initialized, it
-may be assigned to any number of times.
-
-   For efficiency reasons, avoid excessive initializing and clearing.
-In general, initialize near the start of a function and clear near the
-end.  For example,
-
-     void
-     foo (void)
-     {
-       mpz_t  n;
-       int    i;
-       mpz_init (n);
-       for (i = 1; i < 100; i++)
-         {
-           mpz_mul (n, ...);
-           mpz_fdiv_q (n, ...);
-           ...
-         }
-       mpz_clear (n);
-     }
-
-
-File: gmp.info,  Node: Parameter Conventions,  Next: Memory Management,  Prev: Variable Conventions,  Up: GMP Basics
-
-3.5 Parameter Conventions
-=========================
-
-When a GMP variable is used as a function parameter, it's effectively a
-call-by-reference, meaning if the function stores a value there it will
-change the original in the caller.  Parameters which are input-only can
-be designated `const' to provoke a compiler error or warning on
-attempting to modify them.
-
-   When a function is going to return a GMP result, it should designate
-a parameter that it sets, like the library functions do.  More than one
-value can be returned by having more than one output parameter, again
-like the library functions.  A `return' of an `mpz_t' etc doesn't
-return the object, only a pointer, and this is almost certainly not
-what's wanted.
-
-   Here's an example accepting an `mpz_t' parameter, doing a
-calculation, and storing the result to the indicated parameter.
-
-     void
-     foo (mpz_t result, const mpz_t param, unsigned long n)
-     {
-       unsigned long  i;
-       mpz_mul_ui (result, param, n);
-       for (i = 1; i < n; i++)
-         mpz_add_ui (result, result, i*7);
-     }
-
-     int
-     main (void)
-     {
-       mpz_t  r, n;
-       mpz_init (r);
-       mpz_init_set_str (n, "123456", 0);
-       foo (r, n, 20L);
-       gmp_printf ("%Zd\n", r);
-       return 0;
-     }
-
-   `foo' works even if the mainline passes the same variable for
-`param' and `result', just like the library functions.  But sometimes
-it's tricky to make that work, and an application might not want to
-bother supporting that sort of thing.
-
-   For interest, the GMP types `mpz_t' etc are implemented as
-one-element arrays of certain structures.  This is why declaring a
-variable creates an object with the fields GMP needs, but then using it
-as a parameter passes a pointer to the object.  Note that the actual
-fields in each `mpz_t' etc are for internal use only and should not be
-accessed directly by code that expects to be compatible with future GMP
-releases.
-
-
-File: gmp.info,  Node: Memory Management,  Next: Reentrancy,  Prev: Parameter Conventions,  Up: GMP Basics
-
-3.6 Memory Management
-=====================
-
-The GMP types like `mpz_t' are small, containing only a couple of sizes,
-and pointers to allocated data.  Once a variable is initialized, GMP
-takes care of all space allocation.  Additional space is allocated
-whenever a variable doesn't have enough.
-
-   `mpz_t' and `mpq_t' variables never reduce their allocated space.
-Normally this is the best policy, since it avoids frequent reallocation.
-Applications that need to return memory to the heap at some particular
-point can use `mpz_realloc2', or clear variables no longer needed.
-
-   `mpf_t' variables, in the current implementation, use a fixed amount
-of space, determined by the chosen precision and allocated at
-initialization, so their size doesn't change.
-
-   All memory is allocated using `malloc' and friends by default, but
-this can be changed, see *Note Custom Allocation::.  Temporary memory
-on the stack is also used (via `alloca'), but this can be changed at
-build-time if desired, see *Note Build Options::.
-
-
-File: gmp.info,  Node: Reentrancy,  Next: Useful Macros and Constants,  Prev: Memory Management,  Up: GMP Basics
-
-3.7 Reentrancy
-==============
-
-GMP is reentrant and thread-safe, with some exceptions:
-
-   * If configured with `--enable-alloca=malloc-notreentrant' (or with
-     `--enable-alloca=notreentrant' when `alloca' is not available),
-     then naturally GMP is not reentrant.
-
-   * `mpf_set_default_prec' and `mpf_init' use a global variable for the
-     selected precision.  `mpf_init2' can be used instead, and in the
-     C++ interface an explicit precision to the `mpf_class' constructor.
-
-   * `mpz_random' and the other old random number functions use a global
-     random state and are hence not reentrant.  The newer random number
-     functions that accept a `gmp_randstate_t' parameter can be used
-     instead.
-
-   * `gmp_randinit' (obsolete) returns an error indication through a
-     global variable, which is not thread safe.  Applications are
-     advised to use `gmp_randinit_default' or `gmp_randinit_lc_2exp'
-     instead.
-
-   * `mp_set_memory_functions' uses global variables to store the
-     selected memory allocation functions.
-
-   * If the memory allocation functions set by a call to
-     `mp_set_memory_functions' (or `malloc' and friends by default) are
-     not reentrant, then GMP will not be reentrant either.
-
-   * If the standard I/O functions such as `fwrite' are not reentrant
-     then the GMP I/O functions using them will not be reentrant either.
-
-   * It's safe for two threads to read from the same GMP variable
-     simultaneously, but it's not safe for one to read while the
-     another might be writing, nor for two threads to write
-     simultaneously.  It's not safe for two threads to generate a
-     random number from the same `gmp_randstate_t' simultaneously,
-     since this involves an update of that variable.
-
-
-File: gmp.info,  Node: Useful Macros and Constants,  Next: Compatibility with older versions,  Prev: Reentrancy,  Up: GMP Basics
-
-3.8 Useful Macros and Constants
-===============================
-
- -- Global Constant: const int mp_bits_per_limb
-     The number of bits per limb.
-
- -- Macro: __GNU_MP_VERSION
- -- Macro: __GNU_MP_VERSION_MINOR
- -- Macro: __GNU_MP_VERSION_PATCHLEVEL
-     The major and minor GMP version, and patch level, respectively, as
-     integers.  For GMP i.j, these numbers will be i, j, and 0,
-     respectively.  For GMP i.j.k, these numbers will be i, j, and k,
-     respectively.
-
- -- Global Constant: const char * const gmp_version
-     The GMP version number, as a null-terminated string, in the form
-     "i.j.k".  This release is "5.0.2".  Note that the format "i.j" was
-     used when k was zero was used before version 4.3.0.
-
- -- Macro: __GMP_CC
- -- Macro: __GMP_CFLAGS
-     The compiler and compiler flags, respectively, used when compiling
-     GMP, as strings.
-
-
-File: gmp.info,  Node: Compatibility with older versions,  Next: Demonstration Programs,  Prev: Useful Macros and Constants,  Up: GMP Basics
-
-3.9 Compatibility with older versions
-=====================================
-
-This version of GMP is upwardly binary compatible with all 4.x and 3.x
-versions, and upwardly compatible at the source level with all 2.x
-versions, with the following exceptions.
-
-   * `mpn_gcd' had its source arguments swapped as of GMP 3.0, for
-     consistency with other `mpn' functions.
-
-   * `mpf_get_prec' counted precision slightly differently in GMP 3.0
-     and 3.0.1, but in 3.1 reverted to the 2.x style.
-
-   There are a number of compatibility issues between GMP 1 and GMP 2
-that of course also apply when porting applications from GMP 1 to GMP
-4.  Please see the GMP 2 manual for details.
-
-   The Berkeley MP compatibility library (*note BSD Compatible
-Functions::) is source and binary compatible with the standard `libmp'.
-
-
-File: gmp.info,  Node: Demonstration Programs,  Next: Efficiency,  Prev: Compatibility with older versions,  Up: GMP Basics
-
-3.10 Demonstration programs
-===========================
-
-The `demos' subdirectory has some sample programs using GMP.  These
-aren't built or installed, but there's a `Makefile' with rules for them.
-For instance,
-
-     make pexpr
-     ./pexpr 68^975+10
-
-The following programs are provided
-
-   * `pexpr' is an expression evaluator, the program used on the GMP
-     web page.
-
-   * The `calc' subdirectory has a similar but simpler evaluator using
-     `lex' and `yacc'.
-
-   * The `expr' subdirectory is yet another expression evaluator, a
-     library designed for ease of use within a C program.  See
-     `demos/expr/README' for more information.
-
-   * `factorize' is a Pollard-Rho factorization program.
-
-   * `isprime' is a command-line interface to the `mpz_probab_prime_p'
-     function.
-
-   * `primes' counts or lists primes in an interval, using a sieve.
-
-   * `qcn' is an example use of `mpz_kronecker_ui' to estimate quadratic
-     class numbers.
-
-   * The `perl' subdirectory is a comprehensive perl interface to GMP.
-     See `demos/perl/INSTALL' for more information.  Documentation is
-     in POD format in `demos/perl/GMP.pm'.
-
-   As an aside, consideration has been given at various times to some
-sort of expression evaluation within the main GMP library.  Going
-beyond something minimal quickly leads to matters like user-defined
-functions, looping, fixnums for control variables, etc, which are
-considered outside the scope of GMP (much closer to language
-interpreters or compilers, *Note Language Bindings::.)  Something
-simple for program input convenience may yet be a possibility, a
-combination of the `expr' demo and the `pexpr' tree back-end perhaps.
-But for now the above evaluators are offered as illustrations.
-
-
-File: gmp.info,  Node: Efficiency,  Next: Debugging,  Prev: Demonstration Programs,  Up: GMP Basics
-
-3.11 Efficiency
-===============
-
-Small Operands
-     On small operands, the time for function call overheads and memory
-     allocation can be significant in comparison to actual calculation.
-     This is unavoidable in a general purpose variable precision
-     library, although GMP attempts to be as efficient as it can on
-     both large and small operands.
-
-Static Linking
-     On some CPUs, in particular the x86s, the static `libgmp.a' should
-     be used for maximum speed, since the PIC code in the shared
-     `libgmp.so' will have a small overhead on each function call and
-     global data address.  For many programs this will be
-     insignificant, but for long calculations there's a gain to be had.
-
-Initializing and Clearing
-     Avoid excessive initializing and clearing of variables, since this
-     can be quite time consuming, especially in comparison to otherwise
-     fast operations like addition.
-
-     A language interpreter might want to keep a free list or stack of
-     initialized variables ready for use.  It should be possible to
-     integrate something like that with a garbage collector too.
-
-Reallocations
-     An `mpz_t' or `mpq_t' variable used to hold successively increasing
-     values will have its memory repeatedly `realloc'ed, which could be
-     quite slow or could fragment memory, depending on the C library.
-     If an application can estimate the final size then `mpz_init2' or
-     `mpz_realloc2' can be called to allocate the necessary space from
-     the beginning (*note Initializing Integers::).
-
-     It doesn't matter if a size set with `mpz_init2' or `mpz_realloc2'
-     is too small, since all functions will do a further reallocation
-     if necessary.  Badly overestimating memory required will waste
-     space though.
-
-`2exp' Functions
-     It's up to an application to call functions like `mpz_mul_2exp'
-     when appropriate.  General purpose functions like `mpz_mul' make
-     no attempt to identify powers of two or other special forms,
-     because such inputs will usually be very rare and testing every
-     time would be wasteful.
-
-`ui' and `si' Functions
-     The `ui' functions and the small number of `si' functions exist for
-     convenience and should be used where applicable.  But if for
-     example an `mpz_t' contains a value that fits in an `unsigned
-     long' there's no need extract it and call a `ui' function, just
-     use the regular `mpz' function.
-
-In-Place Operations
-     `mpz_abs', `mpq_abs', `mpf_abs', `mpz_neg', `mpq_neg' and
-     `mpf_neg' are fast when used for in-place operations like
-     `mpz_abs(x,x)', since in the current implementation only a single
-     field of `x' needs changing.  On suitable compilers (GCC for
-     instance) this is inlined too.
-
-     `mpz_add_ui', `mpz_sub_ui', `mpf_add_ui' and `mpf_sub_ui' benefit
-     from an in-place operation like `mpz_add_ui(x,x,y)', since usually
-     only one or two limbs of `x' will need to be changed.  The same
-     applies to the full precision `mpz_add' etc if `y' is small.  If
-     `y' is big then cache locality may be helped, but that's all.
-
-     `mpz_mul' is currently the opposite, a separate destination is
-     slightly better.  A call like `mpz_mul(x,x,y)' will, unless `y' is
-     only one limb, make a temporary copy of `x' before forming the
-     result.  Normally that copying will only be a tiny fraction of the
-     time for the multiply, so this is not a particularly important
-     consideration.
-
-     `mpz_set', `mpq_set', `mpq_set_num', `mpf_set', etc, make no
-     attempt to recognise a copy of something to itself, so a call like
-     `mpz_set(x,x)' will be wasteful.  Naturally that would never be
-     written deliberately, but if it might arise from two pointers to
-     the same object then a test to avoid it might be desirable.
-
-          if (x != y)
-            mpz_set (x, y);
-
-     Note that it's never worth introducing extra `mpz_set' calls just
-     to get in-place operations.  If a result should go to a particular
-     variable then just direct it there and let GMP take care of data
-     movement.
-
-Divisibility Testing (Small Integers)
-     `mpz_divisible_ui_p' and `mpz_congruent_ui_p' are the best
-     functions for testing whether an `mpz_t' is divisible by an
-     individual small integer.  They use an algorithm which is faster
-     than `mpz_tdiv_ui', but which gives no useful information about
-     the actual remainder, only whether it's zero (or a particular
-     value).
-
-     However when testing divisibility by several small integers, it's
-     best to take a remainder modulo their product, to save
-     multi-precision operations.  For instance to test whether a number
-     is divisible by any of 23, 29 or 31 take a remainder modulo
-     23*29*31 = 20677 and then test that.
-
-     The division functions like `mpz_tdiv_q_ui' which give a quotient
-     as well as a remainder are generally a little slower than the
-     remainder-only functions like `mpz_tdiv_ui'.  If the quotient is
-     only rarely wanted then it's probably best to just take a
-     remainder and then go back and calculate the quotient if and when
-     it's wanted (`mpz_divexact_ui' can be used if the remainder is
-     zero).
-
-Rational Arithmetic
-     The `mpq' functions operate on `mpq_t' values with no common
-     factors in the numerator and denominator.  Common factors are
-     checked-for and cast out as necessary.  In general, cancelling
-     factors every time is the best approach since it minimizes the
-     sizes for subsequent operations.
-
-     However, applications that know something about the factorization
-     of the values they're working with might be able to avoid some of
-     the GCDs used for canonicalization, or swap them for divisions.
-     For example when multiplying by a prime it's enough to check for
-     factors of it in the denominator instead of doing a full GCD.  Or
-     when forming a big product it might be known that very little
-     cancellation will be possible, and so canonicalization can be left
-     to the end.
-
-     The `mpq_numref' and `mpq_denref' macros give access to the
-     numerator and denominator to do things outside the scope of the
-     supplied `mpq' functions.  *Note Applying Integer Functions::.
-
-     The canonical form for rationals allows mixed-type `mpq_t' and
-     integer additions or subtractions to be done directly with
-     multiples of the denominator.  This will be somewhat faster than
-     `mpq_add'.  For example,
-
-          /* mpq increment */
-          mpz_add (mpq_numref(q), mpq_numref(q), mpq_denref(q));
-
-          /* mpq += unsigned long */
-          mpz_addmul_ui (mpq_numref(q), mpq_denref(q), 123UL);
-
-          /* mpq -= mpz */
-          mpz_submul (mpq_numref(q), mpq_denref(q), z);
-
-Number Sequences
-     Functions like `mpz_fac_ui', `mpz_fib_ui' and `mpz_bin_uiui' are
-     designed for calculating isolated values.  If a range of values is
-     wanted it's probably best to call to get a starting point and
-     iterate from there.
-
-Text Input/Output
-     Hexadecimal or octal are suggested for input or output in text
-     form.  Power-of-2 bases like these can be converted much more
-     efficiently than other bases, like decimal.  For big numbers
-     there's usually nothing of particular interest to be seen in the
-     digits, so the base doesn't matter much.
-
-     Maybe we can hope octal will one day become the normal base for
-     everyday use, as proposed by King Charles XII of Sweden and later
-     reformers.
-
-
-File: gmp.info,  Node: Debugging,  Next: Profiling,  Prev: Efficiency,  Up: GMP Basics
-
-3.12 Debugging
-==============
-
-Stack Overflow
-     Depending on the system, a segmentation violation or bus error
-     might be the only indication of stack overflow.  See
-     `--enable-alloca' choices in *Note Build Options::, for how to
-     address this.
-
-     In new enough versions of GCC, `-fstack-check' may be able to
-     ensure an overflow is recognised by the system before too much
-     damage is done, or `-fstack-limit-symbol' or
-     `-fstack-limit-register' may be able to add checking if the system
-     itself doesn't do any (*note Options for Code Generation:
-     (gcc)Code Gen Options.).  These options must be added to the
-     `CFLAGS' used in the GMP build (*note Build Options::), adding
-     them just to an application will have no effect.  Note also
-     they're a slowdown, adding overhead to each function call and each
-     stack allocation.
-
-Heap Problems
-     The most likely cause of application problems with GMP is heap
-     corruption.  Failing to `init' GMP variables will have
-     unpredictable effects, and corruption arising elsewhere in a
-     program may well affect GMP.  Initializing GMP variables more than
-     once or failing to clear them will cause memory leaks.
-
-     In all such cases a `malloc' debugger is recommended.  On a GNU or
-     BSD system the standard C library `malloc' has some diagnostic
-     facilities, see *Note Allocation Debugging: (libc)Allocation
-     Debugging, or `man 3 malloc'.  Other possibilities, in no
-     particular order, include
-
-          `http://www.inf.ethz.ch/personal/biere/projects/ccmalloc/'
-          `http://dmalloc.com/'
-          `http://www.perens.com/FreeSoftware/'  (electric fence)
-          `http://packages.debian.org/stable/devel/fda'
-          `http://www.gnupdate.org/components/leakbug/'
-          `http://people.redhat.com/~otaylor/memprof/'
-          `http://www.cbmamiga.demon.co.uk/mpatrol/'
-
-     The GMP default allocation routines in `memory.c' also have a
-     simple sentinel scheme which can be enabled with `#define DEBUG'
-     in that file.  This is mainly designed for detecting buffer
-     overruns during GMP development, but might find other uses.
-
-Stack Backtraces
-     On some systems the compiler options GMP uses by default can
-     interfere with debugging.  In particular on x86 and 68k systems
-     `-fomit-frame-pointer' is used and this generally inhibits stack
-     backtracing.  Recompiling without such options may help while
-     debugging, though the usual caveats about it potentially moving a
-     memory problem or hiding a compiler bug will apply.
-
-GDB, the GNU Debugger
-     A sample `.gdbinit' is included in the distribution, showing how
-     to call some undocumented dump functions to print GMP variables
-     from within GDB.  Note that these functions shouldn't be used in
-     final application code since they're undocumented and may be
-     subject to incompatible changes in future versions of GMP.
-
-Source File Paths
-     GMP has multiple source files with the same name, in different
-     directories.  For example `mpz', `mpq' and `mpf' each have an
-     `init.c'.  If the debugger can't already determine the right one
-     it may help to build with absolute paths on each C file.  One way
-     to do that is to use a separate object directory with an absolute
-     path to the source directory.
-
-          cd /my/build/dir
-          /my/source/dir/gmp-5.0.2/configure
-
-     This works via `VPATH', and might require GNU `make'.  Alternately
-     it might be possible to change the `.c.lo' rules appropriately.
-
-Assertion Checking
-     The build option `--enable-assert' is available to add some
-     consistency checks to the library (see *Note Build Options::).
-     These are likely to be of limited value to most applications.
-     Assertion failures are just as likely to indicate memory
-     corruption as a library or compiler bug.
-
-     Applications using the low-level `mpn' functions, however, will
-     benefit from `--enable-assert' since it adds checks on the
-     parameters of most such functions, many of which have subtle
-     restrictions on their usage.  Note however that only the generic C
-     code has checks, not the assembly code, so CPU `none' should be
-     used for maximum checking.
-
-Temporary Memory Checking
-     The build option `--enable-alloca=debug' arranges that each block
-     of temporary memory in GMP is allocated with a separate call to
-     `malloc' (or the allocation function set with
-     `mp_set_memory_functions').
-
-     This can help a malloc debugger detect accesses outside the
-     intended bounds, or detect memory not released.  In a normal
-     build, on the other hand, temporary memory is allocated in blocks
-     which GMP divides up for its own use, or may be allocated with a
-     compiler builtin `alloca' which will go nowhere near any malloc
-     debugger hooks.
-
-Maximum Debuggability
-     To summarize the above, a GMP build for maximum debuggability
-     would be
-
-          ./configure --disable-shared --enable-assert \
-            --enable-alloca=debug --host=none CFLAGS=-g
-
-     For C++, add `--enable-cxx CXXFLAGS=-g'.
-
-Checker
-     The GCC checker (`http://savannah.nongnu.org/projects/checker/')
-     can be used with GMP.  It contains a stub library which means GMP
-     applications compiled with checker can use a normal GMP build.
-
-     A build of GMP with checking within GMP itself can be made.  This
-     will run very very slowly.  On GNU/Linux for example,
-
-          ./configure --host=none-pc-linux-gnu CC=checkergcc
-
-     `--host=none' must be used, since the GMP assembly code doesn't
-     support the checking scheme.  The GMP C++ features cannot be used,
-     since current versions of checker (0.9.9.1) don't yet support the
-     standard C++ library.
-
-Valgrind
-     The valgrind program (`http://valgrind.org/') is a memory checker
-     for x86s.  It translates and emulates machine instructions to do
-     strong checks for uninitialized data (at the level of individual
-     bits), memory accesses through bad pointers, and memory leaks.
-
-     Recent versions of Valgrind are getting support for MMX and
-     SSE/SSE2 instructions, for past versions GMP will need to be
-     configured not to use those, ie. for an x86 without them (for
-     instance plain `i486').
-
-Other Problems
-     Any suspected bug in GMP itself should be isolated to make sure
-     it's not an application problem, see *Note Reporting Bugs::.
-
-
-File: gmp.info,  Node: Profiling,  Next: Autoconf,  Prev: Debugging,  Up: GMP Basics
-
-3.13 Profiling
-==============
-
-Running a program under a profiler is a good way to find where it's
-spending most time and where improvements can be best sought.  The
-profiling choices for a GMP build are as follows.
-
-`--disable-profiling'
-     The default is to add nothing special for profiling.
-
-     It should be possible to just compile the mainline of a program
-     with `-p' and use `prof' to get a profile consisting of
-     timer-based sampling of the program counter.  Most of the GMP
-     assembly code has the necessary symbol information.
-
-     This approach has the advantage of minimizing interference with
-     normal program operation, but on most systems the resolution of
-     the sampling is quite low (10 milliseconds for instance),
-     requiring long runs to get accurate information.
-
-`--enable-profiling=prof'
-     Build with support for the system `prof', which means `-p' added
-     to the `CFLAGS'.
-
-     This provides call counting in addition to program counter
-     sampling, which allows the most frequently called routines to be
-     identified, and an average time spent in each routine to be
-     determined.
-
-     The x86 assembly code has support for this option, but on other
-     processors the assembly routines will be as if compiled without
-     `-p' and therefore won't appear in the call counts.
-
-     On some systems, such as GNU/Linux, `-p' in fact means `-pg' and in
-     this case `--enable-profiling=gprof' described below should be used
-     instead.
-
-`--enable-profiling=gprof'
-     Build with support for `gprof', which means `-pg' added to the
-     `CFLAGS'.
-
-     This provides call graph construction in addition to call counting
-     and program counter sampling, which makes it possible to count
-     calls coming from different locations.  For example the number of
-     calls to `mpn_mul' from `mpz_mul' versus the number from
-     `mpf_mul'.  The program counter sampling is still flat though, so
-     only a total time in `mpn_mul' would be accumulated, not a
-     separate amount for each call site.
-
-     The x86 assembly code has support for this option, but on other
-     processors the assembly routines will be as if compiled without
-     `-pg' and therefore not be included in the call counts.
-
-     On x86 and m68k systems `-pg' and `-fomit-frame-pointer' are
-     incompatible, so the latter is omitted from the default flags in
-     that case, which might result in poorer code generation.
-
-     Incidentally, it should be possible to use the `gprof' program
-     with a plain `--enable-profiling=prof' build.  But in that case
-     only the `gprof -p' flat profile and call counts can be expected
-     to be valid, not the `gprof -q' call graph.
-
-`--enable-profiling=instrument'
-     Build with the GCC option `-finstrument-functions' added to the
-     `CFLAGS' (*note Options for Code Generation: (gcc)Code Gen
-     Options.).
-
-     This inserts special instrumenting calls at the start and end of
-     each function, allowing exact timing and full call graph
-     construction.
-
-     This instrumenting is not normally a standard system feature and
-     will require support from an external library, such as
-
-          `http://sourceforge.net/projects/fnccheck/'
-
-     This should be included in `LIBS' during the GMP configure so that
-     test programs will link.  For example,
-
-          ./configure --enable-profiling=instrument LIBS=-lfc
-
-     On a GNU system the C library provides dummy instrumenting
-     functions, so programs compiled with this option will link.  In
-     this case it's only necessary to ensure the correct library is
-     added when linking an application.
-
-     The x86 assembly code supports this option, but on other
-     processors the assembly routines will be as if compiled without
-     `-finstrument-functions' meaning time spent in them will
-     effectively be attributed to their caller.
-
-
-File: gmp.info,  Node: Autoconf,  Next: Emacs,  Prev: Profiling,  Up: GMP Basics
-
-3.14 Autoconf
-=============
-
-Autoconf based applications can easily check whether GMP is installed.
-The only thing to be noted is that GMP library symbols from version 3
-onwards have prefixes like `__gmpz'.  The following therefore would be
-a simple test,
-
-     AC_CHECK_LIB(gmp, __gmpz_init)
-
-   This just uses the default `AC_CHECK_LIB' actions for found or not
-found, but an application that must have GMP would want to generate an
-error if not found.  For example,
-
-     AC_CHECK_LIB(gmp, __gmpz_init, ,
-       [AC_MSG_ERROR([GNU MP not found, see http://gmplib.org/])])
-
-   If functions added in some particular version of GMP are required,
-then one of those can be used when checking.  For example `mpz_mul_si'
-was added in GMP 3.1,
-
-     AC_CHECK_LIB(gmp, __gmpz_mul_si, ,
-       [AC_MSG_ERROR(
-       [GNU MP not found, or not 3.1 or up, see http://gmplib.org/])])
-
-   An alternative would be to test the version number in `gmp.h' using
-say `AC_EGREP_CPP'.  That would make it possible to test the exact
-version, if some particular sub-minor release is known to be necessary.
-
-   In general it's recommended that applications should simply demand a
-new enough GMP rather than trying to provide supplements for features
-not available in past versions.
-
-   Occasionally an application will need or want to know the size of a
-type at configuration or preprocessing time, not just with `sizeof' in
-the code.  This can be done in the normal way with `mp_limb_t' etc, but
-GMP 4.0 or up is best for this, since prior versions needed certain
-`-D' defines on systems using a `long long' limb.  The following would
-suit Autoconf 2.50 or up,
-
-     AC_CHECK_SIZEOF(mp_limb_t, , [#include <gmp.h>])
-
-
-File: gmp.info,  Node: Emacs,  Prev: Autoconf,  Up: GMP Basics
-
-3.15 Emacs
-==========
-
-<C-h C-i> (`info-lookup-symbol') is a good way to find documentation on
-C functions while editing (*note Info Documentation Lookup: (emacs)Info
-Lookup.).
-
-   The GMP manual can be included in such lookups by putting the
-following in your `.emacs',
-
-     (eval-after-load "info-look"
-       '(let ((mode-value (assoc 'c-mode (assoc 'symbol info-lookup-alist))))
-          (setcar (nthcdr 3 mode-value)
-                  (cons '("(gmp)Function Index" nil "^ -.* " "\\>")
-                        (nth 3 mode-value)))))
-
-
-File: gmp.info,  Node: Reporting Bugs,  Next: Integer Functions,  Prev: GMP Basics,  Up: Top
-
-4 Reporting Bugs
-****************
-
-If you think you have found a bug in the GMP library, please
-investigate it and report it.  We have made this library available to
-you, and it is not too much to ask you to report the bugs you find.
-
-   Before you report a bug, check it's not already addressed in *Note
-Known Build Problems::, or perhaps *Note Notes for Particular
-Systems::.  You may also want to check `http://gmplib.org/' for patches
-for this release.
-
-   Please include the following in any report,
-
-   * The GMP version number, and if pre-packaged or patched then say so.
-
-   * A test program that makes it possible for us to reproduce the bug.
-     Include instructions on how to run the program.
-
-   * A description of what is wrong.  If the results are incorrect, in
-     what way.  If you get a crash, say so.
-
-   * If you get a crash, include a stack backtrace from the debugger if
-     it's informative (`where' in `gdb', or `$C' in `adb').
-
-   * Please do not send core dumps, executables or `strace's.
-
-   * The configuration options you used when building GMP, if any.
-
-   * The name of the compiler and its version.  For `gcc', get the
-     version with `gcc -v', otherwise perhaps `what `which cc`', or
-     similar.
-
-   * The output from running `uname -a'.
-
-   * The output from running `./config.guess', and from running
-     `./configfsf.guess' (might be the same).
-
-   * If the bug is related to `configure', then the compressed contents
-     of `config.log'.
-
-   * If the bug is related to an `asm' file not assembling, then the
-     contents of `config.m4' and the offending line or lines from the
-     temporary `mpn/tmp-<file>.s'.
-
-   Please make an effort to produce a self-contained report, with
-something definite that can be tested or debugged.  Vague queries or
-piecemeal messages are difficult to act on and don't help the
-development effort.
-
-   It is not uncommon that an observed problem is actually due to a bug
-in the compiler; the GMP code tends to explore interesting corners in
-compilers.
-
-   If your bug report is good, we will do our best to help you get a
-corrected version of the library; if the bug report is poor, we won't
-do anything about it (except maybe ask you to send a better report).
-
-   Send your report to: <gmp-bugs@gmplib.org>.
-
-   If you think something in this manual is unclear, or downright
-incorrect, or if the language needs to be improved, please send a note
-to the same address.
-
-
-File: gmp.info,  Node: Integer Functions,  Next: Rational Number Functions,  Prev: Reporting Bugs,  Up: Top
-
-5 Integer Functions
-*******************
-
-This chapter describes the GMP functions for performing integer
-arithmetic.  These functions start with the prefix `mpz_'.
-
-   GMP integers are stored in objects of type `mpz_t'.
-
-* Menu:
-
-* Initializing Integers::
-* Assigning Integers::
-* Simultaneous Integer Init & Assign::
-* Converting Integers::
-* Integer Arithmetic::
-* Integer Division::
-* Integer Exponentiation::
-* Integer Roots::
-* Number Theoretic Functions::
-* Integer Comparisons::
-* Integer Logic and Bit Fiddling::
-* I/O of Integers::
-* Integer Random Numbers::
-* Integer Import and Export::
-* Miscellaneous Integer Functions::
-* Integer Special Functions::
-
-
-File: gmp.info,  Node: Initializing Integers,  Next: Assigning Integers,  Prev: Integer Functions,  Up: Integer Functions
-
-5.1 Initialization Functions
-============================
-
-The functions for integer arithmetic assume that all integer objects are
-initialized.  You do that by calling the function `mpz_init'.  For
-example,
-
-     {
-       mpz_t integ;
-       mpz_init (integ);
-       ...
-       mpz_add (integ, ...);
-       ...
-       mpz_sub (integ, ...);
-
-       /* Unless the program is about to exit, do ... */
-       mpz_clear (integ);
-     }
-
-   As you can see, you can store new values any number of times, once an
-object is initialized.
-
- -- Function: void mpz_init (mpz_t X)
-     Initialize X, and set its value to 0.
-
- -- Function: void mpz_inits (mpz_t X, ...)
-     Initialize a NULL-terminated list of `mpz_t' variables, and set
-     their values to 0.
-
- -- Function: void mpz_init2 (mpz_t X, mp_bitcnt_t N)
-     Initialize X, with space for N-bit numbers, and set its value to 0.
-     Calling this function instead of `mpz_init' or `mpz_inits' is never
-     necessary; reallocation is handled automatically by GMP when
-     needed.
-
-     N is only the initial space, X will grow automatically in the
-     normal way, if necessary, for subsequent values stored.
-     `mpz_init2' makes it possible to avoid such reallocations if a
-     maximum size is known in advance.
-
- -- Function: void mpz_clear (mpz_t X)
-     Free the space occupied by X.  Call this function for all `mpz_t'
-     variables when you are done with them.
-
- -- Function: void mpz_clears (mpz_t X, ...)
-     Free the space occupied by a NULL-terminated list of `mpz_t'
-     variables.
-
- -- Function: void mpz_realloc2 (mpz_t X, mp_bitcnt_t N)
-     Change the space allocated for X to N bits.  The value in X is
-     preserved if it fits, or is set to 0 if not.
-
-     Calling this function is never necessary; reallocation is handled
-     automatically by GMP when needed.  But this function can be used
-     to increase the space for a variable in order to avoid repeated
-     automatic reallocations, or to decrease it to give memory back to
-     the heap.
-
-
-File: gmp.info,  Node: Assigning Integers,  Next: Simultaneous Integer Init & Assign,  Prev: Initializing Integers,  Up: Integer Functions
-
-5.2 Assignment Functions
-========================
-
-These functions assign new values to already initialized integers
-(*note Initializing Integers::).
-
- -- Function: void mpz_set (mpz_t ROP, mpz_t OP)
- -- Function: void mpz_set_ui (mpz_t ROP, unsigned long int OP)
- -- Function: void mpz_set_si (mpz_t ROP, signed long int OP)
- -- Function: void mpz_set_d (mpz_t ROP, double OP)
- -- Function: void mpz_set_q (mpz_t ROP, mpq_t OP)
- -- Function: void mpz_set_f (mpz_t ROP, mpf_t OP)
-     Set the value of ROP from OP.
-
-     `mpz_set_d', `mpz_set_q' and `mpz_set_f' truncate OP to make it an
-     integer.
-
- -- Function: int mpz_set_str (mpz_t ROP, char *STR, int BASE)
-     Set the value of ROP from STR, a null-terminated C string in base
-     BASE.  White space is allowed in the string, and is simply ignored.
-
-     The BASE may vary from 2 to 62, or if BASE is 0, then the leading
-     characters are used: `0x' and `0X' for hexadecimal, `0b' and `0B'
-     for binary, `0' for octal, or decimal otherwise.
-
-     For bases up to 36, case is ignored; upper-case and lower-case
-     letters have the same value.  For bases 37 to 62, upper-case
-     letter represent the usual 10..35 while lower-case letter
-     represent 36..61.
-
-     This function returns 0 if the entire string is a valid number in
-     base BASE.  Otherwise it returns -1.
-
- -- Function: void mpz_swap (mpz_t ROP1, mpz_t ROP2)
-     Swap the values ROP1 and ROP2 efficiently.
-
-
-File: gmp.info,  Node: Simultaneous Integer Init & Assign,  Next: Converting Integers,  Prev: Assigning Integers,  Up: Integer Functions
-
-5.3 Combined Initialization and Assignment Functions
-====================================================
-
-For convenience, GMP provides a parallel series of initialize-and-set
-functions which initialize the output and then store the value there.
-These functions' names have the form `mpz_init_set...'
-
-   Here is an example of using one:
-
-     {
-       mpz_t pie;
-       mpz_init_set_str (pie, "3141592653589793238462643383279502884", 10);
-       ...
-       mpz_sub (pie, ...);
-       ...
-       mpz_clear (pie);
-     }
-
-Once the integer has been initialized by any of the `mpz_init_set...'
-functions, it can be used as the source or destination operand for the
-ordinary integer functions.  Don't use an initialize-and-set function
-on a variable already initialized!
-
- -- Function: void mpz_init_set (mpz_t ROP, mpz_t OP)
- -- Function: void mpz_init_set_ui (mpz_t ROP, unsigned long int OP)
- -- Function: void mpz_init_set_si (mpz_t ROP, signed long int OP)
- -- Function: void mpz_init_set_d (mpz_t ROP, double OP)
-     Initialize ROP with limb space and set the initial numeric value
-     from OP.
-
- -- Function: int mpz_init_set_str (mpz_t ROP, char *STR, int BASE)
-     Initialize ROP and set its value like `mpz_set_str' (see its
-     documentation above for details).
-
-     If the string is a correct base BASE number, the function returns
-     0; if an error occurs it returns -1.  ROP is initialized even if
-     an error occurs.  (I.e., you have to call `mpz_clear' for it.)
-
-
-File: gmp.info,  Node: Converting Integers,  Next: Integer Arithmetic,  Prev: Simultaneous Integer Init & Assign,  Up: Integer Functions
-
-5.4 Conversion Functions
-========================
-
-This section describes functions for converting GMP integers to
-standard C types.  Functions for converting _to_ GMP integers are
-described in *Note Assigning Integers:: and *Note I/O of Integers::.
-
- -- Function: unsigned long int mpz_get_ui (mpz_t OP)
-     Return the value of OP as an `unsigned long'.
-
-     If OP is too big to fit an `unsigned long' then just the least
-     significant bits that do fit are returned.  The sign of OP is
-     ignored, only the absolute value is used.
-
- -- Function: signed long int mpz_get_si (mpz_t OP)
-     If OP fits into a `signed long int' return the value of OP.
-     Otherwise return the least significant part of OP, with the same
-     sign as OP.
-
-     If OP is too big to fit in a `signed long int', the returned
-     result is probably not very useful.  To find out if the value will
-     fit, use the function `mpz_fits_slong_p'.
-
- -- Function: double mpz_get_d (mpz_t OP)
-     Convert OP to a `double', truncating if necessary (ie. rounding
-     towards zero).
-
-     If the exponent from the conversion is too big, the result is
-     system dependent.  An infinity is returned where available.  A
-     hardware overflow trap may or may not occur.
-
- -- Function: double mpz_get_d_2exp (signed long int *EXP, mpz_t OP)
-     Convert OP to a `double', truncating if necessary (ie. rounding
-     towards zero), and returning the exponent separately.
-
-     The return value is in the range 0.5<=abs(D)<1 and the exponent is
-     stored to `*EXP'.  D * 2^EXP is the (truncated) OP value.  If OP
-     is zero, the return is 0.0 and 0 is stored to `*EXP'.
-
-     This is similar to the standard C `frexp' function (*note
-     Normalization Functions: (libc)Normalization Functions.).
-
- -- Function: char * mpz_get_str (char *STR, int BASE, mpz_t OP)
-     Convert OP to a string of digits in base BASE.  The base argument
-     may vary from 2 to 62 or from -2 to -36.
-
-     For BASE in the range 2..36, digits and lower-case letters are
-     used; for -2..-36, digits and upper-case letters are used; for
-     37..62, digits, upper-case letters, and lower-case letters (in
-     that significance order) are used.
-
-     If STR is `NULL', the result string is allocated using the current
-     allocation function (*note Custom Allocation::).  The block will be
-     `strlen(str)+1' bytes, that being exactly enough for the string and
-     null-terminator.
-
-     If STR is not `NULL', it should point to a block of storage large
-     enough for the result, that being `mpz_sizeinbase (OP, BASE) + 2'.
-     The two extra bytes are for a possible minus sign, and the
-     null-terminator.
-
-     A pointer to the result string is returned, being either the
-     allocated block, or the given STR.
-
-
-File: gmp.info,  Node: Integer Arithmetic,  Next: Integer Division,  Prev: Converting Integers,  Up: Integer Functions
-
-5.5 Arithmetic Functions
-========================
-
- -- Function: void mpz_add (mpz_t ROP, mpz_t OP1, mpz_t OP2)
- -- Function: void mpz_add_ui (mpz_t ROP, mpz_t OP1, unsigned long int
-          OP2)
-     Set ROP to OP1 + OP2.
-
- -- Function: void mpz_sub (mpz_t ROP, mpz_t OP1, mpz_t OP2)
- -- Function: void mpz_sub_ui (mpz_t ROP, mpz_t OP1, unsigned long int
-          OP2)
- -- Function: void mpz_ui_sub (mpz_t ROP, unsigned long int OP1, mpz_t
-          OP2)
-     Set ROP to OP1 - OP2.
-
- -- Function: void mpz_mul (mpz_t ROP, mpz_t OP1, mpz_t OP2)
- -- Function: void mpz_mul_si (mpz_t ROP, mpz_t OP1, long int OP2)
- -- Function: void mpz_mul_ui (mpz_t ROP, mpz_t OP1, unsigned long int
-          OP2)
-     Set ROP to OP1 times OP2.
-
- -- Function: void mpz_addmul (mpz_t ROP, mpz_t OP1, mpz_t OP2)
- -- Function: void mpz_addmul_ui (mpz_t ROP, mpz_t OP1, unsigned long
-          int OP2)
-     Set ROP to ROP + OP1 times OP2.
-
- -- Function: void mpz_submul (mpz_t ROP, mpz_t OP1, mpz_t OP2)
- -- Function: void mpz_submul_ui (mpz_t ROP, mpz_t OP1, unsigned long
-          int OP2)
-     Set ROP to ROP - OP1 times OP2.
-
- -- Function: void mpz_mul_2exp (mpz_t ROP, mpz_t OP1, mp_bitcnt_t OP2)
-     Set ROP to OP1 times 2 raised to OP2.  This operation can also be
-     defined as a left shift by OP2 bits.
-
- -- Function: void mpz_neg (mpz_t ROP, mpz_t OP)
-     Set ROP to -OP.
-
- -- Function: void mpz_abs (mpz_t ROP, mpz_t OP)
-     Set ROP to the absolute value of OP.
-
-
-File: gmp.info,  Node: Integer Division,  Next: Integer Exponentiation,  Prev: Integer Arithmetic,  Up: Integer Functions
-
-5.6 Division Functions
-======================
-
-Division is undefined if the divisor is zero.  Passing a zero divisor
-to the division or modulo functions (including the modular powering
-functions `mpz_powm' and `mpz_powm_ui'), will cause an intentional
-division by zero.  This lets a program handle arithmetic exceptions in
-these functions the same way as for normal C `int' arithmetic.
-
- -- Function: void mpz_cdiv_q (mpz_t Q, mpz_t N, mpz_t D)
- -- Function: void mpz_cdiv_r (mpz_t R, mpz_t N, mpz_t D)
- -- Function: void mpz_cdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
- -- Function: unsigned long int mpz_cdiv_q_ui (mpz_t Q, mpz_t N,
-          unsigned long int D)
- -- Function: unsigned long int mpz_cdiv_r_ui (mpz_t R, mpz_t N,
-          unsigned long int D)
- -- Function: unsigned long int mpz_cdiv_qr_ui (mpz_t Q, mpz_t R,
-          mpz_t N, unsigned long int D)
- -- Function: unsigned long int mpz_cdiv_ui (mpz_t N,
-          unsigned long int D)
- -- Function: void mpz_cdiv_q_2exp (mpz_t Q, mpz_t N, mp_bitcnt_t B)
- -- Function: void mpz_cdiv_r_2exp (mpz_t R, mpz_t N, mp_bitcnt_t B)
-
- -- Function: void mpz_fdiv_q (mpz_t Q, mpz_t N, mpz_t D)
- -- Function: void mpz_fdiv_r (mpz_t R, mpz_t N, mpz_t D)
- -- Function: void mpz_fdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
- -- Function: unsigned long int mpz_fdiv_q_ui (mpz_t Q, mpz_t N,
-          unsigned long int D)
- -- Function: unsigned long int mpz_fdiv_r_ui (mpz_t R, mpz_t N,
-          unsigned long int D)
- -- Function: unsigned long int mpz_fdiv_qr_ui (mpz_t Q, mpz_t R,
-          mpz_t N, unsigned long int D)
- -- Function: unsigned long int mpz_fdiv_ui (mpz_t N,
-          unsigned long int D)
- -- Function: void mpz_fdiv_q_2exp (mpz_t Q, mpz_t N, mp_bitcnt_t B)
- -- Function: void mpz_fdiv_r_2exp (mpz_t R, mpz_t N, mp_bitcnt_t B)
-
- -- Function: void mpz_tdiv_q (mpz_t Q, mpz_t N, mpz_t D)
- -- Function: void mpz_tdiv_r (mpz_t R, mpz_t N, mpz_t D)
- -- Function: void mpz_tdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
- -- Function: unsigned long int mpz_tdiv_q_ui (mpz_t Q, mpz_t N,
-          unsigned long int D)
- -- Function: unsigned long int mpz_tdiv_r_ui (mpz_t R, mpz_t N,
-          unsigned long int D)
- -- Function: unsigned long int mpz_tdiv_qr_ui (mpz_t Q, mpz_t R,
-          mpz_t N, unsigned long int D)
- -- Function: unsigned long int mpz_tdiv_ui (mpz_t N,
-          unsigned long int D)
- -- Function: void mpz_tdiv_q_2exp (mpz_t Q, mpz_t N, mp_bitcnt_t B)
- -- Function: void mpz_tdiv_r_2exp (mpz_t R, mpz_t N, mp_bitcnt_t B)
-
-     Divide N by D, forming a quotient Q and/or remainder R.  For the
-     `2exp' functions, D=2^B.  The rounding is in three styles, each
-     suiting different applications.
-
-        * `cdiv' rounds Q up towards +infinity, and R will have the
-          opposite sign to D.  The `c' stands for "ceil".
-
-        * `fdiv' rounds Q down towards -infinity, and R will have the
-          same sign as D.  The `f' stands for "floor".
-
-        * `tdiv' rounds Q towards zero, and R will have the same sign
-          as N.  The `t' stands for "truncate".
-
-     In all cases Q and R will satisfy N=Q*D+R, and R will satisfy
-     0<=abs(R)<abs(D).
-
-     The `q' functions calculate only the quotient, the `r' functions
-     only the remainder, and the `qr' functions calculate both.  Note
-     that for `qr' the same variable cannot be passed for both Q and R,
-     or results will be unpredictable.
-
-     For the `ui' variants the return value is the remainder, and in
-     fact returning the remainder is all the `div_ui' functions do.  For
-     `tdiv' and `cdiv' the remainder can be negative, so for those the
-     return value is the absolute value of the remainder.
-
-     For the `2exp' variants the divisor is 2^B.  These functions are
-     implemented as right shifts and bit masks, but of course they
-     round the same as the other functions.
-
-     For positive N both `mpz_fdiv_q_2exp' and `mpz_tdiv_q_2exp' are
-     simple bitwise right shifts.  For negative N, `mpz_fdiv_q_2exp' is
-     effectively an arithmetic right shift treating N as twos complement
-     the same as the bitwise logical functions do, whereas
-     `mpz_tdiv_q_2exp' effectively treats N as sign and magnitude.
-
- -- Function: void mpz_mod (mpz_t R, mpz_t N, mpz_t D)
- -- Function: unsigned long int mpz_mod_ui (mpz_t R, mpz_t N,
-          unsigned long int D)
-     Set R to N `mod' D.  The sign of the divisor is ignored; the
-     result is always non-negative.
-
-     `mpz_mod_ui' is identical to `mpz_fdiv_r_ui' above, returning the
-     remainder as well as setting R.  See `mpz_fdiv_ui' above if only
-     the return value is wanted.
-
- -- Function: void mpz_divexact (mpz_t Q, mpz_t N, mpz_t D)
- -- Function: void mpz_divexact_ui (mpz_t Q, mpz_t N, unsigned long D)
-     Set Q to N/D.  These functions produce correct results only when
-     it is known in advance that D divides N.
-
-     These routines are much faster than the other division functions,
-     and are the best choice when exact division is known to occur, for
-     example reducing a rational to lowest terms.
-
- -- Function: int mpz_divisible_p (mpz_t N, mpz_t D)
- -- Function: int mpz_divisible_ui_p (mpz_t N, unsigned long int D)
- -- Function: int mpz_divisible_2exp_p (mpz_t N, mp_bitcnt_t B)
-     Return non-zero if N is exactly divisible by D, or in the case of
-     `mpz_divisible_2exp_p' by 2^B.
-
-     N is divisible by D if there exists an integer Q satisfying N =
-     Q*D.  Unlike the other division functions, D=0 is accepted and
-     following the rule it can be seen that only 0 is considered
-     divisible by 0.
-
- -- Function: int mpz_congruent_p (mpz_t N, mpz_t C, mpz_t D)
- -- Function: int mpz_congruent_ui_p (mpz_t N, unsigned long int C,
-          unsigned long int D)
- -- Function: int mpz_congruent_2exp_p (mpz_t N, mpz_t C, mp_bitcnt_t B)
-     Return non-zero if N is congruent to C modulo D, or in the case of
-     `mpz_congruent_2exp_p' modulo 2^B.
-
-     N is congruent to C mod D if there exists an integer Q satisfying
-     N = C + Q*D.  Unlike the other division functions, D=0 is accepted
-     and following the rule it can be seen that N and C are considered
-     congruent mod 0 only when exactly equal.
-
-
-File: gmp.info,  Node: Integer Exponentiation,  Next: Integer Roots,  Prev: Integer Division,  Up: Integer Functions
-
-5.7 Exponentiation Functions
-============================
-
- -- Function: void mpz_powm (mpz_t ROP, mpz_t BASE, mpz_t EXP, mpz_t
-          MOD)
- -- Function: void mpz_powm_ui (mpz_t ROP, mpz_t BASE, unsigned long
-          int EXP, mpz_t MOD)
-     Set ROP to (BASE raised to EXP) modulo MOD.
-
-     Negative EXP is supported if an inverse BASE^-1 mod MOD exists
-     (see `mpz_invert' in *Note Number Theoretic Functions::).  If an
-     inverse doesn't exist then a divide by zero is raised.
-
- -- Function: void mpz_powm_sec (mpz_t ROP, mpz_t BASE, mpz_t EXP,
-          mpz_t MOD)
-     Set ROP to (BASE raised to EXP) modulo MOD.
-
-     It is required that EXP > 0 and that MOD is odd.
-
-     This function is designed to take the same time and have the same
-     cache access patterns for any two same-size arguments, assuming
-     that function arguments are placed at the same position and that
-     the machine state is identical upon function entry.  This function
-     is intended for cryptographic purposes, where resilience to
-     side-channel attacks is desired.
-
- -- Function: void mpz_pow_ui (mpz_t ROP, mpz_t BASE, unsigned long int
-          EXP)
- -- Function: void mpz_ui_pow_ui (mpz_t ROP, unsigned long int BASE,
-          unsigned long int EXP)
-     Set ROP to BASE raised to EXP.  The case 0^0 yields 1.
-
-
-File: gmp.info,  Node: Integer Roots,  Next: Number Theoretic Functions,  Prev: Integer Exponentiation,  Up: Integer Functions
-
-5.8 Root Extraction Functions
-=============================
-
- -- Function: int mpz_root (mpz_t ROP, mpz_t OP, unsigned long int N)
-     Set ROP to  the truncated integer part of the Nth root of OP.
-     Return non-zero if the computation was exact, i.e., if OP is ROP
-     to the Nth power.
-
- -- Function: void mpz_rootrem (mpz_t ROOT, mpz_t REM, mpz_t U,
-          unsigned long int N)
-     Set ROOT to  the truncated integer part of the Nth root of U.  Set
-     REM to the remainder, U-ROOT**N.
-
- -- Function: void mpz_sqrt (mpz_t ROP, mpz_t OP)
-     Set ROP to  the truncated integer part of the square root of OP.
-
- -- Function: void mpz_sqrtrem (mpz_t ROP1, mpz_t ROP2, mpz_t OP)
-     Set ROP1 to the truncated integer part of the square root of OP,
-     like `mpz_sqrt'.  Set ROP2 to the remainder OP-ROP1*ROP1, which
-     will be zero if OP is a perfect square.
-
-     If ROP1 and ROP2 are the same variable, the results are undefined.
-
- -- Function: int mpz_perfect_power_p (mpz_t OP)
-     Return non-zero if OP is a perfect power, i.e., if there exist
-     integers A and B, with B>1, such that OP equals A raised to the
-     power B.
-
-     Under this definition both 0 and 1 are considered to be perfect
-     powers.  Negative values of OP are accepted, but of course can
-     only be odd perfect powers.
-
- -- Function: int mpz_perfect_square_p (mpz_t OP)
-     Return non-zero if OP is a perfect square, i.e., if the square
-     root of OP is an integer.  Under this definition both 0 and 1 are
-     considered to be perfect squares.
-
-
-File: gmp.info,  Node: Number Theoretic Functions,  Next: Integer Comparisons,  Prev: Integer Roots,  Up: Integer Functions
-
-5.9 Number Theoretic Functions
-==============================
-
- -- Function: int mpz_probab_prime_p (mpz_t N, int REPS)
-     Determine whether N is prime.  Return 2 if N is definitely prime,
-     return 1 if N is probably prime (without being certain), or return
-     0 if N is definitely composite.
-
-     This function does some trial divisions, then some Miller-Rabin
-     probabilistic primality tests.  REPS controls how many such tests
-     are done, 5 to 10 is a reasonable number, more will reduce the
-     chances of a composite being returned as "probably prime".
-
-     Miller-Rabin and similar tests can be more properly called
-     compositeness tests.  Numbers which fail are known to be composite
-     but those which pass might be prime or might be composite.  Only a
-     few composites pass, hence those which pass are considered
-     probably prime.
-
- -- Function: void mpz_nextprime (mpz_t ROP, mpz_t OP)
-     Set ROP to the next prime greater than OP.
-
-     This function uses a probabilistic algorithm to identify primes.
-     For practical purposes it's adequate, the chance of a composite
-     passing will be extremely small.
-
- -- Function: void mpz_gcd (mpz_t ROP, mpz_t OP1, mpz_t OP2)
-     Set ROP to the greatest common divisor of OP1 and OP2.  The result
-     is always positive even if one or both input operands are negative.
-
- -- Function: unsigned long int mpz_gcd_ui (mpz_t ROP, mpz_t OP1,
-          unsigned long int OP2)
-     Compute the greatest common divisor of OP1 and OP2.  If ROP is not
-     `NULL', store the result there.
-
-     If the result is small enough to fit in an `unsigned long int', it
-     is returned.  If the result does not fit, 0 is returned, and the
-     result is equal to the argument OP1.  Note that the result will
-     always fit if OP2 is non-zero.
-
- -- Function: void mpz_gcdext (mpz_t G, mpz_t S, mpz_t T, mpz_t A,
-          mpz_t B)
-     Set G to the greatest common divisor of A and B, and in addition
-     set S and T to coefficients satisfying A*S + B*T = G.  The value
-     in G is always positive, even if one or both of A and B are
-     negative.  The values in S and T are chosen such that abs(S) <=
-     abs(B) and abs(T) <= abs(A).
-
-     If T is `NULL' then that value is not computed.
-
- -- Function: void mpz_lcm (mpz_t ROP, mpz_t OP1, mpz_t OP2)
- -- Function: void mpz_lcm_ui (mpz_t ROP, mpz_t OP1, unsigned long OP2)
-     Set ROP to the least common multiple of OP1 and OP2.  ROP is
-     always positive, irrespective of the signs of OP1 and OP2.  ROP
-     will be zero if either OP1 or OP2 is zero.
-
- -- Function: int mpz_invert (mpz_t ROP, mpz_t OP1, mpz_t OP2)
-     Compute the inverse of OP1 modulo OP2 and put the result in ROP.
-     If the inverse exists, the return value is non-zero and ROP will
-     satisfy 0 <= ROP < OP2.  If an inverse doesn't exist the return
-     value is zero and ROP is undefined.
-
- -- Function: int mpz_jacobi (mpz_t A, mpz_t B)
-     Calculate the Jacobi symbol (A/B).  This is defined only for B odd.
-
- -- Function: int mpz_legendre (mpz_t A, mpz_t P)
-     Calculate the Legendre symbol (A/P).  This is defined only for P
-     an odd positive prime, and for such P it's identical to the Jacobi
-     symbol.
-
- -- Function: int mpz_kronecker (mpz_t A, mpz_t B)
- -- Function: int mpz_kronecker_si (mpz_t A, long B)
- -- Function: int mpz_kronecker_ui (mpz_t A, unsigned long B)
- -- Function: int mpz_si_kronecker (long A, mpz_t B)
- -- Function: int mpz_ui_kronecker (unsigned long A, mpz_t B)
-     Calculate the Jacobi symbol (A/B) with the Kronecker extension
-     (a/2)=(2/a) when a odd, or (a/2)=0 when a even.
-
-     When B is odd the Jacobi symbol and Kronecker symbol are
-     identical, so `mpz_kronecker_ui' etc can be used for mixed
-     precision Jacobi symbols too.
-
-     For more information see Henri Cohen section 1.4.2 (*note
-     References::), or any number theory textbook.  See also the
-     example program `demos/qcn.c' which uses `mpz_kronecker_ui'.
-
- -- Function: mp_bitcnt_t mpz_remove (mpz_t ROP, mpz_t OP, mpz_t F)
-     Remove all occurrences of the factor F from OP and store the
-     result in ROP.  The return value is how many such occurrences were
-     removed.
-
- -- Function: void mpz_fac_ui (mpz_t ROP, unsigned long int OP)
-     Set ROP to OP!, the factorial of OP.
-
- -- Function: void mpz_bin_ui (mpz_t ROP, mpz_t N, unsigned long int K)
- -- Function: void mpz_bin_uiui (mpz_t ROP, unsigned long int N,
-          unsigned long int K)
-     Compute the binomial coefficient N over K and store the result in
-     ROP.  Negative values of N are supported by `mpz_bin_ui', using
-     the identity bin(-n,k) = (-1)^k * bin(n+k-1,k), see Knuth volume 1
-     section 1.2.6 part G.
-
- -- Function: void mpz_fib_ui (mpz_t FN, unsigned long int N)
- -- Function: void mpz_fib2_ui (mpz_t FN, mpz_t FNSUB1, unsigned long
-          int N)
-     `mpz_fib_ui' sets FN to to F[n], the N'th Fibonacci number.
-     `mpz_fib2_ui' sets FN to F[n], and FNSUB1 to F[n-1].
-
-     These functions are designed for calculating isolated Fibonacci
-     numbers.  When a sequence of values is wanted it's best to start
-     with `mpz_fib2_ui' and iterate the defining F[n+1]=F[n]+F[n-1] or
-     similar.
-
- -- Function: void mpz_lucnum_ui (mpz_t LN, unsigned long int N)
- -- Function: void mpz_lucnum2_ui (mpz_t LN, mpz_t LNSUB1, unsigned
-          long int N)
-     `mpz_lucnum_ui' sets LN to to L[n], the N'th Lucas number.
-     `mpz_lucnum2_ui' sets LN to L[n], and LNSUB1 to L[n-1].
-
-     These functions are designed for calculating isolated Lucas
-     numbers.  When a sequence of values is wanted it's best to start
-     with `mpz_lucnum2_ui' and iterate the defining L[n+1]=L[n]+L[n-1]
-     or similar.
-
-     The Fibonacci numbers and Lucas numbers are related sequences, so
-     it's never necessary to call both `mpz_fib2_ui' and
-     `mpz_lucnum2_ui'.  The formulas for going from Fibonacci to Lucas
-     can be found in *Note Lucas Numbers Algorithm::, the reverse is
-     straightforward too.
-
-
-File: gmp.info,  Node: Integer Comparisons,  Next: Integer Logic and Bit Fiddling,  Prev: Number Theoretic Functions,  Up: Integer Functions
-
-5.10 Comparison Functions
-=========================
-
- -- Function: int mpz_cmp (mpz_t OP1, mpz_t OP2)
- -- Function: int mpz_cmp_d (mpz_t OP1, double OP2)
- -- Macro: int mpz_cmp_si (mpz_t OP1, signed long int OP2)
- -- Macro: int mpz_cmp_ui (mpz_t OP1, unsigned long int OP2)
-     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
-     if OP1 = OP2, or a negative value if OP1 < OP2.
-
-     `mpz_cmp_ui' and `mpz_cmp_si' are macros and will evaluate their
-     arguments more than once.  `mpz_cmp_d' can be called with an
-     infinity, but results are undefined for a NaN.
-
- -- Function: int mpz_cmpabs (mpz_t OP1, mpz_t OP2)
- -- Function: int mpz_cmpabs_d (mpz_t OP1, double OP2)
- -- Function: int mpz_cmpabs_ui (mpz_t OP1, unsigned long int OP2)
-     Compare the absolute values of OP1 and OP2.  Return a positive
-     value if abs(OP1) > abs(OP2), zero if abs(OP1) = abs(OP2), or a
-     negative value if abs(OP1) < abs(OP2).
-
-     `mpz_cmpabs_d' can be called with an infinity, but results are
-     undefined for a NaN.
-
- -- Macro: int mpz_sgn (mpz_t OP)
-     Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.
-
-     This function is actually implemented as a macro.  It evaluates
-     its argument multiple times.
-
-
-File: gmp.info,  Node: Integer Logic and Bit Fiddling,  Next: I/O of Integers,  Prev: Integer Comparisons,  Up: Integer Functions
-
-5.11 Logical and Bit Manipulation Functions
-===========================================
-
-These functions behave as if twos complement arithmetic were used
-(although sign-magnitude is the actual implementation).  The least
-significant bit is number 0.
-
- -- Function: void mpz_and (mpz_t ROP, mpz_t OP1, mpz_t OP2)
-     Set ROP to OP1 bitwise-and OP2.
-
- -- Function: void mpz_ior (mpz_t ROP, mpz_t OP1, mpz_t OP2)
-     Set ROP to OP1 bitwise inclusive-or OP2.
-
- -- Function: void mpz_xor (mpz_t ROP, mpz_t OP1, mpz_t OP2)
-     Set ROP to OP1 bitwise exclusive-or OP2.
-
- -- Function: void mpz_com (mpz_t ROP, mpz_t OP)
-     Set ROP to the one's complement of OP.
-
- -- Function: mp_bitcnt_t mpz_popcount (mpz_t OP)
-     If OP>=0, return the population count of OP, which is the number
-     of 1 bits in the binary representation.  If OP<0, the number of 1s
-     is infinite, and the return value is the largest possible
-     `mp_bitcnt_t'.
-
- -- Function: mp_bitcnt_t mpz_hamdist (mpz_t OP1, mpz_t OP2)
-     If OP1 and OP2 are both >=0 or both <0, return the hamming
-     distance between the two operands, which is the number of bit
-     positions where OP1 and OP2 have different bit values.  If one
-     operand is >=0 and the other <0 then the number of bits different
-     is infinite, and the return value is the largest possible
-     `mp_bitcnt_t'.
-
- -- Function: mp_bitcnt_t mpz_scan0 (mpz_t OP, mp_bitcnt_t STARTING_BIT)
- -- Function: mp_bitcnt_t mpz_scan1 (mpz_t OP, mp_bitcnt_t STARTING_BIT)
-     Scan OP, starting from bit STARTING_BIT, towards more significant
-     bits, until the first 0 or 1 bit (respectively) is found.  Return
-     the index of the found bit.
-
-     If the bit at STARTING_BIT is already what's sought, then
-     STARTING_BIT is returned.
-
-     If there's no bit found, then the largest possible `mp_bitcnt_t' is
-     returned.  This will happen in `mpz_scan0' past the end of a
-     negative number, or `mpz_scan1' past the end of a nonnegative
-     number.
-
- -- Function: void mpz_setbit (mpz_t ROP, mp_bitcnt_t BIT_INDEX)
-     Set bit BIT_INDEX in ROP.
-
- -- Function: void mpz_clrbit (mpz_t ROP, mp_bitcnt_t BIT_INDEX)
-     Clear bit BIT_INDEX in ROP.
-
- -- Function: void mpz_combit (mpz_t ROP, mp_bitcnt_t BIT_INDEX)
-     Complement bit BIT_INDEX in ROP.
-
- -- Function: int mpz_tstbit (mpz_t OP, mp_bitcnt_t BIT_INDEX)
-     Test bit BIT_INDEX in OP and return 0 or 1 accordingly.
-
-
-File: gmp.info,  Node: I/O of Integers,  Next: Integer Random Numbers,  Prev: Integer Logic and Bit Fiddling,  Up: Integer Functions
-
-5.12 Input and Output Functions
-===============================
-
-Functions that perform input from a stdio stream, and functions that
-output to a stdio stream, of `mpz' numbers.  Passing a `NULL' pointer
-for a STREAM argument to any of these functions will make them read from
-`stdin' and write to `stdout', respectively.
-
-   When using any of these functions, it is a good idea to include
-`stdio.h' before `gmp.h', since that will allow `gmp.h' to define
-prototypes for these functions.
-
-   See also *Note Formatted Output:: and *Note Formatted Input::.
-
- -- Function: size_t mpz_out_str (FILE *STREAM, int BASE, mpz_t OP)
-     Output OP on stdio stream STREAM, as a string of digits in base
-     BASE.  The base argument may vary from 2 to 62 or from -2 to -36.
-
-     For BASE in the range 2..36, digits and lower-case letters are
-     used; for -2..-36, digits and upper-case letters are used; for
-     37..62, digits, upper-case letters, and lower-case letters (in
-     that significance order) are used.
-
-     Return the number of bytes written, or if an error occurred,
-     return 0.
-
- -- Function: size_t mpz_inp_str (mpz_t ROP, FILE *STREAM, int BASE)
-     Input a possibly white-space preceded string in base BASE from
-     stdio stream STREAM, and put the read integer in ROP.
-
-     The BASE may vary from 2 to 62, or if BASE is 0, then the leading
-     characters are used: `0x' and `0X' for hexadecimal, `0b' and `0B'
-     for binary, `0' for octal, or decimal otherwise.
-
-     For bases up to 36, case is ignored; upper-case and lower-case
-     letters have the same value.  For bases 37 to 62, upper-case
-     letter represent the usual 10..35 while lower-case letter
-     represent 36..61.
-
-     Return the number of bytes read, or if an error occurred, return 0.
-
- -- Function: size_t mpz_out_raw (FILE *STREAM, mpz_t OP)
-     Output OP on stdio stream STREAM, in raw binary format.  The
-     integer is written in a portable format, with 4 bytes of size
-     information, and that many bytes of limbs.  Both the size and the
-     limbs are written in decreasing significance order (i.e., in
-     big-endian).
-
-     The output can be read with `mpz_inp_raw'.
-
-     Return the number of bytes written, or if an error occurred,
-     return 0.
-
-     The output of this can not be read by `mpz_inp_raw' from GMP 1,
-     because of changes necessary for compatibility between 32-bit and
-     64-bit machines.
-
- -- Function: size_t mpz_inp_raw (mpz_t ROP, FILE *STREAM)
-     Input from stdio stream STREAM in the format written by
-     `mpz_out_raw', and put the result in ROP.  Return the number of
-     bytes read, or if an error occurred, return 0.
-
-     This routine can read the output from `mpz_out_raw' also from GMP
-     1, in spite of changes necessary for compatibility between 32-bit
-     and 64-bit machines.
-
-
-File: gmp.info,  Node: Integer Random Numbers,  Next: Integer Import and Export,  Prev: I/O of Integers,  Up: Integer Functions
-
-5.13 Random Number Functions
-============================
-
-The random number functions of GMP come in two groups; older function
-that rely on a global state, and newer functions that accept a state
-parameter that is read and modified.  Please see the *Note Random
-Number Functions:: for more information on how to use and not to use
-random number functions.
-
- -- Function: void mpz_urandomb (mpz_t ROP, gmp_randstate_t STATE,
-          mp_bitcnt_t N)
-     Generate a uniformly distributed random integer in the range 0 to
-     2^N-1, inclusive.
-
-     The variable STATE must be initialized by calling one of the
-     `gmp_randinit' functions (*Note Random State Initialization::)
-     before invoking this function.
-
- -- Function: void mpz_urandomm (mpz_t ROP, gmp_randstate_t STATE,
-          mpz_t N)
-     Generate a uniform random integer in the range 0 to N-1, inclusive.
-
-     The variable STATE must be initialized by calling one of the
-     `gmp_randinit' functions (*Note Random State Initialization::)
-     before invoking this function.
-
- -- Function: void mpz_rrandomb (mpz_t ROP, gmp_randstate_t STATE,
-          mp_bitcnt_t N)
-     Generate a random integer with long strings of zeros and ones in
-     the binary representation.  Useful for testing functions and
-     algorithms, since this kind of random numbers have proven to be
-     more likely to trigger corner-case bugs.  The random number will
-     be in the range 0 to 2^N-1, inclusive.
-
-     The variable STATE must be initialized by calling one of the
-     `gmp_randinit' functions (*Note Random State Initialization::)
-     before invoking this function.
-
- -- Function: void mpz_random (mpz_t ROP, mp_size_t MAX_SIZE)
-     Generate a random integer of at most MAX_SIZE limbs.  The generated
-     random number doesn't satisfy any particular requirements of
-     randomness.  Negative random numbers are generated when MAX_SIZE
-     is negative.
-
-     This function is obsolete.  Use `mpz_urandomb' or `mpz_urandomm'
-     instead.
-
- -- Function: void mpz_random2 (mpz_t ROP, mp_size_t MAX_SIZE)
-     Generate a random integer of at most MAX_SIZE limbs, with long
-     strings of zeros and ones in the binary representation.  Useful
-     for testing functions and algorithms, since this kind of random
-     numbers have proven to be more likely to trigger corner-case bugs.
-     Negative random numbers are generated when MAX_SIZE is negative.
-
-     This function is obsolete.  Use `mpz_rrandomb' instead.
-
-
-File: gmp.info,  Node: Integer Import and Export,  Next: Miscellaneous Integer Functions,  Prev: Integer Random Numbers,  Up: Integer Functions
-
-5.14 Integer Import and Export
-==============================
-
-`mpz_t' variables can be converted to and from arbitrary words of binary
-data with the following functions.
-
- -- Function: void mpz_import (mpz_t ROP, size_t COUNT, int ORDER,
-          size_t SIZE, int ENDIAN, size_t NAILS, const void *OP)
-     Set ROP from an array of word data at OP.
-
-     The parameters specify the format of the data.  COUNT many words
-     are read, each SIZE bytes.  ORDER can be 1 for most significant
-     word first or -1 for least significant first.  Within each word
-     ENDIAN can be 1 for most significant byte first, -1 for least
-     significant first, or 0 for the native endianness of the host CPU.
-     The most significant NAILS bits of each word are skipped, this
-     can be 0 to use the full words.
-
-     There is no sign taken from the data, ROP will simply be a positive
-     integer.  An application can handle any sign itself, and apply it
-     for instance with `mpz_neg'.
-
-     There are no data alignment restrictions on OP, any address is
-     allowed.
-
-     Here's an example converting an array of `unsigned long' data, most
-     significant element first, and host byte order within each value.
-
-          unsigned long  a[20];
-          /* Initialize Z and A */
-          mpz_import (z, 20, 1, sizeof(a[0]), 0, 0, a);
-
-     This example assumes the full `sizeof' bytes are used for data in
-     the given type, which is usually true, and certainly true for
-     `unsigned long' everywhere we know of.  However on Cray vector
-     systems it may be noted that `short' and `int' are always stored
-     in 8 bytes (and with `sizeof' indicating that) but use only 32 or
-     46 bits.  The NAILS feature can account for this, by passing for
-     instance `8*sizeof(int)-INT_BIT'.
-
- -- Function: void * mpz_export (void *ROP, size_t *COUNTP, int ORDER,
-          size_t SIZE, int ENDIAN, size_t NAILS, mpz_t OP)
-     Fill ROP with word data from OP.
-
-     The parameters specify the format of the data produced.  Each word
-     will be SIZE bytes and ORDER can be 1 for most significant word
-     first or -1 for least significant first.  Within each word ENDIAN
-     can be 1 for most significant byte first, -1 for least significant
-     first, or 0 for the native endianness of the host CPU.  The most
-     significant NAILS bits of each word are unused and set to zero,
-     this can be 0 to produce full words.
-
-     The number of words produced is written to `*COUNTP', or COUNTP
-     can be `NULL' to discard the count.  ROP must have enough space
-     for the data, or if ROP is `NULL' then a result array of the
-     necessary size is allocated using the current GMP allocation
-     function (*note Custom Allocation::).  In either case the return
-     value is the destination used, either ROP or the allocated block.
-
-     If OP is non-zero then the most significant word produced will be
-     non-zero.  If OP is zero then the count returned will be zero and
-     nothing written to ROP.  If ROP is `NULL' in this case, no block
-     is allocated, just `NULL' is returned.
-
-     The sign of OP is ignored, just the absolute value is exported.  An
-     application can use `mpz_sgn' to get the sign and handle it as
-     desired.  (*note Integer Comparisons::)
-
-     There are no data alignment restrictions on ROP, any address is
-     allowed.
-
-     When an application is allocating space itself the required size
-     can be determined with a calculation like the following.  Since
-     `mpz_sizeinbase' always returns at least 1, `count' here will be
-     at least one, which avoids any portability problems with
-     `malloc(0)', though if `z' is zero no space at all is actually
-     needed (or written).
-
-          numb = 8*size - nail;
-          count = (mpz_sizeinbase (z, 2) + numb-1) / numb;
-          p = malloc (count * size);
-
-
-File: gmp.info,  Node: Miscellaneous Integer Functions,  Next: Integer Special Functions,  Prev: Integer Import and Export,  Up: Integer Functions
-
-5.15 Miscellaneous Functions
-============================
-
- -- Function: int mpz_fits_ulong_p (mpz_t OP)
- -- Function: int mpz_fits_slong_p (mpz_t OP)
- -- Function: int mpz_fits_uint_p (mpz_t OP)
- -- Function: int mpz_fits_sint_p (mpz_t OP)
- -- Function: int mpz_fits_ushort_p (mpz_t OP)
- -- Function: int mpz_fits_sshort_p (mpz_t OP)
-     Return non-zero iff the value of OP fits in an `unsigned long int',
-     `signed long int', `unsigned int', `signed int', `unsigned short
-     int', or `signed short int', respectively.  Otherwise, return zero.
-
- -- Macro: int mpz_odd_p (mpz_t OP)
- -- Macro: int mpz_even_p (mpz_t OP)
-     Determine whether OP is odd or even, respectively.  Return
-     non-zero if yes, zero if no.  These macros evaluate their argument
-     more than once.
-
- -- Function: size_t mpz_sizeinbase (mpz_t OP, int BASE)
-     Return the size of OP measured in number of digits in the given
-     BASE.  BASE can vary from 2 to 62.  The sign of OP is ignored,
-     just the absolute value is used.  The result will be either exact
-     or 1 too big.  If BASE is a power of 2, the result is always
-     exact.  If OP is zero the return value is always 1.
-
-     This function can be used to determine the space required when
-     converting OP to a string.  The right amount of allocation is
-     normally two more than the value returned by `mpz_sizeinbase', one
-     extra for a minus sign and one for the null-terminator.
-
-     It will be noted that `mpz_sizeinbase(OP,2)' can be used to locate
-     the most significant 1 bit in OP, counting from 1.  (Unlike the
-     bitwise functions which start from 0, *Note Logical and Bit
-     Manipulation Functions: Integer Logic and Bit Fiddling.)
-
-
-File: gmp.info,  Node: Integer Special Functions,  Prev: Miscellaneous Integer Functions,  Up: Integer Functions
-
-5.16 Special Functions
-======================
-
-The functions in this section are for various special purposes.  Most
-applications will not need them.
-
- -- Function: void mpz_array_init (mpz_t INTEGER_ARRAY, mp_size_t
-          ARRAY_SIZE, mp_size_t FIXED_NUM_BITS)
-     This is a special type of initialization.  *Fixed* space of
-     FIXED_NUM_BITS is allocated to each of the ARRAY_SIZE integers in
-     INTEGER_ARRAY.  There is no way to free the storage allocated by
-     this function.  Don't call `mpz_clear'!
-
-     The INTEGER_ARRAY parameter is the first `mpz_t' in the array.  For
-     example,
-
-          mpz_t  arr[20000];
-          mpz_array_init (arr[0], 20000, 512);
-
-     This function is only intended for programs that create a large
-     number of integers and need to reduce memory usage by avoiding the
-     overheads of allocating and reallocating lots of small blocks.  In
-     normal programs this function is not recommended.
-
-     The space allocated to each integer by this function will not be
-     automatically increased, unlike the normal `mpz_init', so an
-     application must ensure it is sufficient for any value stored.
-     The following space requirements apply to various routines,
-
-        * `mpz_abs', `mpz_neg', `mpz_set', `mpz_set_si' and
-          `mpz_set_ui' need room for the value they store.
-
-        * `mpz_add', `mpz_add_ui', `mpz_sub' and `mpz_sub_ui' need room
-          for the larger of the two operands, plus an extra
-          `mp_bits_per_limb'.
-
-        * `mpz_mul', `mpz_mul_ui' and `mpz_mul_si' need room for the sum
-          of the number of bits in their operands, but each rounded up
-          to a multiple of `mp_bits_per_limb'.
-
-        * `mpz_swap' can be used between two array variables, but not
-          between an array and a normal variable.
-
-     For other functions, or if in doubt, the suggestion is to
-     calculate in a regular `mpz_init' variable and copy the result to
-     an array variable with `mpz_set'.
-
- -- Function: void * _mpz_realloc (mpz_t INTEGER, mp_size_t NEW_ALLOC)
-     Change the space for INTEGER to NEW_ALLOC limbs.  The value in
-     INTEGER is preserved if it fits, or is set to 0 if not.  The return
-     value is not useful to applications and should be ignored.
-
-     `mpz_realloc2' is the preferred way to accomplish allocation
-     changes like this.  `mpz_realloc2' and `_mpz_realloc' are the same
-     except that `_mpz_realloc' takes its size in limbs.
-
- -- Function: mp_limb_t mpz_getlimbn (mpz_t OP, mp_size_t N)
-     Return limb number N from OP.  The sign of OP is ignored, just the
-     absolute value is used.  The least significant limb is number 0.
-
-     `mpz_size' can be used to find how many limbs make up OP.
-     `mpz_getlimbn' returns zero if N is outside the range 0 to
-     `mpz_size(OP)-1'.
-
- -- Function: size_t mpz_size (mpz_t OP)
-     Return the size of OP measured in number of limbs.  If OP is zero,
-     the returned value will be zero.
-
-
-File: gmp.info,  Node: Rational Number Functions,  Next: Floating-point Functions,  Prev: Integer Functions,  Up: Top
-
-6 Rational Number Functions
-***************************
-
-This chapter describes the GMP functions for performing arithmetic on
-rational numbers.  These functions start with the prefix `mpq_'.
-
-   Rational numbers are stored in objects of type `mpq_t'.
-
-   All rational arithmetic functions assume operands have a canonical
-form, and canonicalize their result.  The canonical from means that the
-denominator and the numerator have no common factors, and that the
-denominator is positive.  Zero has the unique representation 0/1.
-
-   Pure assignment functions do not canonicalize the assigned variable.
-It is the responsibility of the user to canonicalize the assigned
-variable before any arithmetic operations are performed on that
-variable.
-
- -- Function: void mpq_canonicalize (mpq_t OP)
-     Remove any factors that are common to the numerator and
-     denominator of OP, and make the denominator positive.
-
-* Menu:
-
-* Initializing Rationals::
-* Rational Conversions::
-* Rational Arithmetic::
-* Comparing Rationals::
-* Applying Integer Functions::
-* I/O of Rationals::
-
-
-File: gmp.info,  Node: Initializing Rationals,  Next: Rational Conversions,  Prev: Rational Number Functions,  Up: Rational Number Functions
-
-6.1 Initialization and Assignment Functions
-===========================================
-
- -- Function: void mpq_init (mpq_t X)
-     Initialize X and set it to 0/1.  Each variable should normally
-     only be initialized once, or at least cleared out (using the
-     function `mpq_clear') between each initialization.
-
- -- Function: void mpq_inits (mpq_t X, ...)
-     Initialize a NULL-terminated list of `mpq_t' variables, and set
-     their values to 0/1.
-
- -- Function: void mpq_clear (mpq_t X)
-     Free the space occupied by X.  Make sure to call this function for
-     all `mpq_t' variables when you are done with them.
-
- -- Function: void mpq_clears (mpq_t X, ...)
-     Free the space occupied by a NULL-terminated list of `mpq_t'
-     variables.
-
- -- Function: void mpq_set (mpq_t ROP, mpq_t OP)
- -- Function: void mpq_set_z (mpq_t ROP, mpz_t OP)
-     Assign ROP from OP.
-
- -- Function: void mpq_set_ui (mpq_t ROP, unsigned long int OP1,
-          unsigned long int OP2)
- -- Function: void mpq_set_si (mpq_t ROP, signed long int OP1, unsigned
-          long int OP2)
-     Set the value of ROP to OP1/OP2.  Note that if OP1 and OP2 have
-     common factors, ROP has to be passed to `mpq_canonicalize' before
-     any operations are performed on ROP.
-
- -- Function: int mpq_set_str (mpq_t ROP, char *STR, int BASE)
-     Set ROP from a null-terminated string STR in the given BASE.
-
-     The string can be an integer like "41" or a fraction like
-     "41/152".  The fraction must be in canonical form (*note Rational
-     Number Functions::), or if not then `mpq_canonicalize' must be
-     called.
-
-     The numerator and optional denominator are parsed the same as in
-     `mpz_set_str' (*note Assigning Integers::).  White space is
-     allowed in the string, and is simply ignored.  The BASE can vary
-     from 2 to 62, or if BASE is 0 then the leading characters are
-     used: `0x' or `0X' for hex, `0b' or `0B' for binary, `0' for
-     octal, or decimal otherwise.  Note that this is done separately
-     for the numerator and denominator, so for instance `0xEF/100' is
-     239/100, whereas `0xEF/0x100' is 239/256.
-
-     The return value is 0 if the entire string is a valid number, or
-     -1 if not.
-
- -- Function: void mpq_swap (mpq_t ROP1, mpq_t ROP2)
-     Swap the values ROP1 and ROP2 efficiently.
-
-
-File: gmp.info,  Node: Rational Conversions,  Next: Rational Arithmetic,  Prev: Initializing Rationals,  Up: Rational Number Functions
-
-6.2 Conversion Functions
-========================
-
- -- Function: double mpq_get_d (mpq_t OP)
-     Convert OP to a `double', truncating if necessary (ie. rounding
-     towards zero).
-
-     If the exponent from the conversion is too big or too small to fit
-     a `double' then the result is system dependent.  For too big an
-     infinity is returned when available.  For too small 0.0 is
-     normally returned.  Hardware overflow, underflow and denorm traps
-     may or may not occur.
-
- -- Function: void mpq_set_d (mpq_t ROP, double OP)
- -- Function: void mpq_set_f (mpq_t ROP, mpf_t OP)
-     Set ROP to the value of OP.  There is no rounding, this conversion
-     is exact.
-
- -- Function: char * mpq_get_str (char *STR, int BASE, mpq_t OP)
-     Convert OP to a string of digits in base BASE.  The base may vary
-     from 2 to 36.  The string will be of the form `num/den', or if the
-     denominator is 1 then just `num'.
-
-     If STR is `NULL', the result string is allocated using the current
-     allocation function (*note Custom Allocation::).  The block will be
-     `strlen(str)+1' bytes, that being exactly enough for the string and
-     null-terminator.
-
-     If STR is not `NULL', it should point to a block of storage large
-     enough for the result, that being
-
-          mpz_sizeinbase (mpq_numref(OP), BASE)
-          + mpz_sizeinbase (mpq_denref(OP), BASE) + 3
-
-     The three extra bytes are for a possible minus sign, possible
-     slash, and the null-terminator.
-
-     A pointer to the result string is returned, being either the
-     allocated block, or the given STR.
-
-
-File: gmp.info,  Node: Rational Arithmetic,  Next: Comparing Rationals,  Prev: Rational Conversions,  Up: Rational Number Functions
-
-6.3 Arithmetic Functions
-========================
-
- -- Function: void mpq_add (mpq_t SUM, mpq_t ADDEND1, mpq_t ADDEND2)
-     Set SUM to ADDEND1 + ADDEND2.
-
- -- Function: void mpq_sub (mpq_t DIFFERENCE, mpq_t MINUEND, mpq_t
-          SUBTRAHEND)
-     Set DIFFERENCE to MINUEND - SUBTRAHEND.
-
- -- Function: void mpq_mul (mpq_t PRODUCT, mpq_t MULTIPLIER, mpq_t
-          MULTIPLICAND)
-     Set PRODUCT to MULTIPLIER times MULTIPLICAND.
-
- -- Function: void mpq_mul_2exp (mpq_t ROP, mpq_t OP1, mp_bitcnt_t OP2)
-     Set ROP to OP1 times 2 raised to OP2.
-
- -- Function: void mpq_div (mpq_t QUOTIENT, mpq_t DIVIDEND, mpq_t
-          DIVISOR)
-     Set QUOTIENT to DIVIDEND/DIVISOR.
-
- -- Function: void mpq_div_2exp (mpq_t ROP, mpq_t OP1, mp_bitcnt_t OP2)
-     Set ROP to OP1 divided by 2 raised to OP2.
-
- -- Function: void mpq_neg (mpq_t NEGATED_OPERAND, mpq_t OPERAND)
-     Set NEGATED_OPERAND to -OPERAND.
-
- -- Function: void mpq_abs (mpq_t ROP, mpq_t OP)
-     Set ROP to the absolute value of OP.
-
- -- Function: void mpq_inv (mpq_t INVERTED_NUMBER, mpq_t NUMBER)
-     Set INVERTED_NUMBER to 1/NUMBER.  If the new denominator is zero,
-     this routine will divide by zero.
-
-
-File: gmp.info,  Node: Comparing Rationals,  Next: Applying Integer Functions,  Prev: Rational Arithmetic,  Up: Rational Number Functions
-
-6.4 Comparison Functions
-========================
-
- -- Function: int mpq_cmp (mpq_t OP1, mpq_t OP2)
-     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
-     if OP1 = OP2, and a negative value if OP1 < OP2.
-
-     To determine if two rationals are equal, `mpq_equal' is faster than
-     `mpq_cmp'.
-
- -- Macro: int mpq_cmp_ui (mpq_t OP1, unsigned long int NUM2, unsigned
-          long int DEN2)
- -- Macro: int mpq_cmp_si (mpq_t OP1, long int NUM2, unsigned long int
-          DEN2)
-     Compare OP1 and NUM2/DEN2.  Return a positive value if OP1 >
-     NUM2/DEN2, zero if OP1 = NUM2/DEN2, and a negative value if OP1 <
-     NUM2/DEN2.
-
-     NUM2 and DEN2 are allowed to have common factors.
-
-     These functions are implemented as a macros and evaluate their
-     arguments multiple times.
-
- -- Macro: int mpq_sgn (mpq_t OP)
-     Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.
-
-     This function is actually implemented as a macro.  It evaluates its
-     arguments multiple times.
-
- -- Function: int mpq_equal (mpq_t OP1, mpq_t OP2)
-     Return non-zero if OP1 and OP2 are equal, zero if they are
-     non-equal.  Although `mpq_cmp' can be used for the same purpose,
-     this function is much faster.
-
-
-File: gmp.info,  Node: Applying Integer Functions,  Next: I/O of Rationals,  Prev: Comparing Rationals,  Up: Rational Number Functions
-
-6.5 Applying Integer Functions to Rationals
-===========================================
-
-The set of `mpq' functions is quite small.  In particular, there are few
-functions for either input or output.  The following functions give
-direct access to the numerator and denominator of an `mpq_t'.
-
-   Note that if an assignment to the numerator and/or denominator could
-take an `mpq_t' out of the canonical form described at the start of
-this chapter (*note Rational Number Functions::) then
-`mpq_canonicalize' must be called before any other `mpq' functions are
-applied to that `mpq_t'.
-
- -- Macro: mpz_t mpq_numref (mpq_t OP)
- -- Macro: mpz_t mpq_denref (mpq_t OP)
-     Return a reference to the numerator and denominator of OP,
-     respectively.  The `mpz' functions can be used on the result of
-     these macros.
-
- -- Function: void mpq_get_num (mpz_t NUMERATOR, mpq_t RATIONAL)
- -- Function: void mpq_get_den (mpz_t DENOMINATOR, mpq_t RATIONAL)
- -- Function: void mpq_set_num (mpq_t RATIONAL, mpz_t NUMERATOR)
- -- Function: void mpq_set_den (mpq_t RATIONAL, mpz_t DENOMINATOR)
-     Get or set the numerator or denominator of a rational.  These
-     functions are equivalent to calling `mpz_set' with an appropriate
-     `mpq_numref' or `mpq_denref'.  Direct use of `mpq_numref' or
-     `mpq_denref' is recommended instead of these functions.
-
-
-File: gmp.info,  Node: I/O of Rationals,  Prev: Applying Integer Functions,  Up: Rational Number Functions
-
-6.6 Input and Output Functions
-==============================
-
-Functions that perform input from a stdio stream, and functions that
-output to a stdio stream, of `mpq' numbers.  Passing a `NULL' pointer
-for a STREAM argument to any of these functions will make them read from
-`stdin' and write to `stdout', respectively.
-
-   When using any of these functions, it is a good idea to include
-`stdio.h' before `gmp.h', since that will allow `gmp.h' to define
-prototypes for these functions.
-
-   See also *Note Formatted Output:: and *Note Formatted Input::.
-
- -- Function: size_t mpq_out_str (FILE *STREAM, int BASE, mpq_t OP)
-     Output OP on stdio stream STREAM, as a string of digits in base
-     BASE.  The base may vary from 2 to 36.  Output is in the form
-     `num/den' or if the denominator is 1 then just `num'.
-
-     Return the number of bytes written, or if an error occurred,
-     return 0.
-
- -- Function: size_t mpq_inp_str (mpq_t ROP, FILE *STREAM, int BASE)
-     Read a string of digits from STREAM and convert them to a rational
-     in ROP.  Any initial white-space characters are read and
-     discarded.  Return the number of characters read (including white
-     space), or 0 if a rational could not be read.
-
-     The input can be a fraction like `17/63' or just an integer like
-     `123'.  Reading stops at the first character not in this form, and
-     white space is not permitted within the string.  If the input
-     might not be in canonical form, then `mpq_canonicalize' must be
-     called (*note Rational Number Functions::).
-
-     The BASE can be between 2 and 36, or can be 0 in which case the
-     leading characters of the string determine the base, `0x' or `0X'
-     for hexadecimal, `0' for octal, or decimal otherwise.  The leading
-     characters are examined separately for the numerator and
-     denominator of a fraction, so for instance `0x10/11' is 16/11,
-     whereas `0x10/0x11' is 16/17.
-
-
-File: gmp.info,  Node: Floating-point Functions,  Next: Low-level Functions,  Prev: Rational Number Functions,  Up: Top
-
-7 Floating-point Functions
-**************************
-
-GMP floating point numbers are stored in objects of type `mpf_t' and
-functions operating on them have an `mpf_' prefix.
-
-   The mantissa of each float has a user-selectable precision, limited
-only by available memory.  Each variable has its own precision, and
-that can be increased or decreased at any time.
-
-   The exponent of each float is a fixed precision, one machine word on
-most systems.  In the current implementation the exponent is a count of
-limbs, so for example on a 32-bit system this means a range of roughly
-2^-68719476768 to 2^68719476736, or on a 64-bit system this will be
-greater.  Note however `mpf_get_str' can only return an exponent which
-fits an `mp_exp_t' and currently `mpf_set_str' doesn't accept exponents
-bigger than a `long'.
-
-   Each variable keeps a size for the mantissa data actually in use.
-This means that if a float is exactly represented in only a few bits
-then only those bits will be used in a calculation, even if the
-selected precision is high.
-
-   All calculations are performed to the precision of the destination
-variable.  Each function is defined to calculate with "infinite
-precision" followed by a truncation to the destination precision, but
-of course the work done is only what's needed to determine a result
-under that definition.
-
-   The precision selected for a variable is a minimum value, GMP may
-increase it a little to facilitate efficient calculation.  Currently
-this means rounding up to a whole limb, and then sometimes having a
-further partial limb, depending on the high limb of the mantissa.  But
-applications shouldn't be concerned by such details.
-
-   The mantissa in stored in binary, as might be imagined from the fact
-precisions are expressed in bits.  One consequence of this is that
-decimal fractions like 0.1 cannot be represented exactly.  The same is
-true of plain IEEE `double' floats.  This makes both highly unsuitable
-for calculations involving money or other values that should be exact
-decimal fractions.  (Suitably scaled integers, or perhaps rationals,
-are better choices.)
-
-   `mpf' functions and variables have no special notion of infinity or
-not-a-number, and applications must take care not to overflow the
-exponent or results will be unpredictable.  This might change in a
-future release.
-
-   Note that the `mpf' functions are _not_ intended as a smooth
-extension to IEEE P754 arithmetic.  In particular results obtained on
-one computer often differ from the results on a computer with a
-different word size.
-
-* Menu:
-
-* Initializing Floats::
-* Assigning Floats::
-* Simultaneous Float Init & Assign::
-* Converting Floats::
-* Float Arithmetic::
-* Float Comparison::
-* I/O of Floats::
-* Miscellaneous Float Functions::
-
-
-File: gmp.info,  Node: Initializing Floats,  Next: Assigning Floats,  Prev: Floating-point Functions,  Up: Floating-point Functions
-
-7.1 Initialization Functions
-============================
-
- -- Function: void mpf_set_default_prec (mp_bitcnt_t PREC)
-     Set the default precision to be *at least* PREC bits.  All
-     subsequent calls to `mpf_init' will use this precision, but
-     previously initialized variables are unaffected.
-
- -- Function: mp_bitcnt_t mpf_get_default_prec (void)
-     Return the default precision actually used.
-
-   An `mpf_t' object must be initialized before storing the first value
-in it.  The functions `mpf_init' and `mpf_init2' are used for that
-purpose.
-
- -- Function: void mpf_init (mpf_t X)
-     Initialize X to 0.  Normally, a variable should be initialized
-     once only or at least be cleared, using `mpf_clear', between
-     initializations.  The precision of X is undefined unless a default
-     precision has already been established by a call to
-     `mpf_set_default_prec'.
-
- -- Function: void mpf_init2 (mpf_t X, mp_bitcnt_t PREC)
-     Initialize X to 0 and set its precision to be *at least* PREC
-     bits.  Normally, a variable should be initialized once only or at
-     least be cleared, using `mpf_clear', between initializations.
-
- -- Function: void mpf_inits (mpf_t X, ...)
-     Initialize a NULL-terminated list of `mpf_t' variables, and set
-     their values to 0.  The precision of the initialized variables is
-     undefined unless a default precision has already been established
-     by a call to `mpf_set_default_prec'.
-
- -- Function: void mpf_clear (mpf_t X)
-     Free the space occupied by X.  Make sure to call this function for
-     all `mpf_t' variables when you are done with them.
-
- -- Function: void mpf_clears (mpf_t X, ...)
-     Free the space occupied by a NULL-terminated list of `mpf_t'
-     variables.
-
-   Here is an example on how to initialize floating-point variables:
-     {
-       mpf_t x, y;
-       mpf_init (x);           /* use default precision */
-       mpf_init2 (y, 256);     /* precision _at least_ 256 bits */
-       ...
-       /* Unless the program is about to exit, do ... */
-       mpf_clear (x);
-       mpf_clear (y);
-     }
-
-   The following three functions are useful for changing the precision
-during a calculation.  A typical use would be for adjusting the
-precision gradually in iterative algorithms like Newton-Raphson, making
-the computation precision closely match the actual accurate part of the
-numbers.
-
- -- Function: mp_bitcnt_t mpf_get_prec (mpf_t OP)
-     Return the current precision of OP, in bits.
-
- -- Function: void mpf_set_prec (mpf_t ROP, mp_bitcnt_t PREC)
-     Set the precision of ROP to be *at least* PREC bits.  The value in
-     ROP will be truncated to the new precision.
-
-     This function requires a call to `realloc', and so should not be
-     used in a tight loop.
-
- -- Function: void mpf_set_prec_raw (mpf_t ROP, mp_bitcnt_t PREC)
-     Set the precision of ROP to be *at least* PREC bits, without
-     changing the memory allocated.
-
-     PREC must be no more than the allocated precision for ROP, that
-     being the precision when ROP was initialized, or in the most recent
-     `mpf_set_prec'.
-
-     The value in ROP is unchanged, and in particular if it had a higher
-     precision than PREC it will retain that higher precision.  New
-     values written to ROP will use the new PREC.
-
-     Before calling `mpf_clear' or the full `mpf_set_prec', another
-     `mpf_set_prec_raw' call must be made to restore ROP to its original
-     allocated precision.  Failing to do so will have unpredictable
-     results.
-
-     `mpf_get_prec' can be used before `mpf_set_prec_raw' to get the
-     original allocated precision.  After `mpf_set_prec_raw' it
-     reflects the PREC value set.
-
-     `mpf_set_prec_raw' is an efficient way to use an `mpf_t' variable
-     at different precisions during a calculation, perhaps to gradually
-     increase precision in an iteration, or just to use various
-     different precisions for different purposes during a calculation.
-
-
-File: gmp.info,  Node: Assigning Floats,  Next: Simultaneous Float Init & Assign,  Prev: Initializing Floats,  Up: Floating-point Functions
-
-7.2 Assignment Functions
-========================
-
-These functions assign new values to already initialized floats (*note
-Initializing Floats::).
-
- -- Function: void mpf_set (mpf_t ROP, mpf_t OP)
- -- Function: void mpf_set_ui (mpf_t ROP, unsigned long int OP)
- -- Function: void mpf_set_si (mpf_t ROP, signed long int OP)
- -- Function: void mpf_set_d (mpf_t ROP, double OP)
- -- Function: void mpf_set_z (mpf_t ROP, mpz_t OP)
- -- Function: void mpf_set_q (mpf_t ROP, mpq_t OP)
-     Set the value of ROP from OP.
-
- -- Function: int mpf_set_str (mpf_t ROP, char *STR, int BASE)
-     Set the value of ROP from the string in STR.  The string is of the
-     form `M@N' or, if the base is 10 or less, alternatively `MeN'.
-     `M' is the mantissa and `N' is the exponent.  The mantissa is
-     always in the specified base.  The exponent is either in the
-     specified base or, if BASE is negative, in decimal.  The decimal
-     point expected is taken from the current locale, on systems
-     providing `localeconv'.
-
-     The argument BASE may be in the ranges 2 to 62, or -62 to -2.
-     Negative values are used to specify that the exponent is in
-     decimal.
-
-     For bases up to 36, case is ignored; upper-case and lower-case
-     letters have the same value; for bases 37 to 62, upper-case letter
-     represent the usual 10..35 while lower-case letter represent
-     36..61.
-
-     Unlike the corresponding `mpz' function, the base will not be
-     determined from the leading characters of the string if BASE is 0.
-     This is so that numbers like `0.23' are not interpreted as octal.
-
-     White space is allowed in the string, and is simply ignored.
-     [This is not really true; white-space is ignored in the beginning
-     of the string and within the mantissa, but not in other places,
-     such as after a minus sign or in the exponent.  We are considering
-     changing the definition of this function, making it fail when
-     there is any white-space in the input, since that makes a lot of
-     sense.  Please tell us your opinion about this change.  Do you
-     really want it to accept "3 14" as meaning 314 as it does now?]
-
-     This function returns 0 if the entire string is a valid number in
-     base BASE.  Otherwise it returns -1.
-
- -- Function: void mpf_swap (mpf_t ROP1, mpf_t ROP2)
-     Swap ROP1 and ROP2 efficiently.  Both the values and the
-     precisions of the two variables are swapped.
-
-
-File: gmp.info,  Node: Simultaneous Float Init & Assign,  Next: Converting Floats,  Prev: Assigning Floats,  Up: Floating-point Functions
-
-7.3 Combined Initialization and Assignment Functions
-====================================================
-
-For convenience, GMP provides a parallel series of initialize-and-set
-functions which initialize the output and then store the value there.
-These functions' names have the form `mpf_init_set...'
-
-   Once the float has been initialized by any of the `mpf_init_set...'
-functions, it can be used as the source or destination operand for the
-ordinary float functions.  Don't use an initialize-and-set function on
-a variable already initialized!
-
- -- Function: void mpf_init_set (mpf_t ROP, mpf_t OP)
- -- Function: void mpf_init_set_ui (mpf_t ROP, unsigned long int OP)
- -- Function: void mpf_init_set_si (mpf_t ROP, signed long int OP)
- -- Function: void mpf_init_set_d (mpf_t ROP, double OP)
-     Initialize ROP and set its value from OP.
-
-     The precision of ROP will be taken from the active default
-     precision, as set by `mpf_set_default_prec'.
-
- -- Function: int mpf_init_set_str (mpf_t ROP, char *STR, int BASE)
-     Initialize ROP and set its value from the string in STR.  See
-     `mpf_set_str' above for details on the assignment operation.
-
-     Note that ROP is initialized even if an error occurs.  (I.e., you
-     have to call `mpf_clear' for it.)
-
-     The precision of ROP will be taken from the active default
-     precision, as set by `mpf_set_default_prec'.
-
-
-File: gmp.info,  Node: Converting Floats,  Next: Float Arithmetic,  Prev: Simultaneous Float Init & Assign,  Up: Floating-point Functions
-
-7.4 Conversion Functions
-========================
-
- -- Function: double mpf_get_d (mpf_t OP)
-     Convert OP to a `double', truncating if necessary (ie. rounding
-     towards zero).
-
-     If the exponent in OP is too big or too small to fit a `double'
-     then the result is system dependent.  For too big an infinity is
-     returned when available.  For too small 0.0 is normally returned.
-     Hardware overflow, underflow and denorm traps may or may not occur.
-
- -- Function: double mpf_get_d_2exp (signed long int *EXP, mpf_t OP)
-     Convert OP to a `double', truncating if necessary (ie. rounding
-     towards zero), and with an exponent returned separately.
-
-     The return value is in the range 0.5<=abs(D)<1 and the exponent is
-     stored to `*EXP'.  D * 2^EXP is the (truncated) OP value.  If OP
-     is zero, the return is 0.0 and 0 is stored to `*EXP'.
-
-     This is similar to the standard C `frexp' function (*note
-     Normalization Functions: (libc)Normalization Functions.).
-
- -- Function: long mpf_get_si (mpf_t OP)
- -- Function: unsigned long mpf_get_ui (mpf_t OP)
-     Convert OP to a `long' or `unsigned long', truncating any fraction
-     part.  If OP is too big for the return type, the result is
-     undefined.
-
-     See also `mpf_fits_slong_p' and `mpf_fits_ulong_p' (*note
-     Miscellaneous Float Functions::).
-
- -- Function: char * mpf_get_str (char *STR, mp_exp_t *EXPPTR, int
-          BASE, size_t N_DIGITS, mpf_t OP)
-     Convert OP to a string of digits in base BASE.  The base argument
-     may vary from 2 to 62 or from -2 to -36.  Up to N_DIGITS digits
-     will be generated.  Trailing zeros are not returned.  No more
-     digits than can be accurately represented by OP are ever
-     generated.  If N_DIGITS is 0 then that accurate maximum number of
-     digits are generated.
-
-     For BASE in the range 2..36, digits and lower-case letters are
-     used; for -2..-36, digits and upper-case letters are used; for
-     37..62, digits, upper-case letters, and lower-case letters (in
-     that significance order) are used.
-
-     If STR is `NULL', the result string is allocated using the current
-     allocation function (*note Custom Allocation::).  The block will be
-     `strlen(str)+1' bytes, that being exactly enough for the string and
-     null-terminator.
-
-     If STR is not `NULL', it should point to a block of N_DIGITS + 2
-     bytes, that being enough for the mantissa, a possible minus sign,
-     and a null-terminator.  When N_DIGITS is 0 to get all significant
-     digits, an application won't be able to know the space required,
-     and STR should be `NULL' in that case.
-
-     The generated string is a fraction, with an implicit radix point
-     immediately to the left of the first digit.  The applicable
-     exponent is written through the EXPPTR pointer.  For example, the
-     number 3.1416 would be returned as string "31416" and exponent 1.
-
-     When OP is zero, an empty string is produced and the exponent
-     returned is 0.
-
-     A pointer to the result string is returned, being either the
-     allocated block or the given STR.
-
-
-File: gmp.info,  Node: Float Arithmetic,  Next: Float Comparison,  Prev: Converting Floats,  Up: Floating-point Functions
-
-7.5 Arithmetic Functions
-========================
-
- -- Function: void mpf_add (mpf_t ROP, mpf_t OP1, mpf_t OP2)
- -- Function: void mpf_add_ui (mpf_t ROP, mpf_t OP1, unsigned long int
-          OP2)
-     Set ROP to OP1 + OP2.
-
- -- Function: void mpf_sub (mpf_t ROP, mpf_t OP1, mpf_t OP2)
- -- Function: void mpf_ui_sub (mpf_t ROP, unsigned long int OP1, mpf_t
-          OP2)
- -- Function: void mpf_sub_ui (mpf_t ROP, mpf_t OP1, unsigned long int
-          OP2)
-     Set ROP to OP1 - OP2.
-
- -- Function: void mpf_mul (mpf_t ROP, mpf_t OP1, mpf_t OP2)
- -- Function: void mpf_mul_ui (mpf_t ROP, mpf_t OP1, unsigned long int
-          OP2)
-     Set ROP to OP1 times OP2.
-
-   Division is undefined if the divisor is zero, and passing a zero
-divisor to the divide functions will make these functions intentionally
-divide by zero.  This lets the user handle arithmetic exceptions in
-these functions in the same manner as other arithmetic exceptions.
-
- -- Function: void mpf_div (mpf_t ROP, mpf_t OP1, mpf_t OP2)
- -- Function: void mpf_ui_div (mpf_t ROP, unsigned long int OP1, mpf_t
-          OP2)
- -- Function: void mpf_div_ui (mpf_t ROP, mpf_t OP1, unsigned long int
-          OP2)
-     Set ROP to OP1/OP2.
-
- -- Function: void mpf_sqrt (mpf_t ROP, mpf_t OP)
- -- Function: void mpf_sqrt_ui (mpf_t ROP, unsigned long int OP)
-     Set ROP to the square root of OP.
-
- -- Function: void mpf_pow_ui (mpf_t ROP, mpf_t OP1, unsigned long int
-          OP2)
-     Set ROP to OP1 raised to the power OP2.
-
- -- Function: void mpf_neg (mpf_t ROP, mpf_t OP)
-     Set ROP to -OP.
-
- -- Function: void mpf_abs (mpf_t ROP, mpf_t OP)
-     Set ROP to the absolute value of OP.
-
- -- Function: void mpf_mul_2exp (mpf_t ROP, mpf_t OP1, mp_bitcnt_t OP2)
-     Set ROP to OP1 times 2 raised to OP2.
-
- -- Function: void mpf_div_2exp (mpf_t ROP, mpf_t OP1, mp_bitcnt_t OP2)
-     Set ROP to OP1 divided by 2 raised to OP2.
-
-
-File: gmp.info,  Node: Float Comparison,  Next: I/O of Floats,  Prev: Float Arithmetic,  Up: Floating-point Functions
-
-7.6 Comparison Functions
-========================
-
- -- Function: int mpf_cmp (mpf_t OP1, mpf_t OP2)
- -- Function: int mpf_cmp_d (mpf_t OP1, double OP2)
- -- Function: int mpf_cmp_ui (mpf_t OP1, unsigned long int OP2)
- -- Function: int mpf_cmp_si (mpf_t OP1, signed long int OP2)
-     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
-     if OP1 = OP2, and a negative value if OP1 < OP2.
-
-     `mpf_cmp_d' can be called with an infinity, but results are
-     undefined for a NaN.
-
- -- Function: int mpf_eq (mpf_t OP1, mpf_t OP2, mp_bitcnt_t op3)
-     Return non-zero if the first OP3 bits of OP1 and OP2 are equal,
-     zero otherwise.  I.e., test if OP1 and OP2 are approximately equal.
-
-     Caution 1: All version of GMP up to version 4.2.4 compared just
-     whole limbs, meaning sometimes more than OP3 bits, sometimes fewer.
-
-     Caution 2: This function will consider XXX11...111 and XX100...000
-     different, even if ... is replaced by a semi-infinite number of
-     bits.  Such numbers are really just one ulp off, and should be
-     considered equal.
-
- -- Function: void mpf_reldiff (mpf_t ROP, mpf_t OP1, mpf_t OP2)
-     Compute the relative difference between OP1 and OP2 and store the
-     result in ROP.  This is abs(OP1-OP2)/OP1.
-
- -- Macro: int mpf_sgn (mpf_t OP)
-     Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.
-
-     This function is actually implemented as a macro.  It evaluates
-     its arguments multiple times.
-
-
-File: gmp.info,  Node: I/O of Floats,  Next: Miscellaneous Float Functions,  Prev: Float Comparison,  Up: Floating-point Functions
-
-7.7 Input and Output Functions
-==============================
-
-Functions that perform input from a stdio stream, and functions that
-output to a stdio stream, of `mpf' numbers.  Passing a `NULL' pointer
-for a STREAM argument to any of these functions will make them read from
-`stdin' and write to `stdout', respectively.
-
-   When using any of these functions, it is a good idea to include
-`stdio.h' before `gmp.h', since that will allow `gmp.h' to define
-prototypes for these functions.
-
-   See also *Note Formatted Output:: and *Note Formatted Input::.
-
- -- Function: size_t mpf_out_str (FILE *STREAM, int BASE, size_t
-          N_DIGITS, mpf_t OP)
-     Print OP to STREAM, as a string of digits.  Return the number of
-     bytes written, or if an error occurred, return 0.
-
-     The mantissa is prefixed with an `0.' and is in the given BASE,
-     which may vary from 2 to 62 or from -2 to -36.  An exponent is
-     then printed, separated by an `e', or if the base is greater than
-     10 then by an `@'.  The exponent is always in decimal.  The
-     decimal point follows the current locale, on systems providing
-     `localeconv'.
-
-     For BASE in the range 2..36, digits and lower-case letters are
-     used; for -2..-36, digits and upper-case letters are used; for
-     37..62, digits, upper-case letters, and lower-case letters (in
-     that significance order) are used.
-
-     Up to N_DIGITS will be printed from the mantissa, except that no
-     more digits than are accurately representable by OP will be
-     printed.  N_DIGITS can be 0 to select that accurate maximum.
-
- -- Function: size_t mpf_inp_str (mpf_t ROP, FILE *STREAM, int BASE)
-     Read a string in base BASE from STREAM, and put the read float in
-     ROP.  The string is of the form `M@N' or, if the base is 10 or
-     less, alternatively `MeN'.  `M' is the mantissa and `N' is the
-     exponent.  The mantissa is always in the specified base.  The
-     exponent is either in the specified base or, if BASE is negative,
-     in decimal.  The decimal point expected is taken from the current
-     locale, on systems providing `localeconv'.
-
-     The argument BASE may be in the ranges 2 to 36, or -36 to -2.
-     Negative values are used to specify that the exponent is in
-     decimal.
-
-     Unlike the corresponding `mpz' function, the base will not be
-     determined from the leading characters of the string if BASE is 0.
-     This is so that numbers like `0.23' are not interpreted as octal.
-
-     Return the number of bytes read, or if an error occurred, return 0.
-
-
-File: gmp.info,  Node: Miscellaneous Float Functions,  Prev: I/O of Floats,  Up: Floating-point Functions
-
-7.8 Miscellaneous Functions
-===========================
-
- -- Function: void mpf_ceil (mpf_t ROP, mpf_t OP)
- -- Function: void mpf_floor (mpf_t ROP, mpf_t OP)
- -- Function: void mpf_trunc (mpf_t ROP, mpf_t OP)
-     Set ROP to OP rounded to an integer.  `mpf_ceil' rounds to the
-     next higher integer, `mpf_floor' to the next lower, and `mpf_trunc'
-     to the integer towards zero.
-
- -- Function: int mpf_integer_p (mpf_t OP)
-     Return non-zero if OP is an integer.
-
- -- Function: int mpf_fits_ulong_p (mpf_t OP)
- -- Function: int mpf_fits_slong_p (mpf_t OP)
- -- Function: int mpf_fits_uint_p (mpf_t OP)
- -- Function: int mpf_fits_sint_p (mpf_t OP)
- -- Function: int mpf_fits_ushort_p (mpf_t OP)
- -- Function: int mpf_fits_sshort_p (mpf_t OP)
-     Return non-zero if OP would fit in the respective C data type, when
-     truncated to an integer.
-
- -- Function: void mpf_urandomb (mpf_t ROP, gmp_randstate_t STATE,
-          mp_bitcnt_t NBITS)
-     Generate a uniformly distributed random float in ROP, such that 0
-     <= ROP < 1, with NBITS significant bits in the mantissa or less if
-     the precision of ROP is smaller.
-
-     The variable STATE must be initialized by calling one of the
-     `gmp_randinit' functions (*Note Random State Initialization::)
-     before invoking this function.
-
- -- Function: void mpf_random2 (mpf_t ROP, mp_size_t MAX_SIZE, mp_exp_t
-          EXP)
-     Generate a random float of at most MAX_SIZE limbs, with long
-     strings of zeros and ones in the binary representation.  The
-     exponent of the number is in the interval -EXP to EXP (in limbs).
-     This function is useful for testing functions and algorithms,
-     since these kind of random numbers have proven to be more likely
-     to trigger corner-case bugs.  Negative random numbers are
-     generated when MAX_SIZE is negative.
-
-
-File: gmp.info,  Node: Low-level Functions,  Next: Random Number Functions,  Prev: Floating-point Functions,  Up: Top
-
-8 Low-level Functions
-*********************
-
-This chapter describes low-level GMP functions, used to implement the
-high-level GMP functions, but also intended for time-critical user code.
-
-   These functions start with the prefix `mpn_'.
-
-   The `mpn' functions are designed to be as fast as possible, *not* to
-provide a coherent calling interface.  The different functions have
-somewhat similar interfaces, but there are variations that make them
-hard to use.  These functions do as little as possible apart from the
-real multiple precision computation, so that no time is spent on things
-that not all callers need.
-
-   A source operand is specified by a pointer to the least significant
-limb and a limb count.  A destination operand is specified by just a
-pointer.  It is the responsibility of the caller to ensure that the
-destination has enough space for storing the result.
-
-   With this way of specifying operands, it is possible to perform
-computations on subranges of an argument, and store the result into a
-subrange of a destination.
-
-   A common requirement for all functions is that each source area
-needs at least one limb.  No size argument may be zero.  Unless
-otherwise stated, in-place operations are allowed where source and
-destination are the same, but not where they only partly overlap.
-
-   The `mpn' functions are the base for the implementation of the
-`mpz_', `mpf_', and `mpq_' functions.
-
-   This example adds the number beginning at S1P and the number
-beginning at S2P and writes the sum at DESTP.  All areas have N limbs.
-
-     cy = mpn_add_n (destp, s1p, s2p, n)
-
-   It should be noted that the `mpn' functions make no attempt to
-identify high or low zero limbs on their operands, or other special
-forms.  On random data such cases will be unlikely and it'd be wasteful
-for every function to check every time.  An application knowing
-something about its data can take steps to trim or perhaps split its
-calculations.
-
-
-In the notation used below, a source operand is identified by the
-pointer to the least significant limb, and the limb count in braces.
-For example, {S1P, S1N}.
-
- -- Function: mp_limb_t mpn_add_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Add {S1P, N} and {S2P, N}, and write the N least significant limbs
-     of the result to RP.  Return carry, either 0 or 1.
-
-     This is the lowest-level function for addition.  It is the
-     preferred function for addition, since it is written in assembly
-     for most CPUs.  For addition of a variable to itself (i.e., S1P
-     equals S2P) use `mpn_lshift' with a count of 1 for optimal speed.
-
- -- Function: mp_limb_t mpn_add_1 (mp_limb_t *RP, const mp_limb_t *S1P,
-          mp_size_t N, mp_limb_t S2LIMB)
-     Add {S1P, N} and S2LIMB, and write the N least significant limbs
-     of the result to RP.  Return carry, either 0 or 1.
-
- -- Function: mp_limb_t mpn_add (mp_limb_t *RP, const mp_limb_t *S1P,
-          mp_size_t S1N, const mp_limb_t *S2P, mp_size_t S2N)
-     Add {S1P, S1N} and {S2P, S2N}, and write the S1N least significant
-     limbs of the result to RP.  Return carry, either 0 or 1.
-
-     This function requires that S1N is greater than or equal to S2N.
-
- -- Function: mp_limb_t mpn_sub_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Subtract {S2P, N} from {S1P, N}, and write the N least significant
-     limbs of the result to RP.  Return borrow, either 0 or 1.
-
-     This is the lowest-level function for subtraction.  It is the
-     preferred function for subtraction, since it is written in
-     assembly for most CPUs.
-
- -- Function: mp_limb_t mpn_sub_1 (mp_limb_t *RP, const mp_limb_t *S1P,
-          mp_size_t N, mp_limb_t S2LIMB)
-     Subtract S2LIMB from {S1P, N}, and write the N least significant
-     limbs of the result to RP.  Return borrow, either 0 or 1.
-
- -- Function: mp_limb_t mpn_sub (mp_limb_t *RP, const mp_limb_t *S1P,
-          mp_size_t S1N, const mp_limb_t *S2P, mp_size_t S2N)
-     Subtract {S2P, S2N} from {S1P, S1N}, and write the S1N least
-     significant limbs of the result to RP.  Return borrow, either 0 or
-     1.
-
-     This function requires that S1N is greater than or equal to S2N.
-
- -- Function: void mpn_neg (mp_limb_t *RP, const mp_limb_t *SP,
-          mp_size_t N)
-     Perform the negation of {SP, N}, and write the result to {RP, N}.
-     Return carry-out.
-
- -- Function: void mpn_mul_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Multiply {S1P, N} and {S2P, N}, and write the 2*N-limb result to
-     RP.
-
-     The destination has to have space for 2*N limbs, even if the
-     product's most significant limb is zero.  No overlap is permitted
-     between the destination and either source.
-
-     If the two input operands are the same, use `mpn_sqr'.
-
- -- Function: mp_limb_t mpn_mul (mp_limb_t *RP, const mp_limb_t *S1P,
-          mp_size_t S1N, const mp_limb_t *S2P, mp_size_t S2N)
-     Multiply {S1P, S1N} and {S2P, S2N}, and write the (S1N+S2N)-limb
-     result to RP.  Return the most significant limb of the result.
-
-     The destination has to have space for S1N + S2N limbs, even if the
-     product's most significant limb is zero.  No overlap is permitted
-     between the destination and either source.
-
-     This function requires that S1N is greater than or equal to S2N.
-
- -- Function: void mpn_sqr (mp_limb_t *RP, const mp_limb_t *S1P,
-          mp_size_t N)
-     Compute the square of {S1P, N} and write the 2*N-limb result to RP.
-
-     The destination has to have space for 2*N limbs, even if the
-     result's most significant limb is zero.  No overlap is permitted
-     between the destination and the source.
-
- -- Function: mp_limb_t mpn_mul_1 (mp_limb_t *RP, const mp_limb_t *S1P,
-          mp_size_t N, mp_limb_t S2LIMB)
-     Multiply {S1P, N} by S2LIMB, and write the N least significant
-     limbs of the product to RP.  Return the most significant limb of
-     the product.  {S1P, N} and {RP, N} are allowed to overlap provided
-     RP <= S1P.
-
-     This is a low-level function that is a building block for general
-     multiplication as well as other operations in GMP.  It is written
-     in assembly for most CPUs.
-
-     Don't call this function if S2LIMB is a power of 2; use
-     `mpn_lshift' with a count equal to the logarithm of S2LIMB
-     instead, for optimal speed.
-
- -- Function: mp_limb_t mpn_addmul_1 (mp_limb_t *RP, const mp_limb_t
-          *S1P, mp_size_t N, mp_limb_t S2LIMB)
-     Multiply {S1P, N} and S2LIMB, and add the N least significant
-     limbs of the product to {RP, N} and write the result to RP.
-     Return the most significant limb of the product, plus carry-out
-     from the addition.
-
-     This is a low-level function that is a building block for general
-     multiplication as well as other operations in GMP.  It is written
-     in assembly for most CPUs.
-
- -- Function: mp_limb_t mpn_submul_1 (mp_limb_t *RP, const mp_limb_t
-          *S1P, mp_size_t N, mp_limb_t S2LIMB)
-     Multiply {S1P, N} and S2LIMB, and subtract the N least significant
-     limbs of the product from {RP, N} and write the result to RP.
-     Return the most significant limb of the product, plus borrow-out
-     from the subtraction.
-
-     This is a low-level function that is a building block for general
-     multiplication and division as well as other operations in GMP.
-     It is written in assembly for most CPUs.
-
- -- Function: void mpn_tdiv_qr (mp_limb_t *QP, mp_limb_t *RP, mp_size_t
-          QXN, const mp_limb_t *NP, mp_size_t NN, const mp_limb_t *DP,
-          mp_size_t DN)
-     Divide {NP, NN} by {DP, DN} and put the quotient at {QP, NN-DN+1}
-     and the remainder at {RP, DN}.  The quotient is rounded towards 0.
-
-     No overlap is permitted between arguments, except that NP might
-     equal RP.  The dividend size NN must be greater than or equal to
-     divisor size DN.  The most significant limb of the divisor must be
-     non-zero.  The QXN operand must be zero.
-
- -- Function: mp_limb_t mpn_divrem (mp_limb_t *R1P, mp_size_t QXN,
-          mp_limb_t *RS2P, mp_size_t RS2N, const mp_limb_t *S3P,
-          mp_size_t S3N)
-     [This function is obsolete.  Please call `mpn_tdiv_qr' instead for
-     best performance.]
-
-     Divide {RS2P, RS2N} by {S3P, S3N}, and write the quotient at R1P,
-     with the exception of the most significant limb, which is
-     returned.  The remainder replaces the dividend at RS2P; it will be
-     S3N limbs long (i.e., as many limbs as the divisor).
-
-     In addition to an integer quotient, QXN fraction limbs are
-     developed, and stored after the integral limbs.  For most usages,
-     QXN will be zero.
-
-     It is required that RS2N is greater than or equal to S3N.  It is
-     required that the most significant bit of the divisor is set.
-
-     If the quotient is not needed, pass RS2P + S3N as R1P.  Aside from
-     that special case, no overlap between arguments is permitted.
-
-     Return the most significant limb of the quotient, either 0 or 1.
-
-     The area at R1P needs to be RS2N - S3N + QXN limbs large.
-
- -- Function: mp_limb_t mpn_divrem_1 (mp_limb_t *R1P, mp_size_t QXN,
-          mp_limb_t *S2P, mp_size_t S2N, mp_limb_t S3LIMB)
- -- Macro: mp_limb_t mpn_divmod_1 (mp_limb_t *R1P, mp_limb_t *S2P,
-          mp_size_t S2N, mp_limb_t S3LIMB)
-     Divide {S2P, S2N} by S3LIMB, and write the quotient at R1P.
-     Return the remainder.
-
-     The integer quotient is written to {R1P+QXN, S2N} and in addition
-     QXN fraction limbs are developed and written to {R1P, QXN}.
-     Either or both S2N and QXN can be zero.  For most usages, QXN will
-     be zero.
-
-     `mpn_divmod_1' exists for upward source compatibility and is
-     simply a macro calling `mpn_divrem_1' with a QXN of 0.
-
-     The areas at R1P and S2P have to be identical or completely
-     separate, not partially overlapping.
-
- -- Function: mp_limb_t mpn_divmod (mp_limb_t *R1P, mp_limb_t *RS2P,
-          mp_size_t RS2N, const mp_limb_t *S3P, mp_size_t S3N)
-     [This function is obsolete.  Please call `mpn_tdiv_qr' instead for
-     best performance.]
-
- -- Macro: mp_limb_t mpn_divexact_by3 (mp_limb_t *RP, mp_limb_t *SP,
-          mp_size_t N)
- -- Function: mp_limb_t mpn_divexact_by3c (mp_limb_t *RP, mp_limb_t
-          *SP, mp_size_t N, mp_limb_t CARRY)
-     Divide {SP, N} by 3, expecting it to divide exactly, and writing
-     the result to {RP, N}.  If 3 divides exactly, the return value is
-     zero and the result is the quotient.  If not, the return value is
-     non-zero and the result won't be anything useful.
-
-     `mpn_divexact_by3c' takes an initial carry parameter, which can be
-     the return value from a previous call, so a large calculation can
-     be done piece by piece from low to high.  `mpn_divexact_by3' is
-     simply a macro calling `mpn_divexact_by3c' with a 0 carry
-     parameter.
-
-     These routines use a multiply-by-inverse and will be faster than
-     `mpn_divrem_1' on CPUs with fast multiplication but slow division.
-
-     The source a, result q, size n, initial carry i, and return value
-     c satisfy c*b^n + a-i = 3*q, where b=2^GMP_NUMB_BITS.  The return
-     c is always 0, 1 or 2, and the initial carry i must also be 0, 1
-     or 2 (these are both borrows really).  When c=0 clearly q=(a-i)/3.
-     When c!=0, the remainder (a-i) mod 3 is given by 3-c, because b
-     == 1 mod 3 (when `mp_bits_per_limb' is even, which is always so
-     currently).
-
- -- Function: mp_limb_t mpn_mod_1 (const mp_limb_t *S1P, mp_size_t S1N,
-          mp_limb_t S2LIMB)
-     Divide {S1P, S1N} by S2LIMB, and return the remainder.  S1N can be
-     zero.
-
- -- Function: mp_limb_t mpn_lshift (mp_limb_t *RP, const mp_limb_t *SP,
-          mp_size_t N, unsigned int COUNT)
-     Shift {SP, N} left by COUNT bits, and write the result to {RP, N}.
-     The bits shifted out at the left are returned in the least
-     significant COUNT bits of the return value (the rest of the return
-     value is zero).
-
-     COUNT must be in the range 1 to mp_bits_per_limb-1.  The regions
-     {SP, N} and {RP, N} may overlap, provided RP >= SP.
-
-     This function is written in assembly for most CPUs.
-
- -- Function: mp_limb_t mpn_rshift (mp_limb_t *RP, const mp_limb_t *SP,
-          mp_size_t N, unsigned int COUNT)
-     Shift {SP, N} right by COUNT bits, and write the result to {RP,
-     N}.  The bits shifted out at the right are returned in the most
-     significant COUNT bits of the return value (the rest of the return
-     value is zero).
-
-     COUNT must be in the range 1 to mp_bits_per_limb-1.  The regions
-     {SP, N} and {RP, N} may overlap, provided RP <= SP.
-
-     This function is written in assembly for most CPUs.
-
- -- Function: int mpn_cmp (const mp_limb_t *S1P, const mp_limb_t *S2P,
-          mp_size_t N)
-     Compare {S1P, N} and {S2P, N} and return a positive value if S1 >
-     S2, 0 if they are equal, or a negative value if S1 < S2.
-
- -- Function: mp_size_t mpn_gcd (mp_limb_t *RP, mp_limb_t *XP,
-          mp_size_t XN, mp_limb_t *YP, mp_size_t YN)
-     Set {RP, RETVAL} to the greatest common divisor of {XP, XN} and
-     {YP, YN}.  The result can be up to YN limbs, the return value is
-     the actual number produced.  Both source operands are destroyed.
-
-     {XP, XN} must have at least as many bits as {YP, YN}.  {YP, YN}
-     must be odd.  Both operands must have non-zero most significant
-     limbs.  No overlap is permitted between {XP, XN} and {YP, YN}.
-
- -- Function: mp_limb_t mpn_gcd_1 (const mp_limb_t *XP, mp_size_t XN,
-          mp_limb_t YLIMB)
-     Return the greatest common divisor of {XP, XN} and YLIMB.  Both
-     operands must be non-zero.
-
- -- Function: mp_size_t mpn_gcdext (mp_limb_t *GP, mp_limb_t *SP,
-          mp_size_t *SN, mp_limb_t *XP, mp_size_t XN, mp_limb_t *YP,
-          mp_size_t YN)
-     Let U be defined by {XP, XN} and let V be defined by {YP, YN}.
-
-     Compute the greatest common divisor G of U and V.  Compute a
-     cofactor S such that G = US + VT.  The second cofactor T is not
-     computed but can easily be obtained from (G - U*S) / V (the
-     division will be exact).  It is required that U >= V > 0.
-
-     S satisfies S = 1 or abs(S) < V / (2 G). S = 0 if and only if V
-     divides U (i.e., G = V).
-
-     Store G at GP and let the return value define its limb count.
-     Store S at SP and let |*SN| define its limb count.  S can be
-     negative; when this happens *SN will be negative.  The areas at GP
-     and SP should each have room for XN+1 limbs.
-
-     The areas {XP, XN+1} and {YP, YN+1} are destroyed (i.e. the input
-     operands plus an extra limb past the end of each).
-
-     Compatibility note: GMP 4.3.0 and 4.3.1 defined S less strictly.
-     Earlier as well as later GMP releases define S as described here.
-
- -- Function: mp_size_t mpn_sqrtrem (mp_limb_t *R1P, mp_limb_t *R2P,
-          const mp_limb_t *SP, mp_size_t N)
-     Compute the square root of {SP, N} and put the result at {R1P,
-     ceil(N/2)} and the remainder at {R2P, RETVAL}.  R2P needs space
-     for N limbs, but the return value indicates how many are produced.
-
-     The most significant limb of {SP, N} must be non-zero.  The areas
-     {R1P, ceil(N/2)} and {SP, N} must be completely separate.  The
-     areas {R2P, N} and {SP, N} must be either identical or completely
-     separate.
-
-     If the remainder is not wanted then R2P can be `NULL', and in this
-     case the return value is zero or non-zero according to whether the
-     remainder would have been zero or non-zero.
-
-     A return value of zero indicates a perfect square.  See also
-     `mpz_perfect_square_p'.
-
- -- Function: mp_size_t mpn_get_str (unsigned char *STR, int BASE,
-          mp_limb_t *S1P, mp_size_t S1N)
-     Convert {S1P, S1N} to a raw unsigned char array at STR in base
-     BASE, and return the number of characters produced.  There may be
-     leading zeros in the string.  The string is not in ASCII; to
-     convert it to printable format, add the ASCII codes for `0' or
-     `A', depending on the base and range.  BASE can vary from 2 to 256.
-
-     The most significant limb of the input {S1P, S1N} must be
-     non-zero.  The input {S1P, S1N} is clobbered, except when BASE is
-     a power of 2, in which case it's unchanged.
-
-     The area at STR has to have space for the largest possible number
-     represented by a S1N long limb array, plus one extra character.
-
- -- Function: mp_size_t mpn_set_str (mp_limb_t *RP, const unsigned char
-          *STR, size_t STRSIZE, int BASE)
-     Convert bytes {STR,STRSIZE} in the given BASE to limbs at RP.
-
-     STR[0] is the most significant byte and STR[STRSIZE-1] is the
-     least significant.  Each byte should be a value in the range 0 to
-     BASE-1, not an ASCII character.  BASE can vary from 2 to 256.
-
-     The return value is the number of limbs written to RP.  If the most
-     significant input byte is non-zero then the high limb at RP will be
-     non-zero, and only that exact number of limbs will be required
-     there.
-
-     If the most significant input byte is zero then there may be high
-     zero limbs written to RP and included in the return value.
-
-     STRSIZE must be at least 1, and no overlap is permitted between
-     {STR,STRSIZE} and the result at RP.
-
- -- Function: mp_bitcnt_t mpn_scan0 (const mp_limb_t *S1P, mp_bitcnt_t
-          BIT)
-     Scan S1P from bit position BIT for the next clear bit.
-
-     It is required that there be a clear bit within the area at S1P at
-     or beyond bit position BIT, so that the function has something to
-     return.
-
- -- Function: mp_bitcnt_t mpn_scan1 (const mp_limb_t *S1P, mp_bitcnt_t
-          BIT)
-     Scan S1P from bit position BIT for the next set bit.
-
-     It is required that there be a set bit within the area at S1P at or
-     beyond bit position BIT, so that the function has something to
-     return.
-
- -- Function: void mpn_random (mp_limb_t *R1P, mp_size_t R1N)
- -- Function: void mpn_random2 (mp_limb_t *R1P, mp_size_t R1N)
-     Generate a random number of length R1N and store it at R1P.  The
-     most significant limb is always non-zero.  `mpn_random' generates
-     uniformly distributed limb data, `mpn_random2' generates long
-     strings of zeros and ones in the binary representation.
-
-     `mpn_random2' is intended for testing the correctness of the `mpn'
-     routines.
-
- -- Function: mp_bitcnt_t mpn_popcount (const mp_limb_t *S1P, mp_size_t
-          N)
-     Count the number of set bits in {S1P, N}.
-
- -- Function: mp_bitcnt_t mpn_hamdist (const mp_limb_t *S1P, const
-          mp_limb_t *S2P, mp_size_t N)
-     Compute the hamming distance between {S1P, N} and {S2P, N}, which
-     is the number of bit positions where the two operands have
-     different bit values.
-
- -- Function: int mpn_perfect_square_p (const mp_limb_t *S1P, mp_size_t
-          N)
-     Return non-zero iff {S1P, N} is a perfect square.  The most
-     significant limb of the input {S1P, N} must be non-zero.
-
- -- Function: void mpn_and_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Perform the bitwise logical and of {S1P, N} and {S2P, N}, and
-     write the result to {RP, N}.
-
- -- Function: void mpn_ior_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Perform the bitwise logical inclusive or of {S1P, N} and {S2P, N},
-     and write the result to {RP, N}.
-
- -- Function: void mpn_xor_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Perform the bitwise logical exclusive or of {S1P, N} and {S2P, N},
-     and write the result to {RP, N}.
-
- -- Function: void mpn_andn_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Perform the bitwise logical and of {S1P, N} and the bitwise
-     complement of {S2P, N}, and write the result to {RP, N}.
-
- -- Function: void mpn_iorn_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Perform the bitwise logical inclusive or of {S1P, N} and the
-     bitwise complement of {S2P, N}, and write the result to {RP, N}.
-
- -- Function: void mpn_nand_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Perform the bitwise logical and of {S1P, N} and {S2P, N}, and
-     write the bitwise complement of the result to {RP, N}.
-
- -- Function: void mpn_nior_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Perform the bitwise logical inclusive or of {S1P, N} and {S2P, N},
-     and write the bitwise complement of the result to {RP, N}.
-
- -- Function: void mpn_xnor_n (mp_limb_t *RP, const mp_limb_t *S1P,
-          const mp_limb_t *S2P, mp_size_t N)
-     Perform the bitwise logical exclusive or of {S1P, N} and {S2P, N},
-     and write the bitwise complement of the result to {RP, N}.
-
- -- Function: void mpn_com (mp_limb_t *RP, const mp_limb_t *SP,
-          mp_size_t N)
-     Perform the bitwise complement of {SP, N}, and write the result to
-     {RP, N}.
-
- -- Function: void mpn_copyi (mp_limb_t *RP, const mp_limb_t *S1P,
-          mp_size_t N)
-     Copy from {S1P, N} to {RP, N}, increasingly.
-
- -- Function: void mpn_copyd (mp_limb_t *RP, const mp_limb_t *S1P,
-          mp_size_t N)
-     Copy from {S1P, N} to {RP, N}, decreasingly.
-
- -- Function: void mpn_zero (mp_limb_t *RP, mp_size_t N)
-     Zero {RP, N}.
-
-
-8.1 Nails
-=========
-
-*Everything in this section is highly experimental and may disappear or
-be subject to incompatible changes in a future version of GMP.*
-
-   Nails are an experimental feature whereby a few bits are left unused
-at the top of each `mp_limb_t'.  This can significantly improve carry
-handling on some processors.
-
-   All the `mpn' functions accepting limb data will expect the nail
-bits to be zero on entry, and will return data with the nails similarly
-all zero.  This applies both to limb vectors and to single limb
-arguments.
-
-   Nails can be enabled by configuring with `--enable-nails'.  By
-default the number of bits will be chosen according to what suits the
-host processor, but a particular number can be selected with
-`--enable-nails=N'.
-
-   At the mpn level, a nail build is neither source nor binary
-compatible with a non-nail build, strictly speaking.  But programs
-acting on limbs only through the mpn functions are likely to work
-equally well with either build, and judicious use of the definitions
-below should make any program compatible with either build, at the
-source level.
-
-   For the higher level routines, meaning `mpz' etc, a nail build
-should be fully source and binary compatible with a non-nail build.
-
- -- Macro: GMP_NAIL_BITS
- -- Macro: GMP_NUMB_BITS
- -- Macro: GMP_LIMB_BITS
-     `GMP_NAIL_BITS' is the number of nail bits, or 0 when nails are
-     not in use.  `GMP_NUMB_BITS' is the number of data bits in a limb.
-     `GMP_LIMB_BITS' is the total number of bits in an `mp_limb_t'.  In
-     all cases
-
-          GMP_LIMB_BITS == GMP_NAIL_BITS + GMP_NUMB_BITS
-
- -- Macro: GMP_NAIL_MASK
- -- Macro: GMP_NUMB_MASK
-     Bit masks for the nail and number parts of a limb.
-     `GMP_NAIL_MASK' is 0 when nails are not in use.
-
-     `GMP_NAIL_MASK' is not often needed, since the nail part can be
-     obtained with `x >> GMP_NUMB_BITS', and that means one less large
-     constant, which can help various RISC chips.
-
- -- Macro: GMP_NUMB_MAX
-     The maximum value that can be stored in the number part of a limb.
-     This is the same as `GMP_NUMB_MASK', but can be used for clarity
-     when doing comparisons rather than bit-wise operations.
-
-   The term "nails" comes from finger or toe nails, which are at the
-ends of a limb (arm or leg).  "numb" is short for number, but is also
-how the developers felt after trying for a long time to come up with
-sensible names for these things.
-
-   In the future (the distant future most likely) a non-zero nail might
-be permitted, giving non-unique representations for numbers in a limb
-vector.  This would help vector processors since carries would only
-ever need to propagate one or two limbs.
-
-
-File: gmp.info,  Node: Random Number Functions,  Next: Formatted Output,  Prev: Low-level Functions,  Up: Top
-
-9 Random Number Functions
-*************************
-
-Sequences of pseudo-random numbers in GMP are generated using a
-variable of type `gmp_randstate_t', which holds an algorithm selection
-and a current state.  Such a variable must be initialized by a call to
-one of the `gmp_randinit' functions, and can be seeded with one of the
-`gmp_randseed' functions.
-
-   The functions actually generating random numbers are described in
-*Note Integer Random Numbers::, and *Note Miscellaneous Float
-Functions::.
-
-   The older style random number functions don't accept a
-`gmp_randstate_t' parameter but instead share a global variable of that
-type.  They use a default algorithm and are currently not seeded
-(though perhaps that will change in the future).  The new functions
-accepting a `gmp_randstate_t' are recommended for applications that
-care about randomness.
-
-* Menu:
-
-* Random State Initialization::
-* Random State Seeding::
-* Random State Miscellaneous::
-
-
-File: gmp.info,  Node: Random State Initialization,  Next: Random State Seeding,  Prev: Random Number Functions,  Up: Random Number Functions
-
-9.1 Random State Initialization
-===============================
-
- -- Function: void gmp_randinit_default (gmp_randstate_t STATE)
-     Initialize STATE with a default algorithm.  This will be a
-     compromise between speed and randomness, and is recommended for
-     applications with no special requirements.  Currently this is
-     `gmp_randinit_mt'.
-
- -- Function: void gmp_randinit_mt (gmp_randstate_t STATE)
-     Initialize STATE for a Mersenne Twister algorithm.  This algorithm
-     is fast and has good randomness properties.
-
- -- Function: void gmp_randinit_lc_2exp (gmp_randstate_t STATE, mpz_t
-          A, unsigned long C, mp_bitcnt_t M2EXP)
-     Initialize STATE with a linear congruential algorithm X = (A*X +
-     C) mod 2^M2EXP.
-
-     The low bits of X in this algorithm are not very random.  The least
-     significant bit will have a period no more than 2, and the second
-     bit no more than 4, etc.  For this reason only the high half of
-     each X is actually used.
-
-     When a random number of more than M2EXP/2 bits is to be generated,
-     multiple iterations of the recurrence are used and the results
-     concatenated.
-
- -- Function: int gmp_randinit_lc_2exp_size (gmp_randstate_t STATE,
-          mp_bitcnt_t SIZE)
-     Initialize STATE for a linear congruential algorithm as per
-     `gmp_randinit_lc_2exp'.  A, C and M2EXP are selected from a table,
-     chosen so that SIZE bits (or more) of each X will be used, ie.
-     M2EXP/2 >= SIZE.
-
-     If successful the return value is non-zero.  If SIZE is bigger
-     than the table data provides then the return value is zero.  The
-     maximum SIZE currently supported is 128.
-
- -- Function: void gmp_randinit_set (gmp_randstate_t ROP,
-          gmp_randstate_t OP)
-     Initialize ROP with a copy of the algorithm and state from OP.
-
- -- Function: void gmp_randinit (gmp_randstate_t STATE,
-          gmp_randalg_t ALG, ...)
-     *This function is obsolete.*
-
-     Initialize STATE with an algorithm selected by ALG.  The only
-     choice is `GMP_RAND_ALG_LC', which is `gmp_randinit_lc_2exp_size'
-     described above.  A third parameter of type `unsigned long' is
-     required, this is the SIZE for that function.
-     `GMP_RAND_ALG_DEFAULT' or 0 are the same as `GMP_RAND_ALG_LC'.
-
-     `gmp_randinit' sets bits in the global variable `gmp_errno' to
-     indicate an error.  `GMP_ERROR_UNSUPPORTED_ARGUMENT' if ALG is
-     unsupported, or `GMP_ERROR_INVALID_ARGUMENT' if the SIZE parameter
-     is too big.  It may be noted this error reporting is not thread
-     safe (a good reason to use `gmp_randinit_lc_2exp_size' instead).
-
- -- Function: void gmp_randclear (gmp_randstate_t STATE)
-     Free all memory occupied by STATE.
-
-
-File: gmp.info,  Node: Random State Seeding,  Next: Random State Miscellaneous,  Prev: Random State Initialization,  Up: Random Number Functions
-
-9.2 Random State Seeding
-========================
-
- -- Function: void gmp_randseed (gmp_randstate_t STATE, mpz_t SEED)
- -- Function: void gmp_randseed_ui (gmp_randstate_t STATE,
-          unsigned long int SEED)
-     Set an initial seed value into STATE.
-
-     The size of a seed determines how many different sequences of
-     random numbers that it's possible to generate.  The "quality" of
-     the seed is the randomness of a given seed compared to the
-     previous seed used, and this affects the randomness of separate
-     number sequences.  The method for choosing a seed is critical if
-     the generated numbers are to be used for important applications,
-     such as generating cryptographic keys.
-
-     Traditionally the system time has been used to seed, but care
-     needs to be taken with this.  If an application seeds often and
-     the resolution of the system clock is low, then the same sequence
-     of numbers might be repeated.  Also, the system time is quite easy
-     to guess, so if unpredictability is required then it should
-     definitely not be the only source for the seed value.  On some
-     systems there's a special device `/dev/random' which provides
-     random data better suited for use as a seed.
-
-
-File: gmp.info,  Node: Random State Miscellaneous,  Prev: Random State Seeding,  Up: Random Number Functions
-
-9.3 Random State Miscellaneous
-==============================
-
- -- Function: unsigned long gmp_urandomb_ui (gmp_randstate_t STATE,
-          unsigned long N)
-     Return a uniformly distributed random number of N bits, ie. in the
-     range 0 to 2^N-1 inclusive.  N must be less than or equal to the
-     number of bits in an `unsigned long'.
-
- -- Function: unsigned long gmp_urandomm_ui (gmp_randstate_t STATE,
-          unsigned long N)
-     Return a uniformly distributed random number in the range 0 to
-     N-1, inclusive.
-
-
-File: gmp.info,  Node: Formatted Output,  Next: Formatted Input,  Prev: Random Number Functions,  Up: Top
-
-10 Formatted Output
-*******************
-
-* Menu:
-
-* Formatted Output Strings::
-* Formatted Output Functions::
-* C++ Formatted Output::
-
-
-File: gmp.info,  Node: Formatted Output Strings,  Next: Formatted Output Functions,  Prev: Formatted Output,  Up: Formatted Output
-
-10.1 Format Strings
-===================
-
-`gmp_printf' and friends accept format strings similar to the standard C
-`printf' (*note Formatted Output: (libc)Formatted Output.).  A format
-specification is of the form
-
-     % [flags] [width] [.[precision]] [type] conv
-
-   GMP adds types `Z', `Q' and `F' for `mpz_t', `mpq_t' and `mpf_t'
-respectively, `M' for `mp_limb_t', and `N' for an `mp_limb_t' array.
-`Z', `Q', `M' and `N' behave like integers.  `Q' will print a `/' and a
-denominator, if needed.  `F' behaves like a float.  For example,
-
-     mpz_t z;
-     gmp_printf ("%s is an mpz %Zd\n", "here", z);
-
-     mpq_t q;
-     gmp_printf ("a hex rational: %#40Qx\n", q);
-
-     mpf_t f;
-     int   n;
-     gmp_printf ("fixed point mpf %.*Ff with %d digits\n", n, f, n);
-
-     mp_limb_t l;
-     gmp_printf ("limb %Mu\n", l);
-
-     const mp_limb_t *ptr;
-     mp_size_t       size;
-     gmp_printf ("limb array %Nx\n", ptr, size);
-
-   For `N' the limbs are expected least significant first, as per the
-`mpn' functions (*note Low-level Functions::).  A negative size can be
-given to print the value as a negative.
-
-   All the standard C `printf' types behave the same as the C library
-`printf', and can be freely intermixed with the GMP extensions.  In the
-current implementation the standard parts of the format string are
-simply handed to `printf' and only the GMP extensions handled directly.
-
-   The flags accepted are as follows.  GLIBC style ' is only for the
-standard C types (not the GMP types), and only if the C library
-supports it.
-
-     0         pad with zeros (rather than spaces)
-     #         show the base with `0x', `0X' or `0'
-     +         always show a sign
-     (space)   show a space or a `-' sign
-     '         group digits, GLIBC style (not GMP types)
-
-   The optional width and precision can be given as a number within the
-format string, or as a `*' to take an extra parameter of type `int', the
-same as the standard `printf'.
-
-   The standard types accepted are as follows.  `h' and `l' are
-portable, the rest will depend on the compiler (or include files) for
-the type and the C library for the output.
-
-     h         short
-     hh        char
-     j         intmax_t or uintmax_t
-     l         long or wchar_t
-     ll        long long
-     L         long double
-     q         quad_t or u_quad_t
-     t         ptrdiff_t
-     z         size_t
-
-The GMP types are
-
-     F         mpf_t, float conversions
-     Q         mpq_t, integer conversions
-     M         mp_limb_t, integer conversions
-     N         mp_limb_t array, integer conversions
-     Z         mpz_t, integer conversions
-
-   The conversions accepted are as follows.  `a' and `A' are always
-supported for `mpf_t' but depend on the C library for standard C float
-types.  `m' and `p' depend on the C library.
-
-     a A       hex floats, C99 style
-     c         character
-     d         decimal integer
-     e E       scientific format float
-     f         fixed point float
-     i         same as d
-     g G       fixed or scientific float
-     m         `strerror' string, GLIBC style
-     n         store characters written so far
-     o         octal integer
-     p         pointer
-     s         string
-     u         unsigned integer
-     x X       hex integer
-
-   `o', `x' and `X' are unsigned for the standard C types, but for
-types `Z', `Q' and `N' they are signed.  `u' is not meaningful for `Z',
-`Q' and `N'.
-
-   `M' is a proxy for the C library `l' or `L', according to the size
-of `mp_limb_t'.  Unsigned conversions will be usual, but a signed
-conversion can be used and will interpret the value as a twos complement
-negative.
-
-   `n' can be used with any type, even the GMP types.
-
-   Other types or conversions that might be accepted by the C library
-`printf' cannot be used through `gmp_printf', this includes for
-instance extensions registered with GLIBC `register_printf_function'.
-Also currently there's no support for POSIX `$' style numbered arguments
-(perhaps this will be added in the future).
-
-   The precision field has it's usual meaning for integer `Z' and float
-`F' types, but is currently undefined for `Q' and should not be used
-with that.
-
-   `mpf_t' conversions only ever generate as many digits as can be
-accurately represented by the operand, the same as `mpf_get_str' does.
-Zeros will be used if necessary to pad to the requested precision.  This
-happens even for an `f' conversion of an `mpf_t' which is an integer,
-for instance 2^1024 in an `mpf_t' of 128 bits precision will only
-produce about 40 digits, then pad with zeros to the decimal point.  An
-empty precision field like `%.Fe' or `%.Ff' can be used to specifically
-request just the significant digits.
-
-   The decimal point character (or string) is taken from the current
-locale settings on systems which provide `localeconv' (*note Locales
-and Internationalization: (libc)Locales.).  The C library will normally
-do the same for standard float output.
-
-   The format string is only interpreted as plain `char's, multibyte
-characters are not recognised.  Perhaps this will change in the future.
-
-
-File: gmp.info,  Node: Formatted Output Functions,  Next: C++ Formatted Output,  Prev: Formatted Output Strings,  Up: Formatted Output
-
-10.2 Functions
-==============
-
-Each of the following functions is similar to the corresponding C
-library function.  The basic `printf' forms take a variable argument
-list.  The `vprintf' forms take an argument pointer, see *Note Variadic
-Functions: (libc)Variadic Functions, or `man 3 va_start'.
-
-   It should be emphasised that if a format string is invalid, or the
-arguments don't match what the format specifies, then the behaviour of
-any of these functions will be unpredictable.  GCC format string
-checking is not available, since it doesn't recognise the GMP
-extensions.
-
-   The file based functions `gmp_printf' and `gmp_fprintf' will return
--1 to indicate a write error.  Output is not "atomic", so partial
-output may be produced if a write error occurs.  All the functions can
-return -1 if the C library `printf' variant in use returns -1, but this
-shouldn't normally occur.
-
- -- Function: int gmp_printf (const char *FMT, ...)
- -- Function: int gmp_vprintf (const char *FMT, va_list AP)
-     Print to the standard output `stdout'.  Return the number of
-     characters written, or -1 if an error occurred.
-
- -- Function: int gmp_fprintf (FILE *FP, const char *FMT, ...)
- -- Function: int gmp_vfprintf (FILE *FP, const char *FMT, va_list AP)
-     Print to the stream FP.  Return the number of characters written,
-     or -1 if an error occurred.
-
- -- Function: int gmp_sprintf (char *BUF, const char *FMT, ...)
- -- Function: int gmp_vsprintf (char *BUF, const char *FMT, va_list AP)
-     Form a null-terminated string in BUF.  Return the number of
-     characters written, excluding the terminating null.
-
-     No overlap is permitted between the space at BUF and the string
-     FMT.
-
-     These functions are not recommended, since there's no protection
-     against exceeding the space available at BUF.
-
- -- Function: int gmp_snprintf (char *BUF, size_t SIZE, const char
-          *FMT, ...)
- -- Function: int gmp_vsnprintf (char *BUF, size_t SIZE, const char
-          *FMT, va_list AP)
-     Form a null-terminated string in BUF.  No more than SIZE bytes
-     will be written.  To get the full output, SIZE must be enough for
-     the string and null-terminator.
-
-     The return value is the total number of characters which ought to
-     have been produced, excluding the terminating null.  If RETVAL >=
-     SIZE then the actual output has been truncated to the first SIZE-1
-     characters, and a null appended.
-
-     No overlap is permitted between the region {BUF,SIZE} and the FMT
-     string.
-
-     Notice the return value is in ISO C99 `snprintf' style.  This is
-     so even if the C library `vsnprintf' is the older GLIBC 2.0.x
-     style.
-
- -- Function: int gmp_asprintf (char **PP, const char *FMT, ...)
- -- Function: int gmp_vasprintf (char **PP, const char *FMT, va_list AP)
-     Form a null-terminated string in a block of memory obtained from
-     the current memory allocation function (*note Custom
-     Allocation::).  The block will be the size of the string and
-     null-terminator.  The address of the block in stored to *PP.  The
-     return value is the number of characters produced, excluding the
-     null-terminator.
-
-     Unlike the C library `asprintf', `gmp_asprintf' doesn't return -1
-     if there's no more memory available, it lets the current allocation
-     function handle that.
-
- -- Function: int gmp_obstack_printf (struct obstack *OB, const char
-          *FMT, ...)
- -- Function: int gmp_obstack_vprintf (struct obstack *OB, const char
-          *FMT, va_list AP)
-     Append to the current object in OB.  The return value is the
-     number of characters written.  A null-terminator is not written.
-
-     FMT cannot be within the current object in OB, since that object
-     might move as it grows.
-
-     These functions are available only when the C library provides the
-     obstack feature, which probably means only on GNU systems, see
-     *Note Obstacks: (libc)Obstacks.
-
-
-File: gmp.info,  Node: C++ Formatted Output,  Prev: Formatted Output Functions,  Up: Formatted Output
-
-10.3 C++ Formatted Output
-=========================
-
-The following functions are provided in `libgmpxx' (*note Headers and
-Libraries::), which is built if C++ support is enabled (*note Build
-Options::).  Prototypes are available from `<gmp.h>'.
-
- -- Function: ostream& operator<< (ostream& STREAM, mpz_t OP)
-     Print OP to STREAM, using its `ios' formatting settings.
-     `ios::width' is reset to 0 after output, the same as the standard
-     `ostream operator<<' routines do.
-
-     In hex or octal, OP is printed as a signed number, the same as for
-     decimal.  This is unlike the standard `operator<<' routines on
-     `int' etc, which instead give twos complement.
-
- -- Function: ostream& operator<< (ostream& STREAM, mpq_t OP)
-     Print OP to STREAM, using its `ios' formatting settings.
-     `ios::width' is reset to 0 after output, the same as the standard
-     `ostream operator<<' routines do.
-
-     Output will be a fraction like `5/9', or if the denominator is 1
-     then just a plain integer like `123'.
-
-     In hex or octal, OP is printed as a signed value, the same as for
-     decimal.  If `ios::showbase' is set then a base indicator is shown
-     on both the numerator and denominator (if the denominator is
-     required).
-
- -- Function: ostream& operator<< (ostream& STREAM, mpf_t OP)
-     Print OP to STREAM, using its `ios' formatting settings.
-     `ios::width' is reset to 0 after output, the same as the standard
-     `ostream operator<<' routines do.
-
-     The decimal point follows the standard library float `operator<<',
-     which on recent systems means the `std::locale' imbued on STREAM.
-
-     Hex and octal are supported, unlike the standard `operator<<' on
-     `double'.  The mantissa will be in hex or octal, the exponent will
-     be in decimal.  For hex the exponent delimiter is an `@'.  This is
-     as per `mpf_out_str'.
-
-     `ios::showbase' is supported, and will put a base on the mantissa,
-     for example hex `0x1.8' or `0x0.8', or octal `01.4' or `00.4'.
-     This last form is slightly strange, but at least differentiates
-     itself from decimal.
-
-   These operators mean that GMP types can be printed in the usual C++
-way, for example,
-
-     mpz_t  z;
-     int    n;
-     ...
-     cout << "iteration " << n << " value " << z << "\n";
-
-   But note that `ostream' output (and `istream' input, *note C++
-Formatted Input::) is the only overloading available for the GMP types
-and that for instance using `+' with an `mpz_t' will have unpredictable
-results.  For classes with overloading, see *Note C++ Class Interface::.
-
-
-File: gmp.info,  Node: Formatted Input,  Next: C++ Class Interface,  Prev: Formatted Output,  Up: Top
-
-11 Formatted Input
-******************
-
-* Menu:
-
-* Formatted Input Strings::
-* Formatted Input Functions::
-* C++ Formatted Input::
-
-
-File: gmp.info,  Node: Formatted Input Strings,  Next: Formatted Input Functions,  Prev: Formatted Input,  Up: Formatted Input
-
-11.1 Formatted Input Strings
-============================
-
-`gmp_scanf' and friends accept format strings similar to the standard C
-`scanf' (*note Formatted Input: (libc)Formatted Input.).  A format
-specification is of the form
-
-     % [flags] [width] [type] conv
-
-   GMP adds types `Z', `Q' and `F' for `mpz_t', `mpq_t' and `mpf_t'
-respectively.  `Z' and `Q' behave like integers.  `Q' will read a `/'
-and a denominator, if present.  `F' behaves like a float.
-
-   GMP variables don't require an `&' when passed to `gmp_scanf', since
-they're already "call-by-reference".  For example,
-
-     /* to read say "a(5) = 1234" */
-     int   n;
-     mpz_t z;
-     gmp_scanf ("a(%d) = %Zd\n", &n, z);
-
-     mpq_t q1, q2;
-     gmp_sscanf ("0377 + 0x10/0x11", "%Qi + %Qi", q1, q2);
-
-     /* to read say "topleft (1.55,-2.66)" */
-     mpf_t x, y;
-     char  buf[32];
-     gmp_scanf ("%31s (%Ff,%Ff)", buf, x, y);
-
-   All the standard C `scanf' types behave the same as in the C library
-`scanf', and can be freely intermixed with the GMP extensions.  In the
-current implementation the standard parts of the format string are
-simply handed to `scanf' and only the GMP extensions handled directly.
-
-   The flags accepted are as follows.  `a' and `'' will depend on
-support from the C library, and `'' cannot be used with GMP types.
-
-     *         read but don't store
-     a         allocate a buffer (string conversions)
-     '         grouped digits, GLIBC style (not GMP
-               types)
-
-   The standard types accepted are as follows.  `h' and `l' are
-portable, the rest will depend on the compiler (or include files) for
-the type and the C library for the input.
-
-     h         short
-     hh        char
-     j         intmax_t or uintmax_t
-     l         long int, double or wchar_t
-     ll        long long
-     L         long double
-     q         quad_t or u_quad_t
-     t         ptrdiff_t
-     z         size_t
-
-The GMP types are
-
-     F         mpf_t, float conversions
-     Q         mpq_t, integer conversions
-     Z         mpz_t, integer conversions
-
-   The conversions accepted are as follows.  `p' and `[' will depend on
-support from the C library, the rest are standard.
-
-     c         character or characters
-     d         decimal integer
-     e E f g G float
-     i         integer with base indicator
-     n         characters read so far
-     o         octal integer
-     p         pointer
-     s         string of non-whitespace characters
-     u         decimal integer
-     x X       hex integer
-     [         string of characters in a set
-
-   `e', `E', `f', `g' and `G' are identical, they all read either fixed
-point or scientific format, and either upper or lower case `e' for the
-exponent in scientific format.
-
-   C99 style hex float format (`printf %a', *note Formatted Output
-Strings::) is always accepted for `mpf_t', but for the standard float
-types it will depend on the C library.
-
-   `x' and `X' are identical, both accept both upper and lower case
-hexadecimal.
-
-   `o', `u', `x' and `X' all read positive or negative values.  For the
-standard C types these are described as "unsigned" conversions, but
-that merely affects certain overflow handling, negatives are still
-allowed (per `strtoul', *note Parsing of Integers: (libc)Parsing of
-Integers.).  For GMP types there are no overflows, so `d' and `u' are
-identical.
-
-   `Q' type reads the numerator and (optional) denominator as given.
-If the value might not be in canonical form then `mpq_canonicalize'
-must be called before using it in any calculations (*note Rational
-Number Functions::).
-
-   `Qi' will read a base specification separately for the numerator and
-denominator.  For example `0x10/11' would be 16/11, whereas `0x10/0x11'
-would be 16/17.
-
-   `n' can be used with any of the types above, even the GMP types.
-`*' to suppress assignment is allowed, though in that case it would do
-nothing at all.
-
-   Other conversions or types that might be accepted by the C library
-`scanf' cannot be used through `gmp_scanf'.
-
-   Whitespace is read and discarded before a field, except for `c' and
-`[' conversions.
-
-   For float conversions, the decimal point character (or string)
-expected is taken from the current locale settings on systems which
-provide `localeconv' (*note Locales and Internationalization:
-(libc)Locales.).  The C library will normally do the same for standard
-float input.
-
-   The format string is only interpreted as plain `char's, multibyte
-characters are not recognised.  Perhaps this will change in the future.
-
-
-File: gmp.info,  Node: Formatted Input Functions,  Next: C++ Formatted Input,  Prev: Formatted Input Strings,  Up: Formatted Input
-
-11.2 Formatted Input Functions
-==============================
-
-Each of the following functions is similar to the corresponding C
-library function.  The plain `scanf' forms take a variable argument
-list.  The `vscanf' forms take an argument pointer, see *Note Variadic
-Functions: (libc)Variadic Functions, or `man 3 va_start'.
-
-   It should be emphasised that if a format string is invalid, or the
-arguments don't match what the format specifies, then the behaviour of
-any of these functions will be unpredictable.  GCC format string
-checking is not available, since it doesn't recognise the GMP
-extensions.
-
-   No overlap is permitted between the FMT string and any of the results
-produced.
-
- -- Function: int gmp_scanf (const char *FMT, ...)
- -- Function: int gmp_vscanf (const char *FMT, va_list AP)
-     Read from the standard input `stdin'.
-
- -- Function: int gmp_fscanf (FILE *FP, const char *FMT, ...)
- -- Function: int gmp_vfscanf (FILE *FP, const char *FMT, va_list AP)
-     Read from the stream FP.
-
- -- Function: int gmp_sscanf (const char *S, const char *FMT, ...)
- -- Function: int gmp_vsscanf (const char *S, const char *FMT, va_list
-          AP)
-     Read from a null-terminated string S.
-
-   The return value from each of these functions is the same as the
-standard C99 `scanf', namely the number of fields successfully parsed
-and stored.  `%n' fields and fields read but suppressed by `*' don't
-count towards the return value.
-
-   If end of input (or a file error) is reached before a character for
-a field or a literal, and if no previous non-suppressed fields have
-matched, then the return value is `EOF' instead of 0.  A whitespace
-character in the format string is only an optional match and doesn't
-induce an `EOF' in this fashion.  Leading whitespace read and discarded
-for a field don't count as characters for that field.
-
-   For the GMP types, input parsing follows C99 rules, namely one
-character of lookahead is used and characters are read while they
-continue to meet the format requirements.  If this doesn't provide a
-complete number then the function terminates, with that field not
-stored nor counted towards the return value.  For instance with `mpf_t'
-an input `1.23e-XYZ' would be read up to the `X' and that character
-pushed back since it's not a digit.  The string `1.23e-' would then be
-considered invalid since an `e' must be followed by at least one digit.
-
-   For the standard C types, in the current implementation GMP calls
-the C library `scanf' functions, which might have looser rules about
-what constitutes a valid input.
-
-   Note that `gmp_sscanf' is the same as `gmp_fscanf' and only does one
-character of lookahead when parsing.  Although clearly it could look at
-its entire input, it is deliberately made identical to `gmp_fscanf',
-the same way C99 `sscanf' is the same as `fscanf'.
-
-
-File: gmp.info,  Node: C++ Formatted Input,  Prev: Formatted Input Functions,  Up: Formatted Input
-
-11.3 C++ Formatted Input
-========================
-
-The following functions are provided in `libgmpxx' (*note Headers and
-Libraries::), which is built only if C++ support is enabled (*note
-Build Options::).  Prototypes are available from `<gmp.h>'.
-
- -- Function: istream& operator>> (istream& STREAM, mpz_t ROP)
-     Read ROP from STREAM, using its `ios' formatting settings.
-
- -- Function: istream& operator>> (istream& STREAM, mpq_t ROP)
-     An integer like `123' will be read, or a fraction like `5/9'.  No
-     whitespace is allowed around the `/'.  If the fraction is not in
-     canonical form then `mpq_canonicalize' must be called (*note
-     Rational Number Functions::) before operating on it.
-
-     As per integer input, an `0' or `0x' base indicator is read when
-     none of `ios::dec', `ios::oct' or `ios::hex' are set.  This is
-     done separately for numerator and denominator, so that for instance
-     `0x10/11' is 16/11 and `0x10/0x11' is 16/17.
-
- -- Function: istream& operator>> (istream& STREAM, mpf_t ROP)
-     Read ROP from STREAM, using its `ios' formatting settings.
-
-     Hex or octal floats are not supported, but might be in the future,
-     or perhaps it's best to accept only what the standard float
-     `operator>>' does.
-
-   Note that digit grouping specified by the `istream' locale is
-currently not accepted.  Perhaps this will change in the future.
-
-
-   These operators mean that GMP types can be read in the usual C++
-way, for example,
-
-     mpz_t  z;
-     ...
-     cin >> z;
-
-   But note that `istream' input (and `ostream' output, *note C++
-Formatted Output::) is the only overloading available for the GMP types
-and that for instance using `+' with an `mpz_t' will have unpredictable
-results.  For classes with overloading, see *Note C++ Class Interface::.
-
-
-File: gmp.info,  Node: C++ Class Interface,  Next: BSD Compatible Functions,  Prev: Formatted Input,  Up: Top
-
-12 C++ Class Interface
-**********************
-
-This chapter describes the C++ class based interface to GMP.
-
-   All GMP C language types and functions can be used in C++ programs,
-since `gmp.h' has `extern "C"' qualifiers, but the class interface
-offers overloaded functions and operators which may be more convenient.
-
-   Due to the implementation of this interface, a reasonably recent C++
-compiler is required, one supporting namespaces, partial specialization
-of templates and member templates.  For GCC this means version 2.91 or
-later.
-
-   *Everything described in this chapter is to be considered preliminary
-and might be subject to incompatible changes if some unforeseen
-difficulty reveals itself.*
-
-* Menu:
-
-* C++ Interface General::
-* C++ Interface Integers::
-* C++ Interface Rationals::
-* C++ Interface Floats::
-* C++ Interface Random Numbers::
-* C++ Interface Limitations::
-
-
-File: gmp.info,  Node: C++ Interface General,  Next: C++ Interface Integers,  Prev: C++ Class Interface,  Up: C++ Class Interface
-
-12.1 C++ Interface General
-==========================
-
-All the C++ classes and functions are available with
-
-     #include <gmpxx.h>
-
-   Programs should be linked with the `libgmpxx' and `libgmp'
-libraries.  For example,
-
-     g++ mycxxprog.cc -lgmpxx -lgmp
-
-The classes defined are
-
- -- Class: mpz_class
- -- Class: mpq_class
- -- Class: mpf_class
-
-   The standard operators and various standard functions are overloaded
-to allow arithmetic with these classes.  For example,
-
-     int
-     main (void)
-     {
-       mpz_class a, b, c;
-
-       a = 1234;
-       b = "-5678";
-       c = a+b;
-       cout << "sum is " << c << "\n";
-       cout << "absolute value is " << abs(c) << "\n";
-
-       return 0;
-     }
-
-   An important feature of the implementation is that an expression like
-`a=b+c' results in a single call to the corresponding `mpz_add',
-without using a temporary for the `b+c' part.  Expressions which by
-their nature imply intermediate values, like `a=b*c+d*e', still use
-temporaries though.
-
-   The classes can be freely intermixed in expressions, as can the
-classes and the standard types `long', `unsigned long' and `double'.
-Smaller types like `int' or `float' can also be intermixed, since C++
-will promote them.
-
-   Note that `bool' is not accepted directly, but must be explicitly
-cast to an `int' first.  This is because C++ will automatically convert
-any pointer to a `bool', so if GMP accepted `bool' it would make all
-sorts of invalid class and pointer combinations compile but almost
-certainly not do anything sensible.
-
-   Conversions back from the classes to standard C++ types aren't done
-automatically, instead member functions like `get_si' are provided (see
-the following sections for details).
-
-   Also there are no automatic conversions from the classes to the
-corresponding GMP C types, instead a reference to the underlying C
-object can be obtained with the following functions,
-
- -- Function: mpz_t mpz_class::get_mpz_t ()
- -- Function: mpq_t mpq_class::get_mpq_t ()
- -- Function: mpf_t mpf_class::get_mpf_t ()
-
-   These can be used to call a C function which doesn't have a C++ class
-interface.  For example to set `a' to the GCD of `b' and `c',
-
-     mpz_class a, b, c;
-     ...
-     mpz_gcd (a.get_mpz_t(), b.get_mpz_t(), c.get_mpz_t());
-
-   In the other direction, a class can be initialized from the
-corresponding GMP C type, or assigned to if an explicit constructor is
-used.  In both cases this makes a copy of the value, it doesn't create
-any sort of association.  For example,
-
-     mpz_t z;
-     // ... init and calculate z ...
-     mpz_class x(z);
-     mpz_class y;
-     y = mpz_class (z);
-
-   There are no namespace setups in `gmpxx.h', all types and functions
-are simply put into the global namespace.  This is what `gmp.h' has
-done in the past, and continues to do for compatibility.  The extras
-provided by `gmpxx.h' follow GMP naming conventions and are unlikely to
-clash with anything.
-
-
-File: gmp.info,  Node: C++ Interface Integers,  Next: C++ Interface Rationals,  Prev: C++ Interface General,  Up: C++ Class Interface
-
-12.2 C++ Interface Integers
-===========================
-
- -- Function:  mpz_class::mpz_class (type N)
-     Construct an `mpz_class'.  All the standard C++ types may be used,
-     except `long long' and `long double', and all the GMP C++ classes
-     can be used.  Any necessary conversion follows the corresponding C
-     function, for example `double' follows `mpz_set_d' (*note
-     Assigning Integers::).
-
- -- Function: explicit mpz_class::mpz_class (mpz_t Z)
-     Construct an `mpz_class' from an `mpz_t'.  The value in Z is
-     copied into the new `mpz_class', there won't be any permanent
-     association between it and Z.
-
- -- Function: explicit mpz_class::mpz_class (const char *S, int BASE =
-          0)
- -- Function: explicit mpz_class::mpz_class (const string& S, int BASE
-          = 0)
-     Construct an `mpz_class' converted from a string using
-     `mpz_set_str' (*note Assigning Integers::).
-
-     If the string is not a valid integer, an `std::invalid_argument'
-     exception is thrown.  The same applies to `operator='.
-
- -- Function: mpz_class operator/ (mpz_class A, mpz_class D)
- -- Function: mpz_class operator% (mpz_class A, mpz_class D)
-     Divisions involving `mpz_class' round towards zero, as per the
-     `mpz_tdiv_q' and `mpz_tdiv_r' functions (*note Integer Division::).
-     This is the same as the C99 `/' and `%' operators.
-
-     The `mpz_fdiv...' or `mpz_cdiv...' functions can always be called
-     directly if desired.  For example,
-
-          mpz_class q, a, d;
-          ...
-          mpz_fdiv_q (q.get_mpz_t(), a.get_mpz_t(), d.get_mpz_t());
-
- -- Function: mpz_class abs (mpz_class OP1)
- -- Function: int cmp (mpz_class OP1, type OP2)
- -- Function: int cmp (type OP1, mpz_class OP2)
- -- Function: bool mpz_class::fits_sint_p (void)
- -- Function: bool mpz_class::fits_slong_p (void)
- -- Function: bool mpz_class::fits_sshort_p (void)
- -- Function: bool mpz_class::fits_uint_p (void)
- -- Function: bool mpz_class::fits_ulong_p (void)
- -- Function: bool mpz_class::fits_ushort_p (void)
- -- Function: double mpz_class::get_d (void)
- -- Function: long mpz_class::get_si (void)
- -- Function: string mpz_class::get_str (int BASE = 10)
- -- Function: unsigned long mpz_class::get_ui (void)
- -- Function: int mpz_class::set_str (const char *STR, int BASE)
- -- Function: int mpz_class::set_str (const string& STR, int BASE)
- -- Function: int sgn (mpz_class OP)
- -- Function: mpz_class sqrt (mpz_class OP)
-     These functions provide a C++ class interface to the corresponding
-     GMP C routines.
-
-     `cmp' can be used with any of the classes or the standard C++
-     types, except `long long' and `long double'.
-
-
-   Overloaded operators for combinations of `mpz_class' and `double'
-are provided for completeness, but it should be noted that if the given
-`double' is not an integer then the way any rounding is done is
-currently unspecified.  The rounding might take place at the start, in
-the middle, or at the end of the operation, and it might change in the
-future.
-
-   Conversions between `mpz_class' and `double', however, are defined
-to follow the corresponding C functions `mpz_get_d' and `mpz_set_d'.
-And comparisons are always made exactly, as per `mpz_cmp_d'.
-
-
-File: gmp.info,  Node: C++ Interface Rationals,  Next: C++ Interface Floats,  Prev: C++ Interface Integers,  Up: C++ Class Interface
-
-12.3 C++ Interface Rationals
-============================
-
-In all the following constructors, if a fraction is given then it
-should be in canonical form, or if not then `mpq_class::canonicalize'
-called.
-
- -- Function:  mpq_class::mpq_class (type OP)
- -- Function:  mpq_class::mpq_class (integer NUM, integer DEN)
-     Construct an `mpq_class'.  The initial value can be a single value
-     of any type, or a pair of integers (`mpz_class' or standard C++
-     integer types) representing a fraction, except that `long long'
-     and `long double' are not supported.  For example,
-
-          mpq_class q (99);
-          mpq_class q (1.75);
-          mpq_class q (1, 3);
-
- -- Function: explicit mpq_class::mpq_class (mpq_t Q)
-     Construct an `mpq_class' from an `mpq_t'.  The value in Q is
-     copied into the new `mpq_class', there won't be any permanent
-     association between it and Q.
-
- -- Function: explicit mpq_class::mpq_class (const char *S, int BASE =
-          0)
- -- Function: explicit mpq_class::mpq_class (const string& S, int BASE
-          = 0)
-     Construct an `mpq_class' converted from a string using
-     `mpq_set_str' (*note Initializing Rationals::).
-
-     If the string is not a valid rational, an `std::invalid_argument'
-     exception is thrown.  The same applies to `operator='.
-
- -- Function: void mpq_class::canonicalize ()
-     Put an `mpq_class' into canonical form, as per *Note Rational
-     Number Functions::.  All arithmetic operators require their
-     operands in canonical form, and will return results in canonical
-     form.
-
- -- Function: mpq_class abs (mpq_class OP)
- -- Function: int cmp (mpq_class OP1, type OP2)
- -- Function: int cmp (type OP1, mpq_class OP2)
- -- Function: double mpq_class::get_d (void)
- -- Function: string mpq_class::get_str (int BASE = 10)
- -- Function: int mpq_class::set_str (const char *STR, int BASE)
- -- Function: int mpq_class::set_str (const string& STR, int BASE)
- -- Function: int sgn (mpq_class OP)
-     These functions provide a C++ class interface to the corresponding
-     GMP C routines.
-
-     `cmp' can be used with any of the classes or the standard C++
-     types, except `long long' and `long double'.
-
- -- Function: mpz_class& mpq_class::get_num ()
- -- Function: mpz_class& mpq_class::get_den ()
-     Get a reference to an `mpz_class' which is the numerator or
-     denominator of an `mpq_class'.  This can be used both for read and
-     write access.  If the object returned is modified, it modifies the
-     original `mpq_class'.
-
-     If direct manipulation might produce a non-canonical value, then
-     `mpq_class::canonicalize' must be called before further operations.
-
- -- Function: mpz_t mpq_class::get_num_mpz_t ()
- -- Function: mpz_t mpq_class::get_den_mpz_t ()
-     Get a reference to the underlying `mpz_t' numerator or denominator
-     of an `mpq_class'.  This can be passed to C functions expecting an
-     `mpz_t'.  Any modifications made to the `mpz_t' will modify the
-     original `mpq_class'.
-
-     If direct manipulation might produce a non-canonical value, then
-     `mpq_class::canonicalize' must be called before further operations.
-
- -- Function: istream& operator>> (istream& STREAM, mpq_class& ROP);
-     Read ROP from STREAM, using its `ios' formatting settings, the
-     same as `mpq_t operator>>' (*note C++ Formatted Input::).
-
-     If the ROP read might not be in canonical form then
-     `mpq_class::canonicalize' must be called.
-
-
-File: gmp.info,  Node: C++ Interface Floats,  Next: C++ Interface Random Numbers,  Prev: C++ Interface Rationals,  Up: C++ Class Interface
-
-12.4 C++ Interface Floats
-=========================
-
-When an expression requires the use of temporary intermediate
-`mpf_class' values, like `f=g*h+x*y', those temporaries will have the
-same precision as the destination `f'.  Explicit constructors can be
-used if this doesn't suit.
-
- -- Function:  mpf_class::mpf_class (type OP)
- -- Function:  mpf_class::mpf_class (type OP, unsigned long PREC)
-     Construct an `mpf_class'.  Any standard C++ type can be used,
-     except `long long' and `long double', and any of the GMP C++
-     classes can be used.
-
-     If PREC is given, the initial precision is that value, in bits.  If
-     PREC is not given, then the initial precision is determined by the
-     type of OP given.  An `mpz_class', `mpq_class', or C++ builtin
-     type will give the default `mpf' precision (*note Initializing
-     Floats::).  An `mpf_class' or expression will give the precision
-     of that value.  The precision of a binary expression is the higher
-     of the two operands.
-
-          mpf_class f(1.5);        // default precision
-          mpf_class f(1.5, 500);   // 500 bits (at least)
-          mpf_class f(x);          // precision of x
-          mpf_class f(abs(x));     // precision of x
-          mpf_class f(-g, 1000);   // 1000 bits (at least)
-          mpf_class f(x+y);        // greater of precisions of x and y
-
- -- Function: explicit mpf_class::mpf_class (mpf_t F)
- -- Function:  mpf_class::mpf_class (mpf_t F, unsigned long PREC)
-     Construct an `mpf_class' from an `mpf_t'.  The value in F is
-     copied into the new `mpf_class', there won't be any permanent
-     association between it and F.
-
-     If PREC is given, the initial precision is that value, in bits.  If
-     PREC is not given, then the initial precision is that of F.
-
- -- Function: explicit mpf_class::mpf_class (const char *S)
- -- Function:  mpf_class::mpf_class (const char *S, unsigned long PREC,
-          int BASE = 0)
- -- Function: explicit mpf_class::mpf_class (const string& S)
- -- Function:  mpf_class::mpf_class (const string& S, unsigned long
-          PREC, int BASE = 0)
-     Construct an `mpf_class' converted from a string using
-     `mpf_set_str' (*note Assigning Floats::).  If PREC is given, the
-     initial precision is that value, in bits.  If not, the default
-     `mpf' precision (*note Initializing Floats::) is used.
-
-     If the string is not a valid float, an `std::invalid_argument'
-     exception is thrown.  The same applies to `operator='.
-
- -- Function: mpf_class& mpf_class::operator= (type OP)
-     Convert and store the given OP value to an `mpf_class' object.  The
-     same types are accepted as for the constructors above.
-
-     Note that `operator=' only stores a new value, it doesn't copy or
-     change the precision of the destination, instead the value is
-     truncated if necessary.  This is the same as `mpf_set' etc.  Note
-     in particular this means for `mpf_class' a copy constructor is not
-     the same as a default constructor plus assignment.
-
-          mpf_class x (y);   // x created with precision of y
-
-          mpf_class x;       // x created with default precision
-          x = y;             // value truncated to that precision
-
-     Applications using templated code may need to be careful about the
-     assumptions the code makes in this area, when working with
-     `mpf_class' values of various different or non-default precisions.
-     For instance implementations of the standard `complex' template
-     have been seen in both styles above, though of course `complex' is
-     normally only actually specified for use with the builtin float
-     types.
-
- -- Function: mpf_class abs (mpf_class OP)
- -- Function: mpf_class ceil (mpf_class OP)
- -- Function: int cmp (mpf_class OP1, type OP2)
- -- Function: int cmp (type OP1, mpf_class OP2)
- -- Function: bool mpf_class::fits_sint_p (void)
- -- Function: bool mpf_class::fits_slong_p (void)
- -- Function: bool mpf_class::fits_sshort_p (void)
- -- Function: bool mpf_class::fits_uint_p (void)
- -- Function: bool mpf_class::fits_ulong_p (void)
- -- Function: bool mpf_class::fits_ushort_p (void)
- -- Function: mpf_class floor (mpf_class OP)
- -- Function: mpf_class hypot (mpf_class OP1, mpf_class OP2)
- -- Function: double mpf_class::get_d (void)
- -- Function: long mpf_class::get_si (void)
- -- Function: string mpf_class::get_str (mp_exp_t& EXP, int BASE = 10,
-          size_t DIGITS = 0)
- -- Function: unsigned long mpf_class::get_ui (void)
- -- Function: int mpf_class::set_str (const char *STR, int BASE)
- -- Function: int mpf_class::set_str (const string& STR, int BASE)
- -- Function: int sgn (mpf_class OP)
- -- Function: mpf_class sqrt (mpf_class OP)
- -- Function: mpf_class trunc (mpf_class OP)
-     These functions provide a C++ class interface to the corresponding
-     GMP C routines.
-
-     `cmp' can be used with any of the classes or the standard C++
-     types, except `long long' and `long double'.
-
-     The accuracy provided by `hypot' is not currently guaranteed.
-
- -- Function: mp_bitcnt_t mpf_class::get_prec ()
- -- Function: void mpf_class::set_prec (mp_bitcnt_t PREC)
- -- Function: void mpf_class::set_prec_raw (mp_bitcnt_t PREC)
-     Get or set the current precision of an `mpf_class'.
-
-     The restrictions described for `mpf_set_prec_raw' (*note
-     Initializing Floats::) apply to `mpf_class::set_prec_raw'.  Note
-     in particular that the `mpf_class' must be restored to it's
-     allocated precision before being destroyed.  This must be done by
-     application code, there's no automatic mechanism for it.
-
-
-File: gmp.info,  Node: C++ Interface Random Numbers,  Next: C++ Interface Limitations,  Prev: C++ Interface Floats,  Up: C++ Class Interface
-
-12.5 C++ Interface Random Numbers
-=================================
-
- -- Class: gmp_randclass
-     The C++ class interface to the GMP random number functions uses
-     `gmp_randclass' to hold an algorithm selection and current state,
-     as per `gmp_randstate_t'.
-
- -- Function:  gmp_randclass::gmp_randclass (void (*RANDINIT)
-          (gmp_randstate_t, ...), ...)
-     Construct a `gmp_randclass', using a call to the given RANDINIT
-     function (*note Random State Initialization::).  The arguments
-     expected are the same as RANDINIT, but with `mpz_class' instead of
-     `mpz_t'.  For example,
-
-          gmp_randclass r1 (gmp_randinit_default);
-          gmp_randclass r2 (gmp_randinit_lc_2exp_size, 32);
-          gmp_randclass r3 (gmp_randinit_lc_2exp, a, c, m2exp);
-          gmp_randclass r4 (gmp_randinit_mt);
-
-     `gmp_randinit_lc_2exp_size' will fail if the size requested is too
-     big, an `std::length_error' exception is thrown in that case.
-
- -- Function:  gmp_randclass::gmp_randclass (gmp_randalg_t ALG, ...)
-     Construct a `gmp_randclass' using the same parameters as
-     `gmp_randinit' (*note Random State Initialization::).  This
-     function is obsolete and the above RANDINIT style should be
-     preferred.
-
- -- Function: void gmp_randclass::seed (unsigned long int S)
- -- Function: void gmp_randclass::seed (mpz_class S)
-     Seed a random number generator.  See *note Random Number
-     Functions::, for how to choose a good seed.
-
- -- Function: mpz_class gmp_randclass::get_z_bits (unsigned long BITS)
- -- Function: mpz_class gmp_randclass::get_z_bits (mpz_class BITS)
-     Generate a random integer with a specified number of bits.
-
- -- Function: mpz_class gmp_randclass::get_z_range (mpz_class N)
-     Generate a random integer in the range 0 to N-1 inclusive.
-
- -- Function: mpf_class gmp_randclass::get_f ()
- -- Function: mpf_class gmp_randclass::get_f (unsigned long PREC)
-     Generate a random float F in the range 0 <= F < 1.  F will be to
-     PREC bits precision, or if PREC is not given then to the precision
-     of the destination.  For example,
-
-          gmp_randclass  r;
-          ...
-          mpf_class  f (0, 512);   // 512 bits precision
-          f = r.get_f();           // random number, 512 bits
-
-
-File: gmp.info,  Node: C++ Interface Limitations,  Prev: C++ Interface Random Numbers,  Up: C++ Class Interface
-
-12.6 C++ Interface Limitations
-==============================
-
-`mpq_class' and Templated Reading
-     A generic piece of template code probably won't know that
-     `mpq_class' requires a `canonicalize' call if inputs read with
-     `operator>>' might be non-canonical.  This can lead to incorrect
-     results.
-
-     `operator>>' behaves as it does for reasons of efficiency.  A
-     canonicalize can be quite time consuming on large operands, and is
-     best avoided if it's not necessary.
-
-     But this potential difficulty reduces the usefulness of
-     `mpq_class'.  Perhaps a mechanism to tell `operator>>' what to do
-     will be adopted in the future, maybe a preprocessor define, a
-     global flag, or an `ios' flag pressed into service.  Or maybe, at
-     the risk of inconsistency, the `mpq_class' `operator>>' could
-     canonicalize and leave `mpq_t' `operator>>' not doing so, for use
-     on those occasions when that's acceptable.  Send feedback or
-     alternate ideas to <gmp-bugs@gmplib.org>.
-
-Subclassing
-     Subclassing the GMP C++ classes works, but is not currently
-     recommended.
-
-     Expressions involving subclasses resolve correctly (or seem to),
-     but in normal C++ fashion the subclass doesn't inherit
-     constructors and assignments.  There's many of those in the GMP
-     classes, and a good way to reestablish them in a subclass is not
-     yet provided.
-
-Templated Expressions
-     A subtle difficulty exists when using expressions together with
-     application-defined template functions.  Consider the following,
-     with `T' intended to be some numeric type,
-
-          template <class T>
-          T fun (const T &, const T &);
-
-     When used with, say, plain `mpz_class' variables, it works fine:
-     `T' is resolved as `mpz_class'.
-
-          mpz_class f(1), g(2);
-          fun (f, g);    // Good
-
-     But when one of the arguments is an expression, it doesn't work.
-
-          mpz_class f(1), g(2), h(3);
-          fun (f, g+h);  // Bad
-
-     This is because `g+h' ends up being a certain expression template
-     type internal to `gmpxx.h', which the C++ template resolution
-     rules are unable to automatically convert to `mpz_class'.  The
-     workaround is simply to add an explicit cast.
-
-          mpz_class f(1), g(2), h(3);
-          fun (f, mpz_class(g+h));  // Good
-
-     Similarly, within `fun' it may be necessary to cast an expression
-     to type `T' when calling a templated `fun2'.
-
-          template <class T>
-          void fun (T f, T g)
-          {
-            fun2 (f, f+g);     // Bad
-          }
-
-          template <class T>
-          void fun (T f, T g)
-          {
-            fun2 (f, T(f+g));  // Good
-          }
-
-
-File: gmp.info,  Node: BSD Compatible Functions,  Next: Custom Allocation,  Prev: C++ Class Interface,  Up: Top
-
-13 Berkeley MP Compatible Functions
-***********************************
-
-These functions are intended to be fully compatible with the Berkeley MP
-library which is available on many BSD derived U*ix systems.  The
-`--enable-mpbsd' option must be used when building GNU MP to make these
-available (*note Installing GMP::).
-
-   The original Berkeley MP library has a usage restriction: you cannot
-use the same variable as both source and destination in a single
-function call.  The compatible functions in GNU MP do not share this
-restriction--inputs and outputs may overlap.
-
-   It is not recommended that new programs are written using these
-functions.  Apart from the incomplete set of functions, the interface
-for initializing `MINT' objects is more error prone, and the `pow'
-function collides with `pow' in `libm.a'.
-
-   Include the header `mp.h' to get the definition of the necessary
-types and functions.  If you are on a BSD derived system, make sure to
-include GNU `mp.h' if you are going to link the GNU `libmp.a' to your
-program.  This means that you probably need to give the `-I<dir>'
-option to the compiler, where `<dir>' is the directory where you have
-GNU `mp.h'.
-
- -- Function: MINT * itom (signed short int INITIAL_VALUE)
-     Allocate an integer consisting of a `MINT' object and dynamic limb
-     space.  Initialize the integer to INITIAL_VALUE.  Return a pointer
-     to the `MINT' object.
-
- -- Function: MINT * xtom (char *INITIAL_VALUE)
-     Allocate an integer consisting of a `MINT' object and dynamic limb
-     space.  Initialize the integer from INITIAL_VALUE, a hexadecimal,
-     null-terminated C string.  Return a pointer to the `MINT' object.
-
- -- Function: void move (MINT *SRC, MINT *DEST)
-     Set DEST to SRC by copying.  Both variables must be previously
-     initialized.
-
- -- Function: void madd (MINT *SRC_1, MINT *SRC_2, MINT *DESTINATION)
-     Add SRC_1 and SRC_2 and put the sum in DESTINATION.
-
- -- Function: void msub (MINT *SRC_1, MINT *SRC_2, MINT *DESTINATION)
-     Subtract SRC_2 from SRC_1 and put the difference in DESTINATION.
-
- -- Function: void mult (MINT *SRC_1, MINT *SRC_2, MINT *DESTINATION)
-     Multiply SRC_1 and SRC_2 and put the product in DESTINATION.
-
- -- Function: void mdiv (MINT *DIVIDEND, MINT *DIVISOR, MINT *QUOTIENT,
-          MINT *REMAINDER)
- -- Function: void sdiv (MINT *DIVIDEND, signed short int DIVISOR, MINT
-          *QUOTIENT, signed short int *REMAINDER)
-     Set QUOTIENT to DIVIDEND/DIVISOR, and REMAINDER to DIVIDEND mod
-     DIVISOR.  The quotient is rounded towards zero; the remainder has
-     the same sign as the dividend unless it is zero.
-
-     Some implementations of these functions work differently--or not
-     at all--for negative arguments.
-
- -- Function: void msqrt (MINT *OP, MINT *ROOT, MINT *REMAINDER)
-     Set ROOT to the truncated integer part of the square root of OP,
-     like `mpz_sqrt'.  Set REMAINDER to OP-ROOT*ROOT, i.e.  zero if OP
-     is a perfect square.
-
-     If ROOT and REMAINDER are the same variable, the results are
-     undefined.
-
- -- Function: void pow (MINT *BASE, MINT *EXP, MINT *MOD, MINT *DEST)
-     Set DEST to (BASE raised to EXP) modulo MOD.
-
-     Note that the name `pow' clashes with `pow' from the standard C
-     math library (*note Exponentiation and Logarithms: (libc)Exponents
-     and Logarithms.).  An application will only be able to use one or
-     the other.
-
- -- Function: void rpow (MINT *BASE, signed short int EXP, MINT *DEST)
-     Set DEST to BASE raised to EXP.
-
- -- Function: void gcd (MINT *OP1, MINT *OP2, MINT *RES)
-     Set RES to the greatest common divisor of OP1 and OP2.
-
- -- Function: int mcmp (MINT *OP1, MINT *OP2)
-     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
-     if OP1 = OP2, and a negative value if OP1 < OP2.
-
- -- Function: void min (MINT *DEST)
-     Input a decimal string from `stdin', and put the read integer in
-     DEST.  SPC and TAB are allowed in the number string, and are
-     ignored.
-
- -- Function: void mout (MINT *SRC)
-     Output SRC to `stdout', as a decimal string.  Also output a
-     newline.
-
- -- Function: char * mtox (MINT *OP)
-     Convert OP to a hexadecimal string, and return a pointer to the
-     string.  The returned string is allocated using the default memory
-     allocation function, `malloc' by default.  It will be
-     `strlen(str)+1' bytes, that being exactly enough for the string
-     and null-terminator.
-
- -- Function: void mfree (MINT *OP)
-     De-allocate, the space used by OP.  *This function should only be
-     passed a value returned by `itom' or `xtom'.*
-
-
-File: gmp.info,  Node: Custom Allocation,  Next: Language Bindings,  Prev: BSD Compatible Functions,  Up: Top
-
-14 Custom Allocation
-********************
-
-By default GMP uses `malloc', `realloc' and `free' for memory
-allocation, and if they fail GMP prints a message to the standard error
-output and terminates the program.
-
-   Alternate functions can be specified, to allocate memory in a
-different way or to have a different error action on running out of
-memory.
-
-   This feature is available in the Berkeley compatibility library
-(*note BSD Compatible Functions::) as well as the main GMP library.
-
- -- Function: void mp_set_memory_functions (
-          void *(*ALLOC_FUNC_PTR) (size_t),
-          void *(*REALLOC_FUNC_PTR) (void *, size_t, size_t),
-          void (*FREE_FUNC_PTR) (void *, size_t))
-     Replace the current allocation functions from the arguments.  If
-     an argument is `NULL', the corresponding default function is used.
-
-     These functions will be used for all memory allocation done by
-     GMP, apart from temporary space from `alloca' if that function is
-     available and GMP is configured to use it (*note Build Options::).
-
-     *Be sure to call `mp_set_memory_functions' only when there are no
-     active GMP objects allocated using the previous memory functions!
-     Usually that means calling it before any other GMP function.*
-
-   The functions supplied should fit the following declarations:
-
- -- Function: void * allocate_function (size_t ALLOC_SIZE)
-     Return a pointer to newly allocated space with at least ALLOC_SIZE
-     bytes.
-
- -- Function: void * reallocate_function (void *PTR, size_t OLD_SIZE,
-          size_t NEW_SIZE)
-     Resize a previously allocated block PTR of OLD_SIZE bytes to be
-     NEW_SIZE bytes.
-
-     The block may be moved if necessary or if desired, and in that
-     case the smaller of OLD_SIZE and NEW_SIZE bytes must be copied to
-     the new location.  The return value is a pointer to the resized
-     block, that being the new location if moved or just PTR if not.
-
-     PTR is never `NULL', it's always a previously allocated block.
-     NEW_SIZE may be bigger or smaller than OLD_SIZE.
-
- -- Function: void free_function (void *PTR, size_t SIZE)
-     De-allocate the space pointed to by PTR.
-
-     PTR is never `NULL', it's always a previously allocated block of
-     SIZE bytes.
-
-   A "byte" here means the unit used by the `sizeof' operator.
-
-   The OLD_SIZE parameters to REALLOCATE_FUNCTION and FREE_FUNCTION are
-passed for convenience, but of course can be ignored if not needed.
-The default functions using `malloc' and friends for instance don't use
-them.
-
-   No error return is allowed from any of these functions, if they
-return then they must have performed the specified operation.  In
-particular note that ALLOCATE_FUNCTION or REALLOCATE_FUNCTION mustn't
-return `NULL'.
-
-   Getting a different fatal error action is a good use for custom
-allocation functions, for example giving a graphical dialog rather than
-the default print to `stderr'.  How much is possible when genuinely out
-of memory is another question though.
-
-   There's currently no defined way for the allocation functions to
-recover from an error such as out of memory, they must terminate
-program execution.  A `longjmp' or throwing a C++ exception will have
-undefined results.  This may change in the future.
-
-   GMP may use allocated blocks to hold pointers to other allocated
-blocks.  This will limit the assumptions a conservative garbage
-collection scheme can make.
-
-   Since the default GMP allocation uses `malloc' and friends, those
-functions will be linked in even if the first thing a program does is an
-`mp_set_memory_functions'.  It's necessary to change the GMP sources if
-this is a problem.
-
-
- -- Function: void mp_get_memory_functions (
-          void *(**ALLOC_FUNC_PTR) (size_t),
-          void *(**REALLOC_FUNC_PTR) (void *, size_t, size_t),
-          void (**FREE_FUNC_PTR) (void *, size_t))
-     Get the current allocation functions, storing function pointers to
-     the locations given by the arguments.  If an argument is `NULL',
-     that function pointer is not stored.
-
-     For example, to get just the current free function,
-
-          void (*freefunc) (void *, size_t);
-
-          mp_get_memory_functions (NULL, NULL, &freefunc);
-
-
-File: gmp.info,  Node: Language Bindings,  Next: Algorithms,  Prev: Custom Allocation,  Up: Top
-
-15 Language Bindings
-********************
-
-The following packages and projects offer access to GMP from languages
-other than C, though perhaps with varying levels of functionality and
-efficiency.
-
-
-C++
-        * GMP C++ class interface, *note C++ Class Interface::
-          Straightforward interface, expression templates to eliminate
-          temporaries.
-
-        * ALP `http://www-sop.inria.fr/saga/logiciels/ALP/'
-          Linear algebra and polynomials using templates.
-
-        * Arithmos `http://www.win.ua.ac.be/~cant/arithmos/'
-          Rationals with infinities and square roots.
-
-        * CLN `http://www.ginac.de/CLN/'
-          High level classes for arithmetic.
-
-        * LiDIA `http://www.cdc.informatik.tu-darmstadt.de/TI/LiDIA/'
-          A C++ library for computational number theory.
-
-        * Linbox `http://www.linalg.org/'
-          Sparse vectors and matrices.
-
-        * NTL `http://www.shoup.net/ntl/'
-          A C++ number theory library.
-
-Eiffel
-        * Eiffelroom `http://www.eiffelroom.org/node/442'
-
-Fortran
-        * Omni F77 `http://phase.hpcc.jp/Omni/home.html'
-          Arbitrary precision floats.
-
-Haskell
-        * Glasgow Haskell Compiler `http://www.haskell.org/ghc/'
-
-Java
-        * Kaffe `http://www.kaffe.org/'
-
-        * Kissme `http://kissme.sourceforge.net/'
-
-Lisp
-        * GNU Common Lisp `http://www.gnu.org/software/gcl/gcl.html'
-
-        * Librep `http://librep.sourceforge.net/'
-
-        * XEmacs (21.5.18 beta and up) `http://www.xemacs.org'
-          Optional big integers, rationals and floats using GMP.
-
-M4
-        * GNU m4 betas `http://www.seindal.dk/rene/gnu/'
-          Optionally provides an arbitrary precision `mpeval'.
-
-ML
-        * MLton compiler `http://mlton.org/'
-
-Objective Caml
-        * MLGMP `http://www.di.ens.fr/~monniaux/programmes.html.en'
-
-        * Numerix `http://pauillac.inria.fr/~quercia/'
-          Optionally using GMP.
-
-Oz
-        * Mozart `http://www.mozart-oz.org/'
-
-Pascal
-        * GNU Pascal Compiler `http://www.gnu-pascal.de/'
-          GMP unit.
-
-        * Numerix `http://pauillac.inria.fr/~quercia/'
-          For Free Pascal, optionally using GMP.
-
-Perl
-        * GMP module, see `demos/perl' in the GMP sources (*note
-          Demonstration Programs::).
-
-        * Math::GMP `http://www.cpan.org/'
-          Compatible with Math::BigInt, but not as many functions as
-          the GMP module above.
-
-        * Math::BigInt::GMP `http://www.cpan.org/'
-          Plug Math::GMP into normal Math::BigInt operations.
-
-Pike
-        * mpz module in the standard distribution,
-          `http://pike.ida.liu.se/'
-
-Prolog
-        * SWI Prolog `http://www.swi-prolog.org/'
-          Arbitrary precision floats.
-
-Python
-        * GMPY `http://code.google.com/p/gmpy/'
-
-Ruby
-        * http://rubygems.org/gems/gmp
-
-Scheme
-        * GNU Guile (upcoming 1.8)
-          `http://www.gnu.org/software/guile/guile.html'
-
-        * RScheme `http://www.rscheme.org/'
-
-        * STklos `http://www.stklos.org/'
-
-Smalltalk
-        * GNU Smalltalk
-          `http://www.smalltalk.org/versions/GNUSmalltalk.html'
-
-Other
-        * Axiom `http://savannah.nongnu.org/projects/axiom'
-          Computer algebra using GCL.
-
-        * DrGenius `http://drgenius.seul.org/'
-          Geometry system and mathematical programming language.
-
-        * GiNaC `http://www.ginac.de/'
-          C++ computer algebra using CLN.
-
-        * GOO `http://www.googoogaga.org/'
-          Dynamic object oriented language.
-
-        * Maxima `http://www.ma.utexas.edu/users/wfs/maxima.html'
-          Macsyma computer algebra using GCL.
-
-        * Q `http://q-lang.sourceforge.net/'
-          Equational programming system.
-
-        * Regina `http://regina.sourceforge.net/'
-          Topological calculator.
-
-        * Yacas `http://www.xs4all.nl/~apinkus/yacas.html'
-          Yet another computer algebra system.
-
-
-
-File: gmp.info,  Node: Algorithms,  Next: Internals,  Prev: Language Bindings,  Up: Top
-
-16 Algorithms
-*************
-
-This chapter is an introduction to some of the algorithms used for
-various GMP operations.  The code is likely to be hard to understand
-without knowing something about the algorithms.
-
-   Some GMP internals are mentioned, but applications that expect to be
-compatible with future GMP releases should take care to use only the
-documented functions.
-
-* Menu:
-
-* Multiplication Algorithms::
-* Division Algorithms::
-* Greatest Common Divisor Algorithms::
-* Powering Algorithms::
-* Root Extraction Algorithms::
-* Radix Conversion Algorithms::
-* Other Algorithms::
-* Assembly Coding::
-
-
-File: gmp.info,  Node: Multiplication Algorithms,  Next: Division Algorithms,  Prev: Algorithms,  Up: Algorithms
-
-16.1 Multiplication
-===================
-
-NxN limb multiplications and squares are done using one of five
-algorithms, as the size N increases.
-
-     Algorithm      Threshold
-     Basecase       (none)
-     Karatsuba      `MUL_TOOM22_THRESHOLD'
-     Toom-3         `MUL_TOOM33_THRESHOLD'
-     Toom-4         `MUL_TOOM44_THRESHOLD'
-     FFT            `MUL_FFT_THRESHOLD'
-
-   Similarly for squaring, with the `SQR' thresholds.
-
-   NxM multiplications of operands with different sizes above
-`MUL_TOOM22_THRESHOLD' are currently done by special Toom-inspired
-algorithms or directly with FFT, depending on operand size (*note
-Unbalanced Multiplication::).
-
-* Menu:
-
-* Basecase Multiplication::
-* Karatsuba Multiplication::
-* Toom 3-Way Multiplication::
-* Toom 4-Way Multiplication::
-* FFT Multiplication::
-* Other Multiplication::
-* Unbalanced Multiplication::
-
-
-File: gmp.info,  Node: Basecase Multiplication,  Next: Karatsuba Multiplication,  Prev: Multiplication Algorithms,  Up: Multiplication Algorithms
-
-16.1.1 Basecase Multiplication
-------------------------------
-
-Basecase NxM multiplication is a straightforward rectangular set of
-cross-products, the same as long multiplication done by hand and for
-that reason sometimes known as the schoolbook or grammar school method.
-This is an O(N*M) algorithm.  See Knuth section 4.3.1 algorithm M
-(*note References::), and the `mpn/generic/mul_basecase.c' code.
-
-   Assembly implementations of `mpn_mul_basecase' are essentially the
-same as the generic C code, but have all the usual assembly tricks and
-obscurities introduced for speed.
-
-   A square can be done in roughly half the time of a multiply, by
-using the fact that the cross products above and below the diagonal are
-the same.  A triangle of products below the diagonal is formed, doubled
-(left shift by one bit), and then the products on the diagonal added.
-This can be seen in `mpn/generic/sqr_basecase.c'.  Again the assembly
-implementations take essentially the same approach.
-
-          u0  u1  u2  u3  u4
-        +---+---+---+---+---+
-     u0 | d |   |   |   |   |
-        +---+---+---+---+---+
-     u1 |   | d |   |   |   |
-        +---+---+---+---+---+
-     u2 |   |   | d |   |   |
-        +---+---+---+---+---+
-     u3 |   |   |   | d |   |
-        +---+---+---+---+---+
-     u4 |   |   |   |   | d |
-        +---+---+---+---+---+
-
-   In practice squaring isn't a full 2x faster than multiplying, it's
-usually around 1.5x.  Less than 1.5x probably indicates
-`mpn_sqr_basecase' wants improving on that CPU.
-
-   On some CPUs `mpn_mul_basecase' can be faster than the generic C
-`mpn_sqr_basecase' on some small sizes.  `SQR_BASECASE_THRESHOLD' is
-the size at which to use `mpn_sqr_basecase', this will be zero if that
-routine should be used always.
-
-
-File: gmp.info,  Node: Karatsuba Multiplication,  Next: Toom 3-Way Multiplication,  Prev: Basecase Multiplication,  Up: Multiplication Algorithms
-
-16.1.2 Karatsuba Multiplication
--------------------------------
-
-The Karatsuba multiplication algorithm is described in Knuth section
-4.3.3 part A, and various other textbooks.  A brief description is
-given here.
-
-   The inputs x and y are treated as each split into two parts of equal
-length (or the most significant part one limb shorter if N is odd).
-
-      high              low
-     +----------+----------+
-     |    x1    |    x0    |
-     +----------+----------+
-
-     +----------+----------+
-     |    y1    |    y0    |
-     +----------+----------+
-
-   Let b be the power of 2 where the split occurs, ie. if x0 is k limbs
-(y0 the same) then b=2^(k*mp_bits_per_limb).  With that x=x1*b+x0 and
-y=y1*b+y0, and the following holds,
-
-     x*y = (b^2+b)*x1*y1 - b*(x1-x0)*(y1-y0) + (b+1)*x0*y0
-
-   This formula means doing only three multiplies of (N/2)x(N/2) limbs,
-whereas a basecase multiply of NxN limbs is equivalent to four
-multiplies of (N/2)x(N/2).  The factors (b^2+b) etc represent the
-positions where the three products must be added.
-
-      high                              low
-     +--------+--------+ +--------+--------+
-     |      x1*y1      | |      x0*y0      |
-     +--------+--------+ +--------+--------+
-               +--------+--------+
-           add |      x1*y1      |
-               +--------+--------+
-               +--------+--------+
-           add |      x0*y0      |
-               +--------+--------+
-               +--------+--------+
-           sub | (x1-x0)*(y1-y0) |
-               +--------+--------+
-
-   The term (x1-x0)*(y1-y0) is best calculated as an absolute value,
-and the sign used to choose to add or subtract.  Notice the sum
-high(x0*y0)+low(x1*y1) occurs twice, so it's possible to do 5*k limb
-additions, rather than 6*k, but in GMP extra function call overheads
-outweigh the saving.
-
-   Squaring is similar to multiplying, but with x=y the formula reduces
-to an equivalent with three squares,
-
-     x^2 = (b^2+b)*x1^2 - b*(x1-x0)^2 + (b+1)*x0^2
-
-   The final result is accumulated from those three squares the same
-way as for the three multiplies above.  The middle term (x1-x0)^2 is now
-always positive.
-
-   A similar formula for both multiplying and squaring can be
-constructed with a middle term (x1+x0)*(y1+y0).  But those sums can
-exceed k limbs, leading to more carry handling and additions than the
-form above.
-
-   Karatsuba multiplication is asymptotically an O(N^1.585) algorithm,
-the exponent being log(3)/log(2), representing 3 multiplies each 1/2
-the size of the inputs.  This is a big improvement over the basecase
-multiply at O(N^2) and the advantage soon overcomes the extra additions
-Karatsuba performs.  `MUL_TOOM22_THRESHOLD' can be as little as 10
-limbs.  The `SQR' threshold is usually about twice the `MUL'.
-
-   The basecase algorithm will take a time of the form M(N) = a*N^2 +
-b*N + c and the Karatsuba algorithm K(N) = 3*M(N/2) + d*N + e, which
-expands to K(N) = 3/4*a*N^2 + 3/2*b*N + 3*c + d*N + e.  The factor 3/4
-for a means per-crossproduct speedups in the basecase code will
-increase the threshold since they benefit M(N) more than K(N).  And
-conversely the 3/2 for b means linear style speedups of b will increase
-the threshold since they benefit K(N) more than M(N).  The latter can
-be seen for instance when adding an optimized `mpn_sqr_diagonal' to
-`mpn_sqr_basecase'.  Of course all speedups reduce total time, and in
-that sense the algorithm thresholds are merely of academic interest.
-
-
-File: gmp.info,  Node: Toom 3-Way Multiplication,  Next: Toom 4-Way Multiplication,  Prev: Karatsuba Multiplication,  Up: Multiplication Algorithms
-
-16.1.3 Toom 3-Way Multiplication
---------------------------------
-
-The Karatsuba formula is the simplest case of a general approach to
-splitting inputs that leads to both Toom and FFT algorithms.  A
-description of Toom can be found in Knuth section 4.3.3, with an
-example 3-way calculation after Theorem A.  The 3-way form used in GMP
-is described here.
-
-   The operands are each considered split into 3 pieces of equal length
-(or the most significant part 1 or 2 limbs shorter than the other two).
-
-      high                         low
-     +----------+----------+----------+
-     |    x2    |    x1    |    x0    |
-     +----------+----------+----------+
-
-     +----------+----------+----------+
-     |    y2    |    y1    |    y0    |
-     +----------+----------+----------+
-
-These parts are treated as the coefficients of two polynomials
-
-     X(t) = x2*t^2 + x1*t + x0
-     Y(t) = y2*t^2 + y1*t + y0
-
-   Let b equal the power of 2 which is the size of the x0, x1, y0 and
-y1 pieces, ie. if they're k limbs each then b=2^(k*mp_bits_per_limb).
-With this x=X(b) and y=Y(b).
-
-   Let a polynomial W(t)=X(t)*Y(t) and suppose its coefficients are
-
-     W(t) = w4*t^4 + w3*t^3 + w2*t^2 + w1*t + w0
-
-   The w[i] are going to be determined, and when they are they'll give
-the final result using w=W(b), since x*y=X(b)*Y(b)=W(b).  The
-coefficients will be roughly b^2 each, and the final W(b) will be an
-addition like,
-
-      high                                        low
-     +-------+-------+
-     |       w4      |
-     +-------+-------+
-            +--------+-------+
-            |        w3      |
-            +--------+-------+
-                    +--------+-------+
-                    |        w2      |
-                    +--------+-------+
-                            +--------+-------+
-                            |        w1      |
-                            +--------+-------+
-                                     +-------+-------+
-                                     |       w0      |
-                                     +-------+-------+
-
-   The w[i] coefficients could be formed by a simple set of cross
-products, like w4=x2*y2, w3=x2*y1+x1*y2, w2=x2*y0+x1*y1+x0*y2 etc, but
-this would need all nine x[i]*y[j] for i,j=0,1,2, and would be
-equivalent merely to a basecase multiply.  Instead the following
-approach is used.
-
-   X(t) and Y(t) are evaluated and multiplied at 5 points, giving
-values of W(t) at those points.  In GMP the following points are used,
-
-     Point    Value
-     t=0      x0 * y0, which gives w0 immediately
-     t=1      (x2+x1+x0) * (y2+y1+y0)
-     t=-1     (x2-x1+x0) * (y2-y1+y0)
-     t=2      (4*x2+2*x1+x0) * (4*y2+2*y1+y0)
-     t=inf    x2 * y2, which gives w4 immediately
-
-   At t=-1 the values can be negative and that's handled using the
-absolute values and tracking the sign separately.  At t=inf the value
-is actually X(t)*Y(t)/t^4 in the limit as t approaches infinity, but
-it's much easier to think of as simply x2*y2 giving w4 immediately
-(much like x0*y0 at t=0 gives w0 immediately).
-
-   Each of the points substituted into W(t)=w4*t^4+...+w0 gives a
-linear combination of the w[i] coefficients, and the value of those
-combinations has just been calculated.
-
-     W(0)   =                              w0
-     W(1)   =    w4 +   w3 +   w2 +   w1 + w0
-     W(-1)  =    w4 -   w3 +   w2 -   w1 + w0
-     W(2)   = 16*w4 + 8*w3 + 4*w2 + 2*w1 + w0
-     W(inf) =    w4
-
-   This is a set of five equations in five unknowns, and some
-elementary linear algebra quickly isolates each w[i].  This involves
-adding or subtracting one W(t) value from another, and a couple of
-divisions by powers of 2 and one division by 3, the latter using the
-special `mpn_divexact_by3' (*note Exact Division::).
-
-   The conversion of W(t) values to the coefficients is interpolation.
-A polynomial of degree 4 like W(t) is uniquely determined by values
-known at 5 different points.  The points are arbitrary and can be
-chosen to make the linear equations come out with a convenient set of
-steps for quickly isolating the w[i].
-
-   Squaring follows the same procedure as multiplication, but there's
-only one X(t) and it's evaluated at the 5 points, and those values
-squared to give values of W(t).  The interpolation is then identical,
-and in fact the same `toom3_interpolate' subroutine is used for both
-squaring and multiplying.
-
-   Toom-3 is asymptotically O(N^1.465), the exponent being
-log(5)/log(3), representing 5 recursive multiplies of 1/3 the original
-size each.  This is an improvement over Karatsuba at O(N^1.585), though
-Toom does more work in the evaluation and interpolation and so it only
-realizes its advantage above a certain size.
-
-   Near the crossover between Toom-3 and Karatsuba there's generally a
-range of sizes where the difference between the two is small.
-`MUL_TOOM33_THRESHOLD' is a somewhat arbitrary point in that range and
-successive runs of the tune program can give different values due to
-small variations in measuring.  A graph of time versus size for the two
-shows the effect, see `tune/README'.
-
-   At the fairly small sizes where the Toom-3 thresholds occur it's
-worth remembering that the asymptotic behaviour for Karatsuba and
-Toom-3 can't be expected to make accurate predictions, due of course to
-the big influence of all sorts of overheads, and the fact that only a
-few recursions of each are being performed.  Even at large sizes
-there's a good chance machine dependent effects like cache architecture
-will mean actual performance deviates from what might be predicted.
-
-   The formula given for the Karatsuba algorithm (*note Karatsuba
-Multiplication::) has an equivalent for Toom-3 involving only five
-multiplies, but this would be complicated and unenlightening.
-
-   An alternate view of Toom-3 can be found in Zuras (*note
-References::), using a vector to represent the x and y splits and a
-matrix multiplication for the evaluation and interpolation stages.  The
-matrix inverses are not meant to be actually used, and they have
-elements with values much greater than in fact arise in the
-interpolation steps.  The diagram shown for the 3-way is attractive,
-but again doesn't have to be implemented that way and for example with
-a bit of rearrangement just one division by 6 can be done.
-
-
-File: gmp.info,  Node: Toom 4-Way Multiplication,  Next: FFT Multiplication,  Prev: Toom 3-Way Multiplication,  Up: Multiplication Algorithms
-
-16.1.4 Toom 4-Way Multiplication
---------------------------------
-
-Karatsuba and Toom-3 split the operands into 2 and 3 coefficients,
-respectively.  Toom-4 analogously splits the operands into 4
-coefficients.  Using the notation from the section on Toom-3
-multiplication, we form two polynomials:
-
-     X(t) = x3*t^3 + x2*t^2 + x1*t + x0
-     Y(t) = y3*t^3 + y2*t^2 + y1*t + y0
-
-   X(t) and Y(t) are evaluated and multiplied at 7 points, giving
-values of W(t) at those points.  In GMP the following points are used,
-
-     Point    Value
-     t=0      x0 * y0, which gives w0 immediately
-     t=1/2    (x3+2*x2+4*x1+8*x0) * (y3+2*y2+4*y1+8*y0)
-     t=-1/2   (-x3+2*x2-4*x1+8*x0) * (-y3+2*y2-4*y1+8*y0)
-     t=1      (x3+x2+x1+x0) * (y3+y2+y1+y0)
-     t=-1     (-x3+x2-x1+x0) * (-y3+y2-y1+y0)
-     t=2      (8*x3+4*x2+2*x1+x0) * (8*y3+4*y2+2*y1+y0)
-     t=inf    x3 * y3, which gives w6 immediately
-
-   The number of additions and subtractions for Toom-4 is much larger
-than for Toom-3.  But several subexpressions occur multiple times, for
-example x2+x0, occurs for both t=1 and t=-1.
-
-   Toom-4 is asymptotically O(N^1.404), the exponent being
-log(7)/log(4), representing 7 recursive multiplies of 1/4 the original
-size each.
-
-
-File: gmp.info,  Node: FFT Multiplication,  Next: Other Multiplication,  Prev: Toom 4-Way Multiplication,  Up: Multiplication Algorithms
-
-16.1.5 FFT Multiplication
--------------------------
-
-At large to very large sizes a Fermat style FFT multiplication is used,
-following Scho"nhage and Strassen (*note References::).  Descriptions
-of FFTs in various forms can be found in many textbooks, for instance
-Knuth section 4.3.3 part C or Lipson chapter IX.  A brief description
-of the form used in GMP is given here.
-
-   The multiplication done is x*y mod 2^N+1, for a given N.  A full
-product x*y is obtained by choosing N>=bits(x)+bits(y) and padding x
-and y with high zero limbs.  The modular product is the native form for
-the algorithm, so padding to get a full product is unavoidable.
-
-   The algorithm follows a split, evaluate, pointwise multiply,
-interpolate and combine similar to that described above for Karatsuba
-and Toom-3.  A k parameter controls the split, with an FFT-k splitting
-into 2^k pieces of M=N/2^k bits each.  N must be a multiple of
-(2^k)*mp_bits_per_limb so the split falls on limb boundaries, avoiding
-bit shifts in the split and combine stages.
-
-   The evaluations, pointwise multiplications, and interpolation, are
-all done modulo 2^N'+1 where N' is 2M+k+3 rounded up to a multiple of
-2^k and of `mp_bits_per_limb'.  The results of interpolation will be
-the following negacyclic convolution of the input pieces, and the
-choice of N' ensures these sums aren't truncated.
-
-                ---
-                \         b
-     w[n] =     /     (-1) * x[i] * y[j]
-                ---
-            i+j==b*2^k+n
-               b=0,1
-
-   The points used for the evaluation are g^i for i=0 to 2^k-1 where
-g=2^(2N'/2^k).  g is a 2^k'th root of unity mod 2^N'+1, which produces
-necessary cancellations at the interpolation stage, and it's also a
-power of 2 so the fast Fourier transforms used for the evaluation and
-interpolation do only shifts, adds and negations.
-
-   The pointwise multiplications are done modulo 2^N'+1 and either
-recurse into a further FFT or use a plain multiplication (Toom-3,
-Karatsuba or basecase), whichever is optimal at the size N'.  The
-interpolation is an inverse fast Fourier transform.  The resulting set
-of sums of x[i]*y[j] are added at appropriate offsets to give the final
-result.
-
-   Squaring is the same, but x is the only input so it's one transform
-at the evaluate stage and the pointwise multiplies are squares.  The
-interpolation is the same.
-
-   For a mod 2^N+1 product, an FFT-k is an O(N^(k/(k-1))) algorithm,
-the exponent representing 2^k recursed modular multiplies each
-1/2^(k-1) the size of the original.  Each successive k is an asymptotic
-improvement, but overheads mean each is only faster at bigger and
-bigger sizes.  In the code, `MUL_FFT_TABLE' and `SQR_FFT_TABLE' are the
-thresholds where each k is used.  Each new k effectively swaps some
-multiplying for some shifts, adds and overheads.
-
-   A mod 2^N+1 product can be formed with a normal NxN->2N bit multiply
-plus a subtraction, so an FFT and Toom-3 etc can be compared directly.
-A k=4 FFT at O(N^1.333) can be expected to be the first faster than
-Toom-3 at O(N^1.465).  In practice this is what's found, with
-`MUL_FFT_MODF_THRESHOLD' and `SQR_FFT_MODF_THRESHOLD' being between 300
-and 1000 limbs, depending on the CPU.  So far it's been found that only
-very large FFTs recurse into pointwise multiplies above these sizes.
-
-   When an FFT is to give a full product, the change of N to 2N doesn't
-alter the theoretical complexity for a given k, but for the purposes of
-considering where an FFT might be first used it can be assumed that the
-FFT is recursing into a normal multiply and that on that basis it's
-doing 2^k recursed multiplies each 1/2^(k-2) the size of the inputs,
-making it O(N^(k/(k-2))).  This would mean k=7 at O(N^1.4) would be the
-first FFT faster than Toom-3.  In practice `MUL_FFT_THRESHOLD' and
-`SQR_FFT_THRESHOLD' have been found to be in the k=8 range, somewhere
-between 3000 and 10000 limbs.
-
-   The way N is split into 2^k pieces and then 2M+k+3 is rounded up to
-a multiple of 2^k and `mp_bits_per_limb' means that when
-2^k>=mp_bits_per_limb the effective N is a multiple of 2^(2k-1) bits.
-The +k+3 means some values of N just under such a multiple will be
-rounded to the next.  The complexity calculations above assume that a
-favourable size is used, meaning one which isn't padded through
-rounding, and it's also assumed that the extra +k+3 bits are negligible
-at typical FFT sizes.
-
-   The practical effect of the 2^(2k-1) constraint is to introduce a
-step-effect into measured speeds.  For example k=8 will round N up to a
-multiple of 32768 bits, so for a 32-bit limb there'll be 512 limb
-groups of sizes for which `mpn_mul_n' runs at the same speed.  Or for
-k=9 groups of 2048 limbs, k=10 groups of 8192 limbs, etc.  In practice
-it's been found each k is used at quite small multiples of its size
-constraint and so the step effect is quite noticeable in a time versus
-size graph.
-
-   The threshold determinations currently measure at the mid-points of
-size steps, but this is sub-optimal since at the start of a new step it
-can happen that it's better to go back to the previous k for a while.
-Something more sophisticated for `MUL_FFT_TABLE' and `SQR_FFT_TABLE'
-will be needed.
-
-
-File: gmp.info,  Node: Other Multiplication,  Next: Unbalanced Multiplication,  Prev: FFT Multiplication,  Up: Multiplication Algorithms
-
-16.1.6 Other Multiplication
----------------------------
-
-The Toom algorithms described above (*note Toom 3-Way Multiplication::,
-*note Toom 4-Way Multiplication::) generalizes to split into an
-arbitrary number of pieces, as per Knuth section 4.3.3 algorithm C.
-This is not currently used.  The notes here are merely for interest.
-
-   In general a split into r+1 pieces is made, and evaluations and
-pointwise multiplications done at 2*r+1 points.  A 4-way split does 7
-pointwise multiplies, 5-way does 9, etc.  Asymptotically an (r+1)-way
-algorithm is O(N^(log(2*r+1)/log(r+1))).  Only the pointwise
-multiplications count towards big-O complexity, but the time spent in
-the evaluate and interpolate stages grows with r and has a significant
-practical impact, with the asymptotic advantage of each r realized only
-at bigger and bigger sizes.  The overheads grow as O(N*r), whereas in
-an r=2^k FFT they grow only as O(N*log(r)).
-
-   Knuth algorithm C evaluates at points 0,1,2,...,2*r, but exercise 4
-uses -r,...,0,...,r and the latter saves some small multiplies in the
-evaluate stage (or rather trades them for additions), and has a further
-saving of nearly half the interpolate steps.  The idea is to separate
-odd and even final coefficients and then perform algorithm C steps C7
-and C8 on them separately.  The divisors at step C7 become j^2 and the
-multipliers at C8 become 2*t*j-j^2.
-
-   Splitting odd and even parts through positive and negative points
-can be thought of as using -1 as a square root of unity.  If a 4th root
-of unity was available then a further split and speedup would be
-possible, but no such root exists for plain integers.  Going to complex
-integers with i=sqrt(-1) doesn't help, essentially because in Cartesian
-form it takes three real multiplies to do a complex multiply.  The
-existence of 2^k'th roots of unity in a suitable ring or field lets the
-fast Fourier transform keep splitting and get to O(N*log(r)).
-
-   Floating point FFTs use complex numbers approximating Nth roots of
-unity.  Some processors have special support for such FFTs.  But these
-are not used in GMP since it's very difficult to guarantee an exact
-result (to some number of bits).  An occasional difference of 1 in the
-last bit might not matter to a typical signal processing algorithm, but
-is of course of vital importance to GMP.
-
-
-File: gmp.info,  Node: Unbalanced Multiplication,  Prev: Other Multiplication,  Up: Multiplication Algorithms
-
-16.1.7 Unbalanced Multiplication
---------------------------------
-
-Multiplication of operands with different sizes, both below
-`MUL_TOOM22_THRESHOLD' are done with plain schoolbook multiplication
-(*note Basecase Multiplication::).
-
-   For really large operands, we invoke FFT directly.
-
-   For operands between these sizes, we use Toom inspired algorithms
-suggested by Alberto Zanoni and Marco Bodrato.  The idea is to split
-the operands into polynomials of different degree.  GMP currently
-splits the smaller operand onto 2 coefficients, i.e., a polynomial of
-degree 1, but the larger operand can be split into 2, 3, or 4
-coefficients, i.e., a polynomial of degree 1 to 3.
-
-
-File: gmp.info,  Node: Division Algorithms,  Next: Greatest Common Divisor Algorithms,  Prev: Multiplication Algorithms,  Up: Algorithms
-
-16.2 Division Algorithms
-========================
-
-* Menu:
-
-* Single Limb Division::
-* Basecase Division::
-* Divide and Conquer Division::
-* Block-Wise Barrett Division::
-* Exact Division::
-* Exact Remainder::
-* Small Quotient Division::
-
-
-File: gmp.info,  Node: Single Limb Division,  Next: Basecase Division,  Prev: Division Algorithms,  Up: Division Algorithms
-
-16.2.1 Single Limb Division
----------------------------
-
-Nx1 division is implemented using repeated 2x1 divisions from high to
-low, either with a hardware divide instruction or a multiplication by
-inverse, whichever is best on a given CPU.
-
-   The multiply by inverse follows "Improved division by invariant
-integers" by Mo"ller and Granlund (*note References::) and is
-implemented as `udiv_qrnnd_preinv' in `gmp-impl.h'.  The idea is to
-have a fixed-point approximation to 1/d (see `invert_limb') and then
-multiply by the high limb (plus one bit) of the dividend to get a
-quotient q.  With d normalized (high bit set), q is no more than 1 too
-small.  Subtracting q*d from the dividend gives a remainder, and
-reveals whether q or q-1 is correct.
-
-   The result is a division done with two multiplications and four or
-five arithmetic operations.  On CPUs with low latency multipliers this
-can be much faster than a hardware divide, though the cost of
-calculating the inverse at the start may mean it's only better on
-inputs bigger than say 4 or 5 limbs.
-
-   When a divisor must be normalized, either for the generic C
-`__udiv_qrnnd_c' or the multiply by inverse, the division performed is
-actually a*2^k by d*2^k where a is the dividend and k is the power
-necessary to have the high bit of d*2^k set.  The bit shifts for the
-dividend are usually accomplished "on the fly" meaning by extracting
-the appropriate bits at each step.  Done this way the quotient limbs
-come out aligned ready to store.  When only the remainder is wanted, an
-alternative is to take the dividend limbs unshifted and calculate r = a
-mod d*2^k followed by an extra final step r*2^k mod d*2^k.  This can
-help on CPUs with poor bit shifts or few registers.
-
-   The multiply by inverse can be done two limbs at a time.  The
-calculation is basically the same, but the inverse is two limbs and the
-divisor treated as if padded with a low zero limb.  This means more
-work, since the inverse will need a 2x2 multiply, but the four 1x1s to
-do that are independent and can therefore be done partly or wholly in
-parallel.  Likewise for a 2x1 calculating q*d.  The net effect is to
-process two limbs with roughly the same two multiplies worth of latency
-that one limb at a time gives.  This extends to 3 or 4 limbs at a time,
-though the extra work to apply the inverse will almost certainly soon
-reach the limits of multiplier throughput.
-
-   A similar approach in reverse can be taken to process just half a
-limb at a time if the divisor is only a half limb.  In this case the
-1x1 multiply for the inverse effectively becomes two (1/2)x1 for each
-limb, which can be a saving on CPUs with a fast half limb multiply, or
-in fact if the only multiply is a half limb, and especially if it's not
-pipelined.
-
-
-File: gmp.info,  Node: Basecase Division,  Next: Divide and Conquer Division,  Prev: Single Limb Division,  Up: Division Algorithms
-
-16.2.2 Basecase Division
-------------------------
-
-Basecase NxM division is like long division done by hand, but in base
-2^mp_bits_per_limb.  See Knuth section 4.3.1 algorithm D, and
-`mpn/generic/sb_divrem_mn.c'.
-
-   Briefly stated, while the dividend remains larger than the divisor,
-a high quotient limb is formed and the Nx1 product q*d subtracted at
-the top end of the dividend.  With a normalized divisor (most
-significant bit set), each quotient limb can be formed with a 2x1
-division and a 1x1 multiplication plus some subtractions.  The 2x1
-division is by the high limb of the divisor and is done either with a
-hardware divide or a multiply by inverse (the same as in *Note Single
-Limb Division::) whichever is faster.  Such a quotient is sometimes one
-too big, requiring an addback of the divisor, but that happens rarely.
-
-   With Q=N-M being the number of quotient limbs, this is an O(Q*M)
-algorithm and will run at a speed similar to a basecase QxM
-multiplication, differing in fact only in the extra multiply and divide
-for each of the Q quotient limbs.
-
-
-File: gmp.info,  Node: Divide and Conquer Division,  Next: Block-Wise Barrett Division,  Prev: Basecase Division,  Up: Division Algorithms
-
-16.2.3 Divide and Conquer Division
-----------------------------------
-
-For divisors larger than `DC_DIV_QR_THRESHOLD', division is done by
-dividing.  Or to be precise by a recursive divide and conquer algorithm
-based on work by Moenck and Borodin, Jebelean, and Burnikel and Ziegler
-(*note References::).
-
-   The algorithm consists essentially of recognising that a 2NxN
-division can be done with the basecase division algorithm (*note
-Basecase Division::), but using N/2 limbs as a base, not just a single
-limb.  This way the multiplications that arise are (N/2)x(N/2) and can
-take advantage of Karatsuba and higher multiplication algorithms (*note
-Multiplication Algorithms::).  The two "digits" of the quotient are
-formed by recursive Nx(N/2) divisions.
-
-   If the (N/2)x(N/2) multiplies are done with a basecase multiplication
-then the work is about the same as a basecase division, but with more
-function call overheads and with some subtractions separated from the
-multiplies.  These overheads mean that it's only when N/2 is above
-`MUL_TOOM22_THRESHOLD' that divide and conquer is of use.
-
-   `DC_DIV_QR_THRESHOLD' is based on the divisor size N, so it will be
-somewhere above twice `MUL_TOOM22_THRESHOLD', but how much above
-depends on the CPU.  An optimized `mpn_mul_basecase' can lower
-`DC_DIV_QR_THRESHOLD' a little by offering a ready-made advantage over
-repeated `mpn_submul_1' calls.
-
-   Divide and conquer is asymptotically O(M(N)*log(N)) where M(N) is
-the time for an NxN multiplication done with FFTs.  The actual time is
-a sum over multiplications of the recursed sizes, as can be seen near
-the end of section 2.2 of Burnikel and Ziegler.  For example, within
-the Toom-3 range, divide and conquer is 2.63*M(N).  With higher
-algorithms the M(N) term improves and the multiplier tends to log(N).
-In practice, at moderate to large sizes, a 2NxN division is about 2 to
-4 times slower than an NxN multiplication.
-
-
-File: gmp.info,  Node: Block-Wise Barrett Division,  Next: Exact Division,  Prev: Divide and Conquer Division,  Up: Division Algorithms
-
-16.2.4 Block-Wise Barrett Division
-----------------------------------
-
-For the largest divisions, a block-wise Barrett division algorithm is
-used.  Here, the divisor is inverted to a precision determined by the
-relative size of the dividend and divisor.  Blocks of quotient limbs
-are then generated by multiplying blocks from the dividend by the
-inverse.
-
-   Our block-wise algorithm computes a smaller inverse than in the
-plain Barrett algorithm.  For a 2n/n division, the inverse will be just
-ceil(n/2) limbs.
-
-
-File: gmp.info,  Node: Exact Division,  Next: Exact Remainder,  Prev: Block-Wise Barrett Division,  Up: Division Algorithms
-
-16.2.5 Exact Division
----------------------
-
-A so-called exact division is when the dividend is known to be an exact
-multiple of the divisor.  Jebelean's exact division algorithm uses this
-knowledge to make some significant optimizations (*note References::).
-
-   The idea can be illustrated in decimal for example with 368154
-divided by 543.  Because the low digit of the dividend is 4, the low
-digit of the quotient must be 8.  This is arrived at from 4*7 mod 10,
-using the fact 7 is the modular inverse of 3 (the low digit of the
-divisor), since 3*7 == 1 mod 10.  So 8*543=4344 can be subtracted from
-the dividend leaving 363810.  Notice the low digit has become zero.
-
-   The procedure is repeated at the second digit, with the next
-quotient digit 7 (7 == 1*7 mod 10), subtracting 7*543=3801, leaving
-325800.  And finally at the third digit with quotient digit 6 (8*7 mod
-10), subtracting 6*543=3258 leaving 0.  So the quotient is 678.
-
-   Notice however that the multiplies and subtractions don't need to
-extend past the low three digits of the dividend, since that's enough
-to determine the three quotient digits.  For the last quotient digit no
-subtraction is needed at all.  On a 2NxN division like this one, only
-about half the work of a normal basecase division is necessary.
-
-   For an NxM exact division producing Q=N-M quotient limbs, the saving
-over a normal basecase division is in two parts.  Firstly, each of the
-Q quotient limbs needs only one multiply, not a 2x1 divide and
-multiply.  Secondly, the crossproducts are reduced when Q>M to
-Q*M-M*(M+1)/2, or when Q<=M to Q*(Q-1)/2.  Notice the savings are
-complementary.  If Q is big then many divisions are saved, or if Q is
-small then the crossproducts reduce to a small number.
-
-   The modular inverse used is calculated efficiently by `binvert_limb'
-in `gmp-impl.h'.  This does four multiplies for a 32-bit limb, or six
-for a 64-bit limb.  `tune/modlinv.c' has some alternate implementations
-that might suit processors better at bit twiddling than multiplying.
-
-   The sub-quadratic exact division described by Jebelean in "Exact
-Division with Karatsuba Complexity" is not currently implemented.  It
-uses a rearrangement similar to the divide and conquer for normal
-division (*note Divide and Conquer Division::), but operating from low
-to high.  A further possibility not currently implemented is
-"Bidirectional Exact Integer Division" by Krandick and Jebelean which
-forms quotient limbs from both the high and low ends of the dividend,
-and can halve once more the number of crossproducts needed in a 2NxN
-division.
-
-   A special case exact division by 3 exists in `mpn_divexact_by3',
-supporting Toom-3 multiplication and `mpq' canonicalizations.  It forms
-quotient digits with a multiply by the modular inverse of 3 (which is
-`0xAA..AAB') and uses two comparisons to determine a borrow for the next
-limb.  The multiplications don't need to be on the dependent chain, as
-long as the effect of the borrows is applied, which can help chips with
-pipelined multipliers.
-
-
-File: gmp.info,  Node: Exact Remainder,  Next: Small Quotient Division,  Prev: Exact Division,  Up: Division Algorithms
-
-16.2.6 Exact Remainder
-----------------------
-
-If the exact division algorithm is done with a full subtraction at each
-stage and the dividend isn't a multiple of the divisor, then low zero
-limbs are produced but with a remainder in the high limbs.  For
-dividend a, divisor d, quotient q, and b = 2^mp_bits_per_limb, this
-remainder r is of the form
-
-     a = q*d + r*b^n
-
-   n represents the number of zero limbs produced by the subtractions,
-that being the number of limbs produced for q.  r will be in the range
-0<=r<d and can be viewed as a remainder, but one shifted up by a factor
-of b^n.
-
-   Carrying out full subtractions at each stage means the same number
-of cross products must be done as a normal division, but there's still
-some single limb divisions saved.  When d is a single limb some
-simplifications arise, providing good speedups on a number of
-processors.
-
-   `mpn_divexact_by3', `mpn_modexact_1_odd' and the `mpn_redc_X'
-functions differ subtly in how they return r, leading to some negations
-in the above formula, but all are essentially the same.
-
-   Clearly r is zero when a is a multiple of d, and this leads to
-divisibility or congruence tests which are potentially more efficient
-than a normal division.
-
-   The factor of b^n on r can be ignored in a GCD when d is odd, hence
-the use of `mpn_modexact_1_odd' by `mpn_gcd_1' and `mpz_kronecker_ui'
-etc (*note Greatest Common Divisor Algorithms::).
-
-   Montgomery's REDC method for modular multiplications uses operands
-of the form of x*b^-n and y*b^-n and on calculating (x*b^-n)*(y*b^-n)
-uses the factor of b^n in the exact remainder to reach a product in the
-same form (x*y)*b^-n (*note Modular Powering Algorithm::).
-
-   Notice that r generally gives no useful information about the
-ordinary remainder a mod d since b^n mod d could be anything.  If
-however b^n == 1 mod d, then r is the negative of the ordinary
-remainder.  This occurs whenever d is a factor of b^n-1, as for example
-with 3 in `mpn_divexact_by3'.  For a 32 or 64 bit limb other such
-factors include 5, 17 and 257, but no particular use has been found for
-this.
-
-
-File: gmp.info,  Node: Small Quotient Division,  Prev: Exact Remainder,  Up: Division Algorithms
-
-16.2.7 Small Quotient Division
-------------------------------
-
-An NxM division where the number of quotient limbs Q=N-M is small can
-be optimized somewhat.
-
-   An ordinary basecase division normalizes the divisor by shifting it
-to make the high bit set, shifting the dividend accordingly, and
-shifting the remainder back down at the end of the calculation.  This
-is wasteful if only a few quotient limbs are to be formed.  Instead a
-division of just the top 2*Q limbs of the dividend by the top Q limbs
-of the divisor can be used to form a trial quotient.  This requires
-only those limbs normalized, not the whole of the divisor and dividend.
-
-   A multiply and subtract then applies the trial quotient to the M-Q
-unused limbs of the divisor and N-Q dividend limbs (which includes Q
-limbs remaining from the trial quotient division).  The starting trial
-quotient can be 1 or 2 too big, but all cases of 2 too big and most
-cases of 1 too big are detected by first comparing the most significant
-limbs that will arise from the subtraction.  An addback is done if the
-quotient still turns out to be 1 too big.
-
-   This whole procedure is essentially the same as one step of the
-basecase algorithm done in a Q limb base, though with the trial
-quotient test done only with the high limbs, not an entire Q limb
-"digit" product.  The correctness of this weaker test can be
-established by following the argument of Knuth section 4.3.1 exercise
-20 but with the v2*q>b*r+u2 condition appropriately relaxed.
-
-
-File: gmp.info,  Node: Greatest Common Divisor Algorithms,  Next: Powering Algorithms,  Prev: Division Algorithms,  Up: Algorithms
-
-16.3 Greatest Common Divisor
-============================
-
-* Menu:
-
-* Binary GCD::
-* Lehmer's Algorithm::
-* Subquadratic GCD::
-* Extended GCD::
-* Jacobi Symbol::
-
-
-File: gmp.info,  Node: Binary GCD,  Next: Lehmer's Algorithm,  Prev: Greatest Common Divisor Algorithms,  Up: Greatest Common Divisor Algorithms
-
-16.3.1 Binary GCD
------------------
-
-At small sizes GMP uses an O(N^2) binary style GCD.  This is described
-in many textbooks, for example Knuth section 4.5.2 algorithm B.  It
-simply consists of successively reducing odd operands a and b using
-
-     a,b = abs(a-b),min(a,b)
-     strip factors of 2 from a
-
-   The Euclidean GCD algorithm, as per Knuth algorithms E and A,
-repeatedly computes the quotient q = floor(a/b) and replaces a,b by v,
-u - q v. The binary algorithm has so far been found to be faster than
-the Euclidean algorithm everywhere.  One reason the binary method does
-well is that the implied quotient at each step is usually small, so
-often only one or two subtractions are needed to get the same effect as
-a division.  Quotients 1, 2 and 3 for example occur 67.7% of the time,
-see Knuth section 4.5.3 Theorem E.
-
-   When the implied quotient is large, meaning b is much smaller than
-a, then a division is worthwhile.  This is the basis for the initial a
-mod b reductions in `mpn_gcd' and `mpn_gcd_1' (the latter for both Nx1
-and 1x1 cases).  But after that initial reduction, big quotients occur
-too rarely to make it worth checking for them.
-
-
-   The final 1x1 GCD in `mpn_gcd_1' is done in the generic C code as
-described above.  For two N-bit operands, the algorithm takes about
-0.68 iterations per bit.  For optimum performance some attention needs
-to be paid to the way the factors of 2 are stripped from a.
-
-   Firstly it may be noted that in twos complement the number of low
-zero bits on a-b is the same as b-a, so counting or testing can begin on
-a-b without waiting for abs(a-b) to be determined.
-
-   A loop stripping low zero bits tends not to branch predict well,
-since the condition is data dependent.  But on average there's only a
-few low zeros, so an option is to strip one or two bits arithmetically
-then loop for more (as done for AMD K6).  Or use a lookup table to get
-a count for several bits then loop for more (as done for AMD K7).  An
-alternative approach is to keep just one of a or b odd and iterate
-
-     a,b = abs(a-b), min(a,b)
-     a = a/2 if even
-     b = b/2 if even
-
-   This requires about 1.25 iterations per bit, but stripping of a
-single bit at each step avoids any branching.  Repeating the bit strip
-reduces to about 0.9 iterations per bit, which may be a worthwhile
-tradeoff.
-
-   Generally with the above approaches a speed of perhaps 6 cycles per
-bit can be achieved, which is still not terribly fast with for instance
-a 64-bit GCD taking nearly 400 cycles.  It's this sort of time which
-means it's not usually advantageous to combine a set of divisibility
-tests into a GCD.
-
-   Currently, the binary algorithm is used for GCD only when N < 3.
-
-
-File: gmp.info,  Node: Lehmer's Algorithm,  Next: Subquadratic GCD,  Prev: Binary GCD,  Up: Greatest Common Divisor Algorithms
-
-16.3.2 Lehmer's algorithm
--------------------------
-
-Lehmer's improvement of the Euclidean algorithms is based on the
-observation that the initial part of the quotient sequence depends only
-on the most significant parts of the inputs. The variant of Lehmer's
-algorithm used in GMP splits off the most significant two limbs, as
-suggested, e.g., in "A Double-Digit Lehmer-Euclid Algorithm" by
-Jebelean (*note References::). The quotients of two double-limb inputs
-are collected as a 2 by 2 matrix with single-limb elements. This is
-done by the function `mpn_hgcd2'. The resulting matrix is applied to
-the inputs using `mpn_mul_1' and `mpn_submul_1'. Each iteration usually
-reduces the inputs by almost one limb. In the rare case of a large
-quotient, no progress can be made by examining just the most
-significant two limbs, and the quotient is computed using plain
-division.
-
-   The resulting algorithm is asymptotically O(N^2), just as the
-Euclidean algorithm and the binary algorithm. The quadratic part of the
-work are the calls to `mpn_mul_1' and `mpn_submul_1'. For small sizes,
-the linear work is also significant. There are roughly N calls to the
-`mpn_hgcd2' function. This function uses a couple of important
-optimizations:
-
-   * It uses the same relaxed notion of correctness as `mpn_hgcd' (see
-     next section). This means that when called with the most
-     significant two limbs of two large numbers, the returned matrix
-     does not always correspond exactly to the initial quotient
-     sequence for the two large numbers; the final quotient may
-     sometimes be one off.
-
-   * It takes advantage of the fact the quotients are usually small.
-     The division operator is not used, since the corresponding
-     assembler instruction is very slow on most architectures. (This
-     code could probably be improved further, it uses many branches
-     that are unfriendly to prediction).
-
-   * It switches from double-limb calculations to single-limb
-     calculations half-way through, when the input numbers have been
-     reduced in size from two limbs to one and a half.
-
-
-
-File: gmp.info,  Node: Subquadratic GCD,  Next: Extended GCD,  Prev: Lehmer's Algorithm,  Up: Greatest Common Divisor Algorithms
-
-16.3.3 Subquadratic GCD
------------------------
-
-For inputs larger than `GCD_DC_THRESHOLD', GCD is computed via the HGCD
-(Half GCD) function, as a generalization to Lehmer's algorithm.
-
-   Let the inputs a,b be of size N limbs each. Put S = floor(N/2) + 1.
-Then HGCD(a,b) returns a transformation matrix T with non-negative
-elements, and reduced numbers (c;d) = T^-1 (a;b). The reduced numbers
-c,d must be larger than S limbs, while their difference abs(c-d) must
-fit in S limbs. The matrix elements will also be of size roughly N/2.
-
-   The HGCD base case uses Lehmer's algorithm, but with the above stop
-condition that returns reduced numbers and the corresponding
-transformation matrix half-way through. For inputs larger than
-`HGCD_THRESHOLD', HGCD is computed recursively, using the divide and
-conquer algorithm in "On Scho"nhage's algorithm and subquadratic
-integer GCD computation" by Mo"ller (*note References::). The recursive
-algorithm consists of these main steps.
-
-   * Call HGCD recursively, on the most significant N/2 limbs. Apply the
-     resulting matrix T_1 to the full numbers, reducing them to a size
-     just above 3N/2.
-
-   * Perform a small number of division or subtraction steps to reduce
-     the numbers to size below 3N/2. This is essential mainly for the
-     unlikely case of large quotients.
-
-   * Call HGCD recursively, on the most significant N/2 limbs of the
-     reduced numbers. Apply the resulting matrix T_2 to the full
-     numbers, reducing them to a size just above N/2.
-
-   * Compute T = T_1 T_2.
-
-   * Perform a small number of division and subtraction steps to
-     satisfy the requirements, and return.
-
-   GCD is then implemented as a loop around HGCD, similarly to Lehmer's
-algorithm. Where Lehmer repeatedly chops off the top two limbs, calls
-`mpn_hgcd2', and applies the resulting matrix to the full numbers, the
-subquadratic GCD chops off the most significant third of the limbs (the
-proportion is a tuning parameter, and 1/3 seems to be more efficient
-than, e.g, 1/2), calls `mpn_hgcd', and applies the resulting matrix.
-Once the input numbers are reduced to size below `GCD_DC_THRESHOLD',
-Lehmer's algorithm is used for the rest of the work.
-
-   The asymptotic running time of both HGCD and GCD is O(M(N)*log(N)),
-where M(N) is the time for multiplying two N-limb numbers.
-
-
-File: gmp.info,  Node: Extended GCD,  Next: Jacobi Symbol,  Prev: Subquadratic GCD,  Up: Greatest Common Divisor Algorithms
-
-16.3.4 Extended GCD
--------------------
-
-The extended GCD function, or GCDEXT, calculates gcd(a,b) and also
-cofactors x and y satisfying a*x+b*y=gcd(a,b). All the algorithms used
-for plain GCD are extended to handle this case. The binary algorithm is
-used only for single-limb GCDEXT.  Lehmer's algorithm is used for sizes
-up to `GCDEXT_DC_THRESHOLD'. Above this threshold, GCDEXT is
-implemented as a loop around HGCD, but with more book-keeping to keep
-track of the cofactors. This gives the same asymptotic running time as
-for GCD and HGCD, O(M(N)*log(N))
-
-   One difference to plain GCD is that while the inputs a and b are
-reduced as the algorithm proceeds, the cofactors x and y grow in size.
-This makes the tuning of the chopping-point more difficult. The current
-code chops off the most significant half of the inputs for the call to
-HGCD in the first iteration, and the most significant two thirds for
-the remaining calls. This strategy could surely be improved. Also the
-stop condition for the loop, where Lehmer's algorithm is invoked once
-the inputs are reduced below `GCDEXT_DC_THRESHOLD', could maybe be
-improved by taking into account the current size of the cofactors.
-
diff --git a/gmp/doc/gmp.info-2 b/gmp/doc/gmp.info-2
deleted file mode 100644
index bb74451..0000000
--- a/gmp/doc/gmp.info-2
+++ /dev/null
@@ -1,3514 +0,0 @@
-This is ../../gmp/doc/gmp.info, produced by makeinfo version 4.8 from
-../../gmp/doc/gmp.texi.
-
-   This manual describes how to install and use the GNU multiple
-precision arithmetic library, version 5.0.2.
-
-   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this
-document under the terms of the GNU Free Documentation License, Version
-1.3 or any later version published by the Free Software Foundation;
-with no Invariant Sections, with the Front-Cover Texts being "A GNU
-Manual", and with the Back-Cover Texts being "You have freedom to copy
-and modify this GNU Manual, like GNU software".  A copy of the license
-is included in *Note GNU Free Documentation License::.
-
-INFO-DIR-SECTION GNU libraries
-START-INFO-DIR-ENTRY
-* gmp: (gmp).                   GNU Multiple Precision Arithmetic Library.
-END-INFO-DIR-ENTRY
-
-
-File: gmp.info,  Node: Jacobi Symbol,  Prev: Extended GCD,  Up: Greatest Common Divisor Algorithms
-
-16.3.5 Jacobi Symbol
---------------------
-
-`mpz_jacobi' and `mpz_kronecker' are currently implemented with a
-simple binary algorithm similar to that described for the GCDs (*note
-Binary GCD::).  They're not very fast when both inputs are large.
-Lehmer's multi-step improvement or a binary based multi-step algorithm
-is likely to be better.
-
-   When one operand fits a single limb, and that includes
-`mpz_kronecker_ui' and friends, an initial reduction is done with
-either `mpn_mod_1' or `mpn_modexact_1_odd', followed by the binary
-algorithm on a single limb.  The binary algorithm is well suited to a
-single limb, and the whole calculation in this case is quite efficient.
-
-   In all the routines sign changes for the result are accumulated
-using some bit twiddling, avoiding table lookups or conditional jumps.
-
-
-File: gmp.info,  Node: Powering Algorithms,  Next: Root Extraction Algorithms,  Prev: Greatest Common Divisor Algorithms,  Up: Algorithms
-
-16.4 Powering Algorithms
-========================
-
-* Menu:
-
-* Normal Powering Algorithm::
-* Modular Powering Algorithm::
-
-
-File: gmp.info,  Node: Normal Powering Algorithm,  Next: Modular Powering Algorithm,  Prev: Powering Algorithms,  Up: Powering Algorithms
-
-16.4.1 Normal Powering
-----------------------
-
-Normal `mpz' or `mpf' powering uses a simple binary algorithm,
-successively squaring and then multiplying by the base when a 1 bit is
-seen in the exponent, as per Knuth section 4.6.3.  The "left to right"
-variant described there is used rather than algorithm A, since it's
-just as easy and can be done with somewhat less temporary memory.
-
-
-File: gmp.info,  Node: Modular Powering Algorithm,  Prev: Normal Powering Algorithm,  Up: Powering Algorithms
-
-16.4.2 Modular Powering
------------------------
-
-Modular powering is implemented using a 2^k-ary sliding window
-algorithm, as per "Handbook of Applied Cryptography" algorithm 14.85
-(*note References::).  k is chosen according to the size of the
-exponent.  Larger exponents use larger values of k, the choice being
-made to minimize the average number of multiplications that must
-supplement the squaring.
-
-   The modular multiplies and squares use either a simple division or
-the REDC method by Montgomery (*note References::).  REDC is a little
-faster, essentially saving N single limb divisions in a fashion similar
-to an exact remainder (*note Exact Remainder::).
-
-
-File: gmp.info,  Node: Root Extraction Algorithms,  Next: Radix Conversion Algorithms,  Prev: Powering Algorithms,  Up: Algorithms
-
-16.5 Root Extraction Algorithms
-===============================
-
-* Menu:
-
-* Square Root Algorithm::
-* Nth Root Algorithm::
-* Perfect Square Algorithm::
-* Perfect Power Algorithm::
-
-
-File: gmp.info,  Node: Square Root Algorithm,  Next: Nth Root Algorithm,  Prev: Root Extraction Algorithms,  Up: Root Extraction Algorithms
-
-16.5.1 Square Root
-------------------
-
-Square roots are taken using the "Karatsuba Square Root" algorithm by
-Paul Zimmermann (*note References::).
-
-   An input n is split into four parts of k bits each, so with b=2^k we
-have n = a3*b^3 + a2*b^2 + a1*b + a0.  Part a3 must be "normalized" so
-that either the high or second highest bit is set.  In GMP, k is kept
-on a limb boundary and the input is left shifted (by an even number of
-bits) to normalize.
-
-   The square root of the high two parts is taken, by recursive
-application of the algorithm (bottoming out in a one-limb Newton's
-method),
-
-     s1,r1 = sqrtrem (a3*b + a2)
-
-   This is an approximation to the desired root and is extended by a
-division to give s,r,
-
-     q,u = divrem (r1*b + a1, 2*s1)
-     s = s1*b + q
-     r = u*b + a0 - q^2
-
-   The normalization requirement on a3 means at this point s is either
-correct or 1 too big.  r is negative in the latter case, so
-
-     if r < 0 then
-       r = r + 2*s - 1
-       s = s - 1
-
-   The algorithm is expressed in a divide and conquer form, but as
-noted in the paper it can also be viewed as a discrete variant of
-Newton's method, or as a variation on the schoolboy method (no longer
-taught) for square roots two digits at a time.
-
-   If the remainder r is not required then usually only a few high limbs
-of r and u need to be calculated to determine whether an adjustment to
-s is required.  This optimization is not currently implemented.
-
-   In the Karatsuba multiplication range this algorithm is
-O(1.5*M(N/2)), where M(n) is the time to multiply two numbers of n
-limbs.  In the FFT multiplication range this grows to a bound of
-O(6*M(N/2)).  In practice a factor of about 1.5 to 1.8 is found in the
-Karatsuba and Toom-3 ranges, growing to 2 or 3 in the FFT range.
-
-   The algorithm does all its calculations in integers and the resulting
-`mpn_sqrtrem' is used for both `mpz_sqrt' and `mpf_sqrt'.  The extended
-precision given by `mpf_sqrt_ui' is obtained by padding with zero limbs.
-
-
-File: gmp.info,  Node: Nth Root Algorithm,  Next: Perfect Square Algorithm,  Prev: Square Root Algorithm,  Up: Root Extraction Algorithms
-
-16.5.2 Nth Root
----------------
-
-Integer Nth roots are taken using Newton's method with the following
-iteration, where A is the input and n is the root to be taken.
-
-              1         A
-     a[i+1] = - * ( --------- + (n-1)*a[i] )
-              n     a[i]^(n-1)
-
-   The initial approximation a[1] is generated bitwise by successively
-powering a trial root with or without new 1 bits, aiming to be just
-above the true root.  The iteration converges quadratically when
-started from a good approximation.  When n is large more initial bits
-are needed to get good convergence.  The current implementation is not
-particularly well optimized.
-
-
-File: gmp.info,  Node: Perfect Square Algorithm,  Next: Perfect Power Algorithm,  Prev: Nth Root Algorithm,  Up: Root Extraction Algorithms
-
-16.5.3 Perfect Square
----------------------
-
-A significant fraction of non-squares can be quickly identified by
-checking whether the input is a quadratic residue modulo small integers.
-
-   `mpz_perfect_square_p' first tests the input mod 256, which means
-just examining the low byte.  Only 44 different values occur for
-squares mod 256, so 82.8% of inputs can be immediately identified as
-non-squares.
-
-   On a 32-bit system similar tests are done mod 9, 5, 7, 13 and 17,
-for a total 99.25% of inputs identified as non-squares.  On a 64-bit
-system 97 is tested too, for a total 99.62%.
-
-   These moduli are chosen because they're factors of 2^24-1 (or 2^48-1
-for 64-bits), and such a remainder can be quickly taken just using
-additions (see `mpn_mod_34lsub1').
-
-   When nails are in use moduli are instead selected by the `gen-psqr.c'
-program and applied with an `mpn_mod_1'.  The same 2^24-1 or 2^48-1
-could be done with nails using some extra bit shifts, but this is not
-currently implemented.
-
-   In any case each modulus is applied to the `mpn_mod_34lsub1' or
-`mpn_mod_1' remainder and a table lookup identifies non-squares.  By
-using a "modexact" style calculation, and suitably permuted tables,
-just one multiply each is required, see the code for details.  Moduli
-are also combined to save operations, so long as the lookup tables
-don't become too big.  `gen-psqr.c' does all the pre-calculations.
-
-   A square root must still be taken for any value that passes these
-tests, to verify it's really a square and not one of the small fraction
-of non-squares that get through (ie. a pseudo-square to all the tested
-bases).
-
-   Clearly more residue tests could be done, `mpz_perfect_square_p' only
-uses a compact and efficient set.  Big inputs would probably benefit
-from more residue testing, small inputs might be better off with less.
-The assumed distribution of squares versus non-squares in the input
-would affect such considerations.
-
-
-File: gmp.info,  Node: Perfect Power Algorithm,  Prev: Perfect Square Algorithm,  Up: Root Extraction Algorithms
-
-16.5.4 Perfect Power
---------------------
-
-Detecting perfect powers is required by some factorization algorithms.
-Currently `mpz_perfect_power_p' is implemented using repeated Nth root
-extractions, though naturally only prime roots need to be considered.
-(*Note Nth Root Algorithm::.)
-
-   If a prime divisor p with multiplicity e can be found, then only
-roots which are divisors of e need to be considered, much reducing the
-work necessary.  To this end divisibility by a set of small primes is
-checked.
-
-
-File: gmp.info,  Node: Radix Conversion Algorithms,  Next: Other Algorithms,  Prev: Root Extraction Algorithms,  Up: Algorithms
-
-16.6 Radix Conversion
-=====================
-
-Radix conversions are less important than other algorithms.  A program
-dominated by conversions should probably use a different data
-representation.
-
-* Menu:
-
-* Binary to Radix::
-* Radix to Binary::
-
-
-File: gmp.info,  Node: Binary to Radix,  Next: Radix to Binary,  Prev: Radix Conversion Algorithms,  Up: Radix Conversion Algorithms
-
-16.6.1 Binary to Radix
-----------------------
-
-Conversions from binary to a power-of-2 radix use a simple and fast
-O(N) bit extraction algorithm.
-
-   Conversions from binary to other radices use one of two algorithms.
-Sizes below `GET_STR_PRECOMPUTE_THRESHOLD' use a basic O(N^2) method.
-Repeated divisions by b^n are made, where b is the radix and n is the
-biggest power that fits in a limb.  But instead of simply using the
-remainder r from such divisions, an extra divide step is done to give a
-fractional limb representing r/b^n.  The digits of r can then be
-extracted using multiplications by b rather than divisions.  Special
-case code is provided for decimal, allowing multiplications by 10 to
-optimize to shifts and adds.
-
-   Above `GET_STR_PRECOMPUTE_THRESHOLD' a sub-quadratic algorithm is
-used.  For an input t, powers b^(n*2^i) of the radix are calculated,
-until a power between t and sqrt(t) is reached.  t is then divided by
-that largest power, giving a quotient which is the digits above that
-power, and a remainder which is those below.  These two parts are in
-turn divided by the second highest power, and so on recursively.  When
-a piece has been divided down to less than `GET_STR_DC_THRESHOLD'
-limbs, the basecase algorithm described above is used.
-
-   The advantage of this algorithm is that big divisions can make use
-of the sub-quadratic divide and conquer division (*note Divide and
-Conquer Division::), and big divisions tend to have less overheads than
-lots of separate single limb divisions anyway.  But in any case the
-cost of calculating the powers b^(n*2^i) must first be overcome.
-
-   `GET_STR_PRECOMPUTE_THRESHOLD' and `GET_STR_DC_THRESHOLD' represent
-the same basic thing, the point where it becomes worth doing a big
-division to cut the input in half.  `GET_STR_PRECOMPUTE_THRESHOLD'
-includes the cost of calculating the radix power required, whereas
-`GET_STR_DC_THRESHOLD' assumes that's already available, which is the
-case when recursing.
-
-   Since the base case produces digits from least to most significant
-but they want to be stored from most to least, it's necessary to
-calculate in advance how many digits there will be, or at least be sure
-not to underestimate that.  For GMP the number of input bits is
-multiplied by `chars_per_bit_exactly' from `mp_bases', rounding up.
-The result is either correct or one too big.
-
-   Examining some of the high bits of the input could increase the
-chance of getting the exact number of digits, but an exact result every
-time would not be practical, since in general the difference between
-numbers 100... and 99... is only in the last few bits and the work to
-identify 99...  might well be almost as much as a full conversion.
-
-   `mpf_get_str' doesn't currently use the algorithm described here, it
-multiplies or divides by a power of b to move the radix point to the
-just above the highest non-zero digit (or at worst one above that
-location), then multiplies by b^n to bring out digits.  This is O(N^2)
-and is certainly not optimal.
-
-   The r/b^n scheme described above for using multiplications to bring
-out digits might be useful for more than a single limb.  Some brief
-experiments with it on the base case when recursing didn't give a
-noticeable improvement, but perhaps that was only due to the
-implementation.  Something similar would work for the sub-quadratic
-divisions too, though there would be the cost of calculating a bigger
-radix power.
-
-   Another possible improvement for the sub-quadratic part would be to
-arrange for radix powers that balanced the sizes of quotient and
-remainder produced, ie. the highest power would be an b^(n*k)
-approximately equal to sqrt(t), not restricted to a 2^i factor.  That
-ought to smooth out a graph of times against sizes, but may or may not
-be a net speedup.
-
-
-File: gmp.info,  Node: Radix to Binary,  Prev: Binary to Radix,  Up: Radix Conversion Algorithms
-
-16.6.2 Radix to Binary
-----------------------
-
-*This section needs to be rewritten, it currently describes the
-algorithms used before GMP 4.3.*
-
-   Conversions from a power-of-2 radix into binary use a simple and fast
-O(N) bitwise concatenation algorithm.
-
-   Conversions from other radices use one of two algorithms.  Sizes
-below `SET_STR_PRECOMPUTE_THRESHOLD' use a basic O(N^2) method.  Groups
-of n digits are converted to limbs, where n is the biggest power of the
-base b which will fit in a limb, then those groups are accumulated into
-the result by multiplying by b^n and adding.  This saves
-multi-precision operations, as per Knuth section 4.4 part E (*note
-References::).  Some special case code is provided for decimal, giving
-the compiler a chance to optimize multiplications by 10.
-
-   Above `SET_STR_PRECOMPUTE_THRESHOLD' a sub-quadratic algorithm is
-used.  First groups of n digits are converted into limbs.  Then adjacent
-limbs are combined into limb pairs with x*b^n+y, where x and y are the
-limbs.  Adjacent limb pairs are combined into quads similarly with
-x*b^(2n)+y.  This continues until a single block remains, that being
-the result.
-
-   The advantage of this method is that the multiplications for each x
-are big blocks, allowing Karatsuba and higher algorithms to be used.
-But the cost of calculating the powers b^(n*2^i) must be overcome.
-`SET_STR_PRECOMPUTE_THRESHOLD' usually ends up quite big, around 5000
-digits, and on some processors much bigger still.
-
-   `SET_STR_PRECOMPUTE_THRESHOLD' is based on the input digits (and
-tuned for decimal), though it might be better based on a limb count, so
-as to be independent of the base.  But that sort of count isn't used by
-the base case and so would need some sort of initial calculation or
-estimate.
-
-   The main reason `SET_STR_PRECOMPUTE_THRESHOLD' is so much bigger
-than the corresponding `GET_STR_PRECOMPUTE_THRESHOLD' is that
-`mpn_mul_1' is much faster than `mpn_divrem_1' (often by a factor of 5,
-or more).
-
-
-File: gmp.info,  Node: Other Algorithms,  Next: Assembly Coding,  Prev: Radix Conversion Algorithms,  Up: Algorithms
-
-16.7 Other Algorithms
-=====================
-
-* Menu:
-
-* Prime Testing Algorithm::
-* Factorial Algorithm::
-* Binomial Coefficients Algorithm::
-* Fibonacci Numbers Algorithm::
-* Lucas Numbers Algorithm::
-* Random Number Algorithms::
-
-
-File: gmp.info,  Node: Prime Testing Algorithm,  Next: Factorial Algorithm,  Prev: Other Algorithms,  Up: Other Algorithms
-
-16.7.1 Prime Testing
---------------------
-
-The primality testing in `mpz_probab_prime_p' (*note Number Theoretic
-Functions::) first does some trial division by small factors and then
-uses the Miller-Rabin probabilistic primality testing algorithm, as
-described in Knuth section 4.5.4 algorithm P (*note References::).
-
-   For an odd input n, and with n = q*2^k+1 where q is odd, this
-algorithm selects a random base x and tests whether x^q mod n is 1 or
--1, or an x^(q*2^j) mod n is 1, for 1<=j<=k.  If so then n is probably
-prime, if not then n is definitely composite.
-
-   Any prime n will pass the test, but some composites do too.  Such
-composites are known as strong pseudoprimes to base x.  No n is a
-strong pseudoprime to more than 1/4 of all bases (see Knuth exercise
-22), hence with x chosen at random there's no more than a 1/4 chance a
-"probable prime" will in fact be composite.
-
-   In fact strong pseudoprimes are quite rare, making the test much more
-powerful than this analysis would suggest, but 1/4 is all that's proven
-for an arbitrary n.
-
-
-File: gmp.info,  Node: Factorial Algorithm,  Next: Binomial Coefficients Algorithm,  Prev: Prime Testing Algorithm,  Up: Other Algorithms
-
-16.7.2 Factorial
-----------------
-
-Factorials are calculated by a combination of removal of twos,
-powering, and binary splitting.  The procedure can be best illustrated
-with an example,
-
-     23! = 1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23
-
-has factors of two removed,
-
-     23! = 2^19.1.1.3.1.5.3.7.1.9.5.11.3.13.7.15.1.17.9.19.5.21.11.23
-
-and the resulting terms collected up according to their multiplicity,
-
-     23! = 2^19.(3.5)^3.(7.9.11)^2.(13.15.17.19.21.23)
-
-   Each sequence such as 13.15.17.19.21.23 is evaluated by splitting
-into every second term, as for instance (13.17.21).(15.19.23), and the
-same recursively on each half.  This is implemented iteratively using
-some bit twiddling.
-
-   Such splitting is more efficient than repeated Nx1 multiplies since
-it forms big multiplies, allowing Karatsuba and higher algorithms to be
-used.  And even below the Karatsuba threshold a big block of work can
-be more efficient for the basecase algorithm.
-
-   Splitting into subsequences of every second term keeps the resulting
-products more nearly equal in size than would the simpler approach of
-say taking the first half and second half of the sequence.  Nearly
-equal products are more efficient for the current multiply
-implementation.
-
-
-File: gmp.info,  Node: Binomial Coefficients Algorithm,  Next: Fibonacci Numbers Algorithm,  Prev: Factorial Algorithm,  Up: Other Algorithms
-
-16.7.3 Binomial Coefficients
-----------------------------
-
-Binomial coefficients C(n,k) are calculated by first arranging k <= n/2
-using C(n,k) = C(n,n-k) if necessary, and then evaluating the following
-product simply from i=2 to i=k.
-
-                           k  (n-k+i)
-     C(n,k) =  (n-k+1) * prod -------
-                          i=2    i
-
-   It's easy to show that each denominator i will divide the product so
-far, so the exact division algorithm is used (*note Exact Division::).
-
-   The numerators n-k+i and denominators i are first accumulated into
-as many fit a limb, to save multi-precision operations, though for
-`mpz_bin_ui' this applies only to the divisors, since n is an `mpz_t'
-and n-k+i in general won't fit in a limb at all.
-
-
-File: gmp.info,  Node: Fibonacci Numbers Algorithm,  Next: Lucas Numbers Algorithm,  Prev: Binomial Coefficients Algorithm,  Up: Other Algorithms
-
-16.7.4 Fibonacci Numbers
-------------------------
-
-The Fibonacci functions `mpz_fib_ui' and `mpz_fib2_ui' are designed for
-calculating isolated F[n] or F[n],F[n-1] values efficiently.
-
-   For small n, a table of single limb values in `__gmp_fib_table' is
-used.  On a 32-bit limb this goes up to F[47], or on a 64-bit limb up
-to F[93].  For convenience the table starts at F[-1].
-
-   Beyond the table, values are generated with a binary powering
-algorithm, calculating a pair F[n] and F[n-1] working from high to low
-across the bits of n.  The formulas used are
-
-     F[2k+1] = 4*F[k]^2 - F[k-1]^2 + 2*(-1)^k
-     F[2k-1] =   F[k]^2 + F[k-1]^2
-
-     F[2k] = F[2k+1] - F[2k-1]
-
-   At each step, k is the high b bits of n.  If the next bit of n is 0
-then F[2k],F[2k-1] is used, or if it's a 1 then F[2k+1],F[2k] is used,
-and the process repeated until all bits of n are incorporated.  Notice
-these formulas require just two squares per bit of n.
-
-   It'd be possible to handle the first few n above the single limb
-table with simple additions, using the defining Fibonacci recurrence
-F[k+1]=F[k]+F[k-1], but this is not done since it usually turns out to
-be faster for only about 10 or 20 values of n, and including a block of
-code for just those doesn't seem worthwhile.  If they really mattered
-it'd be better to extend the data table.
-
-   Using a table avoids lots of calculations on small numbers, and
-makes small n go fast.  A bigger table would make more small n go fast,
-it's just a question of balancing size against desired speed.  For GMP
-the code is kept compact, with the emphasis primarily on a good
-powering algorithm.
-
-   `mpz_fib2_ui' returns both F[n] and F[n-1], but `mpz_fib_ui' is only
-interested in F[n].  In this case the last step of the algorithm can
-become one multiply instead of two squares.  One of the following two
-formulas is used, according as n is odd or even.
-
-     F[2k]   = F[k]*(F[k]+2F[k-1])
-
-     F[2k+1] = (2F[k]+F[k-1])*(2F[k]-F[k-1]) + 2*(-1)^k
-
-   F[2k+1] here is the same as above, just rearranged to be a multiply.
-For interest, the 2*(-1)^k term both here and above can be applied
-just to the low limb of the calculation, without a carry or borrow into
-further limbs, which saves some code size.  See comments with
-`mpz_fib_ui' and the internal `mpn_fib2_ui' for how this is done.
-
-
-File: gmp.info,  Node: Lucas Numbers Algorithm,  Next: Random Number Algorithms,  Prev: Fibonacci Numbers Algorithm,  Up: Other Algorithms
-
-16.7.5 Lucas Numbers
---------------------
-
-`mpz_lucnum2_ui' derives a pair of Lucas numbers from a pair of
-Fibonacci numbers with the following simple formulas.
-
-     L[k]   =   F[k] + 2*F[k-1]
-     L[k-1] = 2*F[k] -   F[k-1]
-
-   `mpz_lucnum_ui' is only interested in L[n], and some work can be
-saved.  Trailing zero bits on n can be handled with a single square
-each.
-
-     L[2k] = L[k]^2 - 2*(-1)^k
-
-   And the lowest 1 bit can be handled with one multiply of a pair of
-Fibonacci numbers, similar to what `mpz_fib_ui' does.
-
-     L[2k+1] = 5*F[k-1]*(2*F[k]+F[k-1]) - 4*(-1)^k
-
-
-File: gmp.info,  Node: Random Number Algorithms,  Prev: Lucas Numbers Algorithm,  Up: Other Algorithms
-
-16.7.6 Random Numbers
----------------------
-
-For the `urandomb' functions, random numbers are generated simply by
-concatenating bits produced by the generator.  As long as the generator
-has good randomness properties this will produce well-distributed N bit
-numbers.
-
-   For the `urandomm' functions, random numbers in a range 0<=R<N are
-generated by taking values R of ceil(log2(N)) bits each until one
-satisfies R<N.  This will normally require only one or two attempts,
-but the attempts are limited in case the generator is somehow
-degenerate and produces only 1 bits or similar.
-
-   The Mersenne Twister generator is by Matsumoto and Nishimura (*note
-References::).  It has a non-repeating period of 2^19937-1, which is a
-Mersenne prime, hence the name of the generator.  The state is 624
-words of 32-bits each, which is iterated with one XOR and shift for each
-32-bit word generated, making the algorithm very fast.  Randomness
-properties are also very good and this is the default algorithm used by
-GMP.
-
-   Linear congruential generators are described in many text books, for
-instance Knuth volume 2 (*note References::).  With a modulus M and
-parameters A and C, a integer state S is iterated by the formula S <-
-A*S+C mod M.  At each step the new state is a linear function of the
-previous, mod M, hence the name of the generator.
-
-   In GMP only moduli of the form 2^N are supported, and the current
-implementation is not as well optimized as it could be.  Overheads are
-significant when N is small, and when N is large clearly the multiply
-at each step will become slow.  This is not a big concern, since the
-Mersenne Twister generator is better in every respect and is therefore
-recommended for all normal applications.
-
-   For both generators the current state can be deduced by observing
-enough output and applying some linear algebra (over GF(2) in the case
-of the Mersenne Twister).  This generally means raw output is
-unsuitable for cryptographic applications without further hashing or
-the like.
-
-
-File: gmp.info,  Node: Assembly Coding,  Prev: Other Algorithms,  Up: Algorithms
-
-16.8 Assembly Coding
-====================
-
-The assembly subroutines in GMP are the most significant source of
-speed at small to moderate sizes.  At larger sizes algorithm selection
-becomes more important, but of course speedups in low level routines
-will still speed up everything proportionally.
-
-   Carry handling and widening multiplies that are important for GMP
-can't be easily expressed in C.  GCC `asm' blocks help a lot and are
-provided in `longlong.h', but hand coding low level routines invariably
-offers a speedup over generic C by a factor of anything from 2 to 10.
-
-* Menu:
-
-* Assembly Code Organisation::
-* Assembly Basics::
-* Assembly Carry Propagation::
-* Assembly Cache Handling::
-* Assembly Functional Units::
-* Assembly Floating Point::
-* Assembly SIMD Instructions::
-* Assembly Software Pipelining::
-* Assembly Loop Unrolling::
-* Assembly Writing Guide::
-
-
-File: gmp.info,  Node: Assembly Code Organisation,  Next: Assembly Basics,  Prev: Assembly Coding,  Up: Assembly Coding
-
-16.8.1 Code Organisation
-------------------------
-
-The various `mpn' subdirectories contain machine-dependent code, written
-in C or assembly.  The `mpn/generic' subdirectory contains default code,
-used when there's no machine-specific version of a particular file.
-
-   Each `mpn' subdirectory is for an ISA family.  Generally 32-bit and
-64-bit variants in a family cannot share code and have separate
-directories.  Within a family further subdirectories may exist for CPU
-variants.
-
-   In each directory a `nails' subdirectory may exist, holding code with
-nails support for that CPU variant.  A `NAILS_SUPPORT' directive in each
-file indicates the nails values the code handles.  Nails code only
-exists where it's faster, or promises to be faster, than plain code.
-There's no effort put into nails if they're not going to enhance a
-given CPU.
-
-
-File: gmp.info,  Node: Assembly Basics,  Next: Assembly Carry Propagation,  Prev: Assembly Code Organisation,  Up: Assembly Coding
-
-16.8.2 Assembly Basics
-----------------------
-
-`mpn_addmul_1' and `mpn_submul_1' are the most important routines for
-overall GMP performance.  All multiplications and divisions come down to
-repeated calls to these.  `mpn_add_n', `mpn_sub_n', `mpn_lshift' and
-`mpn_rshift' are next most important.
-
-   On some CPUs assembly versions of the internal functions
-`mpn_mul_basecase' and `mpn_sqr_basecase' give significant speedups,
-mainly through avoiding function call overheads.  They can also
-potentially make better use of a wide superscalar processor, as can
-bigger primitives like `mpn_addmul_2' or `mpn_addmul_4'.
-
-   The restrictions on overlaps between sources and destinations (*note
-Low-level Functions::) are designed to facilitate a variety of
-implementations.  For example, knowing `mpn_add_n' won't have partly
-overlapping sources and destination means reading can be done far ahead
-of writing on superscalar processors, and loops can be vectorized on a
-vector processor, depending on the carry handling.
-
-
-File: gmp.info,  Node: Assembly Carry Propagation,  Next: Assembly Cache Handling,  Prev: Assembly Basics,  Up: Assembly Coding
-
-16.8.3 Carry Propagation
-------------------------
-
-The problem that presents most challenges in GMP is propagating carries
-from one limb to the next.  In functions like `mpn_addmul_1' and
-`mpn_add_n', carries are the only dependencies between limb operations.
-
-   On processors with carry flags, a straightforward CISC style `adc' is
-generally best.  AMD K6 `mpn_addmul_1' however is an example of an
-unusual set of circumstances where a branch works out better.
-
-   On RISC processors generally an add and compare for overflow is
-used.  This sort of thing can be seen in `mpn/generic/aors_n.c'.  Some
-carry propagation schemes require 4 instructions, meaning at least 4
-cycles per limb, but other schemes may use just 1 or 2.  On wide
-superscalar processors performance may be completely determined by the
-number of dependent instructions between carry-in and carry-out for
-each limb.
-
-   On vector processors good use can be made of the fact that a carry
-bit only very rarely propagates more than one limb.  When adding a
-single bit to a limb, there's only a carry out if that limb was
-`0xFF...FF' which on random data will be only 1 in 2^mp_bits_per_limb.
-`mpn/cray/add_n.c' is an example of this, it adds all limbs in
-parallel, adds one set of carry bits in parallel and then only rarely
-needs to fall through to a loop propagating further carries.
-
-   On the x86s, GCC (as of version 2.95.2) doesn't generate
-particularly good code for the RISC style idioms that are necessary to
-handle carry bits in C.  Often conditional jumps are generated where
-`adc' or `sbb' forms would be better.  And so unfortunately almost any
-loop involving carry bits needs to be coded in assembly for best
-results.
-
-
-File: gmp.info,  Node: Assembly Cache Handling,  Next: Assembly Functional Units,  Prev: Assembly Carry Propagation,  Up: Assembly Coding
-
-16.8.4 Cache Handling
----------------------
-
-GMP aims to perform well both on operands that fit entirely in L1 cache
-and those which don't.
-
-   Basic routines like `mpn_add_n' or `mpn_lshift' are often used on
-large operands, so L2 and main memory performance is important for them.
-`mpn_mul_1' and `mpn_addmul_1' are mostly used for multiply and square
-basecases, so L1 performance matters most for them, unless assembly
-versions of `mpn_mul_basecase' and `mpn_sqr_basecase' exist, in which
-case the remaining uses are mostly for larger operands.
-
-   For L2 or main memory operands, memory access times will almost
-certainly be more than the calculation time.  The aim therefore is to
-maximize memory throughput, by starting a load of the next cache line
-while processing the contents of the previous one.  Clearly this is
-only possible if the chip has a lock-up free cache or some sort of
-prefetch instruction.  Most current chips have both these features.
-
-   Prefetching sources combines well with loop unrolling, since a
-prefetch can be initiated once per unrolled loop (or more than once if
-the loop covers more than one cache line).
-
-   On CPUs without write-allocate caches, prefetching destinations will
-ensure individual stores don't go further down the cache hierarchy,
-limiting bandwidth.  Of course for calculations which are slow anyway,
-like `mpn_divrem_1', write-throughs might be fine.
-
-   The distance ahead to prefetch will be determined by memory latency
-versus throughput.  The aim of course is to have data arriving
-continuously, at peak throughput.  Some CPUs have limits on the number
-of fetches or prefetches in progress.
-
-   If a special prefetch instruction doesn't exist then a plain load
-can be used, but in that case care must be taken not to attempt to read
-past the end of an operand, since that might produce a segmentation
-violation.
-
-   Some CPUs or systems have hardware that detects sequential memory
-accesses and initiates suitable cache movements automatically, making
-life easy.
-
-
-File: gmp.info,  Node: Assembly Functional Units,  Next: Assembly Floating Point,  Prev: Assembly Cache Handling,  Up: Assembly Coding
-
-16.8.5 Functional Units
------------------------
-
-When choosing an approach for an assembly loop, consideration is given
-to what operations can execute simultaneously and what throughput can
-thereby be achieved.  In some cases an algorithm can be tweaked to
-accommodate available resources.
-
-   Loop control will generally require a counter and pointer updates,
-costing as much as 5 instructions, plus any delays a branch introduces.
-CPU addressing modes might reduce pointer updates, perhaps by allowing
-just one updating pointer and others expressed as offsets from it, or
-on CISC chips with all addressing done with the loop counter as a
-scaled index.
-
-   The final loop control cost can be amortised by processing several
-limbs in each iteration (*note Assembly Loop Unrolling::).  This at
-least ensures loop control isn't a big fraction the work done.
-
-   Memory throughput is always a limit.  If perhaps only one load or
-one store can be done per cycle then 3 cycles/limb will the top speed
-for "binary" operations like `mpn_add_n', and any code achieving that
-is optimal.
-
-   Integer resources can be freed up by having the loop counter in a
-float register, or by pressing the float units into use for some
-multiplying, perhaps doing every second limb on the float side (*note
-Assembly Floating Point::).
-
-   Float resources can be freed up by doing carry propagation on the
-integer side, or even by doing integer to float conversions in integers
-using bit twiddling.
-
-
-File: gmp.info,  Node: Assembly Floating Point,  Next: Assembly SIMD Instructions,  Prev: Assembly Functional Units,  Up: Assembly Coding
-
-16.8.6 Floating Point
----------------------
-
-Floating point arithmetic is used in GMP for multiplications on CPUs
-with poor integer multipliers.  It's mostly useful for `mpn_mul_1',
-`mpn_addmul_1' and `mpn_submul_1' on 64-bit machines, and
-`mpn_mul_basecase' on both 32-bit and 64-bit machines.
-
-   With IEEE 53-bit double precision floats, integer multiplications
-producing up to 53 bits will give exact results.  Breaking a 64x64
-multiplication into eight 16x32->48 bit pieces is convenient.  With
-some care though six 21x32->53 bit products can be used, if one of the
-lower two 21-bit pieces also uses the sign bit.
-
-   For the `mpn_mul_1' family of functions on a 64-bit machine, the
-invariant single limb is split at the start, into 3 or 4 pieces.
-Inside the loop, the bignum operand is split into 32-bit pieces.  Fast
-conversion of these unsigned 32-bit pieces to floating point is highly
-machine-dependent.  In some cases, reading the data into the integer
-unit, zero-extending to 64-bits, then transferring to the floating
-point unit back via memory is the only option.
-
-   Converting partial products back to 64-bit limbs is usually best
-done as a signed conversion.  Since all values are smaller than 2^53,
-signed and unsigned are the same, but most processors lack unsigned
-conversions.
-
-
-
-   Here is a diagram showing 16x32 bit products for an `mpn_mul_1' or
-`mpn_addmul_1' with a 64-bit limb.  The single limb operand V is split
-into four 16-bit parts.  The multi-limb operand U is split in the loop
-into two 32-bit parts.
-
-                     +---+---+---+---+
-                     |v48|v32|v16|v00|    V operand
-                     +---+---+---+---+
-
-                     +-------+---+---+
-                 x   |  u32  |  u00  |    U operand (one limb)
-                     +---------------+
-
-     ---------------------------------
-
-                         +-----------+
-                         | u00 x v00 |    p00    48-bit products
-                         +-----------+
-                     +-----------+
-                     | u00 x v16 |        p16
-                     +-----------+
-                 +-----------+
-                 | u00 x v32 |            p32
-                 +-----------+
-             +-----------+
-             | u00 x v48 |                p48
-             +-----------+
-                 +-----------+
-                 | u32 x v00 |            r32
-                 +-----------+
-             +-----------+
-             | u32 x v16 |                r48
-             +-----------+
-         +-----------+
-         | u32 x v32 |                    r64
-         +-----------+
-     +-----------+
-     | u32 x v48 |                        r80
-     +-----------+
-
-   p32 and r32 can be summed using floating-point addition, and
-likewise p48 and r48.  p00 and p16 can be summed with r64 and r80 from
-the previous iteration.
-
-   For each loop then, four 49-bit quantities are transferred to the
-integer unit, aligned as follows,
-
-     |-----64bits----|-----64bits----|
-                        +------------+
-                        | p00 + r64' |    i00
-                        +------------+
-                    +------------+
-                    | p16 + r80' |        i16
-                    +------------+
-                +------------+
-                | p32 + r32  |            i32
-                +------------+
-            +------------+
-            | p48 + r48  |                i48
-            +------------+
-
-   The challenge then is to sum these efficiently and add in a carry
-limb, generating a low 64-bit result limb and a high 33-bit carry limb
-(i48 extends 33 bits into the high half).
-
-
-File: gmp.info,  Node: Assembly SIMD Instructions,  Next: Assembly Software Pipelining,  Prev: Assembly Floating Point,  Up: Assembly Coding
-
-16.8.7 SIMD Instructions
-------------------------
-
-The single-instruction multiple-data support in current microprocessors
-is aimed at signal processing algorithms where each data point can be
-treated more or less independently.  There's generally not much support
-for propagating the sort of carries that arise in GMP.
-
-   SIMD multiplications of say four 16x16 bit multiplies only do as much
-work as one 32x32 from GMP's point of view, and need some shifts and
-adds besides.  But of course if say the SIMD form is fully pipelined
-and uses less instruction decoding then it may still be worthwhile.
-
-   On the x86 chips, MMX has so far found a use in `mpn_rshift' and
-`mpn_lshift', and is used in a special case for 16-bit multipliers in
-the P55 `mpn_mul_1'.  SSE2 is used for Pentium 4 `mpn_mul_1',
-`mpn_addmul_1', and `mpn_submul_1'.
-
-
-File: gmp.info,  Node: Assembly Software Pipelining,  Next: Assembly Loop Unrolling,  Prev: Assembly SIMD Instructions,  Up: Assembly Coding
-
-16.8.8 Software Pipelining
---------------------------
-
-Software pipelining consists of scheduling instructions around the
-branch point in a loop.  For example a loop might issue a load not for
-use in the present iteration but the next, thereby allowing extra
-cycles for the data to arrive from memory.
-
-   Naturally this is wanted only when doing things like loads or
-multiplies that take several cycles to complete, and only where a CPU
-has multiple functional units so that other work can be done in the
-meantime.
-
-   A pipeline with several stages will have a data value in progress at
-each stage and each loop iteration moves them along one stage.  This is
-like juggling.
-
-   If the latency of some instruction is greater than the loop time
-then it will be necessary to unroll, so one register has a result ready
-to use while another (or multiple others) are still in progress.
-(*note Assembly Loop Unrolling::).
-
-
-File: gmp.info,  Node: Assembly Loop Unrolling,  Next: Assembly Writing Guide,  Prev: Assembly Software Pipelining,  Up: Assembly Coding
-
-16.8.9 Loop Unrolling
----------------------
-
-Loop unrolling consists of replicating code so that several limbs are
-processed in each loop.  At a minimum this reduces loop overheads by a
-corresponding factor, but it can also allow better register usage, for
-example alternately using one register combination and then another.
-Judicious use of `m4' macros can help avoid lots of duplication in the
-source code.
-
-   Any amount of unrolling can be handled with a loop counter that's
-decremented by N each time, stopping when the remaining count is less
-than the further N the loop will process.  Or by subtracting N at the
-start, the termination condition becomes when the counter C is less
-than 0 (and the count of remaining limbs is C+N).
-
-   Alternately for a power of 2 unroll the loop count and remainder can
-be established with a shift and mask.  This is convenient if also
-making a computed jump into the middle of a large loop.
-
-   The limbs not a multiple of the unrolling can be handled in various
-ways, for example
-
-   * A simple loop at the end (or the start) to process the excess.
-     Care will be wanted that it isn't too much slower than the
-     unrolled part.
-
-   * A set of binary tests, for example after an 8-limb unrolling, test
-     for 4 more limbs to process, then a further 2 more or not, and
-     finally 1 more or not.  This will probably take more code space
-     than a simple loop.
-
-   * A `switch' statement, providing separate code for each possible
-     excess, for example an 8-limb unrolling would have separate code
-     for 0 remaining, 1 remaining, etc, up to 7 remaining.  This might
-     take a lot of code, but may be the best way to optimize all cases
-     in combination with a deep pipelined loop.
-
-   * A computed jump into the middle of the loop, thus making the first
-     iteration handle the excess.  This should make times smoothly
-     increase with size, which is attractive, but setups for the jump
-     and adjustments for pointers can be tricky and could become quite
-     difficult in combination with deep pipelining.
-
-
-File: gmp.info,  Node: Assembly Writing Guide,  Prev: Assembly Loop Unrolling,  Up: Assembly Coding
-
-16.8.10 Writing Guide
----------------------
-
-This is a guide to writing software pipelined loops for processing limb
-vectors in assembly.
-
-   First determine the algorithm and which instructions are needed.
-Code it without unrolling or scheduling, to make sure it works.  On a
-3-operand CPU try to write each new value to a new register, this will
-greatly simplify later steps.
-
-   Then note for each instruction the functional unit and/or issue port
-requirements.  If an instruction can use either of two units, like U0
-or U1 then make a category "U0/U1".  Count the total using each unit
-(or combined unit), and count all instructions.
-
-   Figure out from those counts the best possible loop time.  The goal
-will be to find a perfect schedule where instruction latencies are
-completely hidden.  The total instruction count might be the limiting
-factor, or perhaps a particular functional unit.  It might be possible
-to tweak the instructions to help the limiting factor.
-
-   Suppose the loop time is N, then make N issue buckets, with the
-final loop branch at the end of the last.  Now fill the buckets with
-dummy instructions using the functional units desired.  Run this to
-make sure the intended speed is reached.
-
-   Now replace the dummy instructions with the real instructions from
-the slow but correct loop you started with.  The first will typically
-be a load instruction.  Then the instruction using that value is placed
-in a bucket an appropriate distance down.  Run the loop again, to check
-it still runs at target speed.
-
-   Keep placing instructions, frequently measuring the loop.  After a
-few you will need to wrap around from the last bucket back to the top
-of the loop.  If you used the new-register for new-value strategy above
-then there will be no register conflicts.  If not then take care not to
-clobber something already in use.  Changing registers at this time is
-very error prone.
-
-   The loop will overlap two or more of the original loop iterations,
-and the computation of one vector element result will be started in one
-iteration of the new loop, and completed one or several iterations
-later.
-
-   The final step is to create feed-in and wind-down code for the loop.
-A good way to do this is to make a copy (or copies) of the loop at the
-start and delete those instructions which don't have valid antecedents,
-and at the end replicate and delete those whose results are unwanted
-(including any further loads).
-
-   The loop will have a minimum number of limbs loaded and processed,
-so the feed-in code must test if the request size is smaller and skip
-either to a suitable part of the wind-down or to special code for small
-sizes.
-
-
-File: gmp.info,  Node: Internals,  Next: Contributors,  Prev: Algorithms,  Up: Top
-
-17 Internals
-************
-
-*This chapter is provided only for informational purposes and the
-various internals described here may change in future GMP releases.
-Applications expecting to be compatible with future releases should use
-only the documented interfaces described in previous chapters.*
-
-* Menu:
-
-* Integer Internals::
-* Rational Internals::
-* Float Internals::
-* Raw Output Internals::
-* C++ Interface Internals::
-
-
-File: gmp.info,  Node: Integer Internals,  Next: Rational Internals,  Prev: Internals,  Up: Internals
-
-17.1 Integer Internals
-======================
-
-`mpz_t' variables represent integers using sign and magnitude, in space
-dynamically allocated and reallocated.  The fields are as follows.
-
-`_mp_size'
-     The number of limbs, or the negative of that when representing a
-     negative integer.  Zero is represented by `_mp_size' set to zero,
-     in which case the `_mp_d' data is unused.
-
-`_mp_d'
-     A pointer to an array of limbs which is the magnitude.  These are
-     stored "little endian" as per the `mpn' functions, so `_mp_d[0]'
-     is the least significant limb and `_mp_d[ABS(_mp_size)-1]' is the
-     most significant.  Whenever `_mp_size' is non-zero, the most
-     significant limb is non-zero.
-
-     Currently there's always at least one limb allocated, so for
-     instance `mpz_set_ui' never needs to reallocate, and `mpz_get_ui'
-     can fetch `_mp_d[0]' unconditionally (though its value is then
-     only wanted if `_mp_size' is non-zero).
-
-`_mp_alloc'
-     `_mp_alloc' is the number of limbs currently allocated at `_mp_d',
-     and naturally `_mp_alloc >= ABS(_mp_size)'.  When an `mpz' routine
-     is about to (or might be about to) increase `_mp_size', it checks
-     `_mp_alloc' to see whether there's enough space, and reallocates
-     if not.  `MPZ_REALLOC' is generally used for this.
-
-   The various bitwise logical functions like `mpz_and' behave as if
-negative values were twos complement.  But sign and magnitude is always
-used internally, and necessary adjustments are made during the
-calculations.  Sometimes this isn't pretty, but sign and magnitude are
-best for other routines.
-
-   Some internal temporary variables are setup with `MPZ_TMP_INIT' and
-these have `_mp_d' space obtained from `TMP_ALLOC' rather than the
-memory allocation functions.  Care is taken to ensure that these are
-big enough that no reallocation is necessary (since it would have
-unpredictable consequences).
-
-   `_mp_size' and `_mp_alloc' are `int', although `mp_size_t' is
-usually a `long'.  This is done to make the fields just 32 bits on some
-64 bits systems, thereby saving a few bytes of data space but still
-providing plenty of range.
-
-
-File: gmp.info,  Node: Rational Internals,  Next: Float Internals,  Prev: Integer Internals,  Up: Internals
-
-17.2 Rational Internals
-=======================
-
-`mpq_t' variables represent rationals using an `mpz_t' numerator and
-denominator (*note Integer Internals::).
-
-   The canonical form adopted is denominator positive (and non-zero),
-no common factors between numerator and denominator, and zero uniquely
-represented as 0/1.
-
-   It's believed that casting out common factors at each stage of a
-calculation is best in general.  A GCD is an O(N^2) operation so it's
-better to do a few small ones immediately than to delay and have to do
-a big one later.  Knowing the numerator and denominator have no common
-factors can be used for example in `mpq_mul' to make only two cross
-GCDs necessary, not four.
-
-   This general approach to common factors is badly sub-optimal in the
-presence of simple factorizations or little prospect for cancellation,
-but GMP has no way to know when this will occur.  As per *Note
-Efficiency::, that's left to applications.  The `mpq_t' framework might
-still suit, with `mpq_numref' and `mpq_denref' for direct access to the
-numerator and denominator, or of course `mpz_t' variables can be used
-directly.
-
-
-File: gmp.info,  Node: Float Internals,  Next: Raw Output Internals,  Prev: Rational Internals,  Up: Internals
-
-17.3 Float Internals
-====================
-
-Efficient calculation is the primary aim of GMP floats and the use of
-whole limbs and simple rounding facilitates this.
-
-   `mpf_t' floats have a variable precision mantissa and a single
-machine word signed exponent.  The mantissa is represented using sign
-and magnitude.
-
-        most                   least
-     significant            significant
-        limb                   limb
-
-                                 _mp_d
-      |---- _mp_exp --->           |
-       _____ _____ _____ _____ _____
-      |_____|_____|_____|_____|_____|
-                        . <------------ radix point
-
-       <-------- _mp_size --------->
-
-The fields are as follows.
-
-`_mp_size'
-     The number of limbs currently in use, or the negative of that when
-     representing a negative value.  Zero is represented by `_mp_size'
-     and `_mp_exp' both set to zero, and in that case the `_mp_d' data
-     is unused.  (In the future `_mp_exp' might be undefined when
-     representing zero.)
-
-`_mp_prec'
-     The precision of the mantissa, in limbs.  In any calculation the
-     aim is to produce `_mp_prec' limbs of result (the most significant
-     being non-zero).
-
-`_mp_d'
-     A pointer to the array of limbs which is the absolute value of the
-     mantissa.  These are stored "little endian" as per the `mpn'
-     functions, so `_mp_d[0]' is the least significant limb and
-     `_mp_d[ABS(_mp_size)-1]' the most significant.
-
-     The most significant limb is always non-zero, but there are no
-     other restrictions on its value, in particular the highest 1 bit
-     can be anywhere within the limb.
-
-     `_mp_prec+1' limbs are allocated to `_mp_d', the extra limb being
-     for convenience (see below).  There are no reallocations during a
-     calculation, only in a change of precision with `mpf_set_prec'.
-
-`_mp_exp'
-     The exponent, in limbs, determining the location of the implied
-     radix point.  Zero means the radix point is just above the most
-     significant limb.  Positive values mean a radix point offset
-     towards the lower limbs and hence a value >= 1, as for example in
-     the diagram above.  Negative exponents mean a radix point further
-     above the highest limb.
-
-     Naturally the exponent can be any value, it doesn't have to fall
-     within the limbs as the diagram shows, it can be a long way above
-     or a long way below.  Limbs other than those included in the
-     `{_mp_d,_mp_size}' data are treated as zero.
-
-   The `_mp_size' and `_mp_prec' fields are `int', although the
-`mp_size_t' type is usually a `long'.  The `_mp_exp' field is usually
-`long'.  This is done to make some fields just 32 bits on some 64 bits
-systems, thereby saving a few bytes of data space but still providing
-plenty of precision and a very large range.
-
-
-The following various points should be noted.
-
-Low Zeros
-     The least significant limbs `_mp_d[0]' etc can be zero, though
-     such low zeros can always be ignored.  Routines likely to produce
-     low zeros check and avoid them to save time in subsequent
-     calculations, but for most routines they're quite unlikely and
-     aren't checked.
-
-Mantissa Size Range
-     The `_mp_size' count of limbs in use can be less than `_mp_prec' if
-     the value can be represented in less.  This means low precision
-     values or small integers stored in a high precision `mpf_t' can
-     still be operated on efficiently.
-
-     `_mp_size' can also be greater than `_mp_prec'.  Firstly a value is
-     allowed to use all of the `_mp_prec+1' limbs available at `_mp_d',
-     and secondly when `mpf_set_prec_raw' lowers `_mp_prec' it leaves
-     `_mp_size' unchanged and so the size can be arbitrarily bigger than
-     `_mp_prec'.
-
-Rounding
-     All rounding is done on limb boundaries.  Calculating `_mp_prec'
-     limbs with the high non-zero will ensure the application requested
-     minimum precision is obtained.
-
-     The use of simple "trunc" rounding towards zero is efficient,
-     since there's no need to examine extra limbs and increment or
-     decrement.
-
-Bit Shifts
-     Since the exponent is in limbs, there are no bit shifts in basic
-     operations like `mpf_add' and `mpf_mul'.  When differing exponents
-     are encountered all that's needed is to adjust pointers to line up
-     the relevant limbs.
-
-     Of course `mpf_mul_2exp' and `mpf_div_2exp' will require bit
-     shifts, but the choice is between an exponent in limbs which
-     requires shifts there, or one in bits which requires them almost
-     everywhere else.
-
-Use of `_mp_prec+1' Limbs
-     The extra limb on `_mp_d' (`_mp_prec+1' rather than just
-     `_mp_prec') helps when an `mpf' routine might get a carry from its
-     operation.  `mpf_add' for instance will do an `mpn_add' of
-     `_mp_prec' limbs.  If there's no carry then that's the result, but
-     if there is a carry then it's stored in the extra limb of space and
-     `_mp_size' becomes `_mp_prec+1'.
-
-     Whenever `_mp_prec+1' limbs are held in a variable, the low limb
-     is not needed for the intended precision, only the `_mp_prec' high
-     limbs.  But zeroing it out or moving the rest down is unnecessary.
-     Subsequent routines reading the value will simply take the high
-     limbs they need, and this will be `_mp_prec' if their target has
-     that same precision.  This is no more than a pointer adjustment,
-     and must be checked anyway since the destination precision can be
-     different from the sources.
-
-     Copy functions like `mpf_set' will retain a full `_mp_prec+1' limbs
-     if available.  This ensures that a variable which has `_mp_size'
-     equal to `_mp_prec+1' will get its full exact value copied.
-     Strictly speaking this is unnecessary since only `_mp_prec' limbs
-     are needed for the application's requested precision, but it's
-     considered that an `mpf_set' from one variable into another of the
-     same precision ought to produce an exact copy.
-
-Application Precisions
-     `__GMPF_BITS_TO_PREC' converts an application requested precision
-     to an `_mp_prec'.  The value in bits is rounded up to a whole limb
-     then an extra limb is added since the most significant limb of
-     `_mp_d' is only non-zero and therefore might contain only one bit.
-
-     `__GMPF_PREC_TO_BITS' does the reverse conversion, and removes the
-     extra limb from `_mp_prec' before converting to bits.  The net
-     effect of reading back with `mpf_get_prec' is simply the precision
-     rounded up to a multiple of `mp_bits_per_limb'.
-
-     Note that the extra limb added here for the high only being
-     non-zero is in addition to the extra limb allocated to `_mp_d'.
-     For example with a 32-bit limb, an application request for 250
-     bits will be rounded up to 8 limbs, then an extra added for the
-     high being only non-zero, giving an `_mp_prec' of 9.  `_mp_d' then
-     gets 10 limbs allocated.  Reading back with `mpf_get_prec' will
-     take `_mp_prec' subtract 1 limb and multiply by 32, giving 256
-     bits.
-
-     Strictly speaking, the fact the high limb has at least one bit
-     means that a float with, say, 3 limbs of 32-bits each will be
-     holding at least 65 bits, but for the purposes of `mpf_t' it's
-     considered simply to be 64 bits, a nice multiple of the limb size.
-
-
-File: gmp.info,  Node: Raw Output Internals,  Next: C++ Interface Internals,  Prev: Float Internals,  Up: Internals
-
-17.4 Raw Output Internals
-=========================
-
-`mpz_out_raw' uses the following format.
-
-     +------+------------------------+
-     | size |       data bytes       |
-     +------+------------------------+
-
-   The size is 4 bytes written most significant byte first, being the
-number of subsequent data bytes, or the twos complement negative of
-that when a negative integer is represented.  The data bytes are the
-absolute value of the integer, written most significant byte first.
-
-   The most significant data byte is always non-zero, so the output is
-the same on all systems, irrespective of limb size.
-
-   In GMP 1, leading zero bytes were written to pad the data bytes to a
-multiple of the limb size.  `mpz_inp_raw' will still accept this, for
-compatibility.
-
-   The use of "big endian" for both the size and data fields is
-deliberate, it makes the data easy to read in a hex dump of a file.
-Unfortunately it also means that the limb data must be reversed when
-reading or writing, so neither a big endian nor little endian system
-can just read and write `_mp_d'.
-
-
-File: gmp.info,  Node: C++ Interface Internals,  Prev: Raw Output Internals,  Up: Internals
-
-17.5 C++ Interface Internals
-============================
-
-A system of expression templates is used to ensure something like
-`a=b+c' turns into a simple call to `mpz_add' etc.  For `mpf_class' the
-scheme also ensures the precision of the final destination is used for
-any temporaries within a statement like `f=w*x+y*z'.  These are
-important features which a naive implementation cannot provide.
-
-   A simplified description of the scheme follows.  The true scheme is
-complicated by the fact that expressions have different return types.
-For detailed information, refer to the source code.
-
-   To perform an operation, say, addition, we first define a "function
-object" evaluating it,
-
-     struct __gmp_binary_plus
-     {
-       static void eval(mpf_t f, mpf_t g, mpf_t h) { mpf_add(f, g, h); }
-     };
-
-And an "additive expression" object,
-
-     __gmp_expr<__gmp_binary_expr<mpf_class, mpf_class, __gmp_binary_plus> >
-     operator+(const mpf_class &f, const mpf_class &g)
-     {
-       return __gmp_expr
-         <__gmp_binary_expr<mpf_class, mpf_class, __gmp_binary_plus> >(f, g);
-     }
-
-   The seemingly redundant `__gmp_expr<__gmp_binary_expr<...>>' is used
-to encapsulate any possible kind of expression into a single template
-type.  In fact even `mpf_class' etc are `typedef' specializations of
-`__gmp_expr'.
-
-   Next we define assignment of `__gmp_expr' to `mpf_class'.
-
-     template <class T>
-     mpf_class & mpf_class::operator=(const __gmp_expr<T> &expr)
-     {
-       expr.eval(this->get_mpf_t(), this->precision());
-       return *this;
-     }
-
-     template <class Op>
-     void __gmp_expr<__gmp_binary_expr<mpf_class, mpf_class, Op> >::eval
-     (mpf_t f, mp_bitcnt_t precision)
-     {
-       Op::eval(f, expr.val1.get_mpf_t(), expr.val2.get_mpf_t());
-     }
-
-   where `expr.val1' and `expr.val2' are references to the expression's
-operands (here `expr' is the `__gmp_binary_expr' stored within the
-`__gmp_expr').
-
-   This way, the expression is actually evaluated only at the time of
-assignment, when the required precision (that of `f') is known.
-Furthermore the target `mpf_t' is now available, thus we can call
-`mpf_add' directly with `f' as the output argument.
-
-   Compound expressions are handled by defining operators taking
-subexpressions as their arguments, like this:
-
-     template <class T, class U>
-     __gmp_expr
-     <__gmp_binary_expr<__gmp_expr<T>, __gmp_expr<U>, __gmp_binary_plus> >
-     operator+(const __gmp_expr<T> &expr1, const __gmp_expr<U> &expr2)
-     {
-       return __gmp_expr
-         <__gmp_binary_expr<__gmp_expr<T>, __gmp_expr<U>, __gmp_binary_plus> >
-         (expr1, expr2);
-     }
-
-   And the corresponding specializations of `__gmp_expr::eval':
-
-     template <class T, class U, class Op>
-     void __gmp_expr
-     <__gmp_binary_expr<__gmp_expr<T>, __gmp_expr<U>, Op> >::eval
-     (mpf_t f, mp_bitcnt_t precision)
-     {
-       // declare two temporaries
-       mpf_class temp1(expr.val1, precision), temp2(expr.val2, precision);
-       Op::eval(f, temp1.get_mpf_t(), temp2.get_mpf_t());
-     }
-
-   The expression is thus recursively evaluated to any level of
-complexity and all subexpressions are evaluated to the precision of `f'.
-
-
-File: gmp.info,  Node: Contributors,  Next: References,  Prev: Internals,  Up: Top
-
-Appendix A Contributors
-***********************
-
-Torbjo"rn Granlund wrote the original GMP library and is still the main
-developer.  Code not explicitly attributed to others, was contributed by
-Torbjo"rn.  Several other individuals and organizations have contributed
-GMP.  Here is a list in chronological order on first contribution:
-
-   Gunnar Sjo"din and Hans Riesel helped with mathematical problems in
-early versions of the library.
-
-   Richard Stallman helped with the interface design and revised the
-first version of this manual.
-
-   Brian Beuning and Doug Lea helped with testing of early versions of
-the library and made creative suggestions.
-
-   John Amanatides of York University in Canada contributed the function
-`mpz_probab_prime_p'.
-
-   Paul Zimmermann wrote the REDC-based mpz_powm code, the
-Scho"nhage-Strassen FFT multiply code, and the Karatsuba square root
-code.  He also improved the Toom3 code for GMP 4.2.  Paul sparked the
-development of GMP 2, with his comparisons between bignum packages.
-The ECMNET project Paul is organizing was a driving force behind many
-of the optimizations in GMP 3.  Paul also wrote the new GMP 4.3 nth
-root code (with Torbjo"rn).
-
-   Ken Weber (Kent State University, Universidade Federal do Rio Grande
-do Sul) contributed now defunct versions of `mpz_gcd', `mpz_divexact',
-`mpn_gcd', and `mpn_bdivmod', partially supported by CNPq (Brazil)
-grant 301314194-2.
-
-   Per Bothner of Cygnus Support helped to set up GMP to use Cygnus'
-configure.  He has also made valuable suggestions and tested numerous
-intermediary releases.
-
-   Joachim Hollman was involved in the design of the `mpf' interface,
-and in the `mpz' design revisions for version 2.
-
-   Bennet Yee contributed the initial versions of `mpz_jacobi' and
-`mpz_legendre'.
-
-   Andreas Schwab contributed the files `mpn/m68k/lshift.S' and
-`mpn/m68k/rshift.S' (now in `.asm' form).
-
-   Robert Harley of Inria, France and David Seal of ARM, England,
-suggested clever improvements for population count.  Robert also wrote
-highly optimized Karatsuba and 3-way Toom multiplication functions for
-GMP 3, and contributed the ARM assembly code.
-
-   Torsten Ekedahl of the Mathematical department of Stockholm
-University provided significant inspiration during several phases of
-the GMP development.  His mathematical expertise helped improve several
-algorithms.
-
-   Linus Nordberg wrote the new configure system based on autoconf and
-implemented the new random functions.
-
-   Kevin Ryde worked on a large number of things: optimized x86 code,
-m4 asm macros, parameter tuning, speed measuring, the configure system,
-function inlining, divisibility tests, bit scanning, Jacobi symbols,
-Fibonacci and Lucas number functions, printf and scanf functions, perl
-interface, demo expression parser, the algorithms chapter in the
-manual, `gmpasm-mode.el', and various miscellaneous improvements
-elsewhere.
-
-   Kent Boortz made the Mac OS 9 port.
-
-   Steve Root helped write the optimized alpha 21264 assembly code.
-
-   Gerardo Ballabio wrote the `gmpxx.h' C++ class interface and the C++
-`istream' input routines.
-
-   Jason Moxham rewrote `mpz_fac_ui'.
-
-   Pedro Gimeno implemented the Mersenne Twister and made other random
-number improvements.
-
-   Niels Mo"ller wrote the sub-quadratic GCD and extended GCD code, the
-quadratic Hensel division code, and (with Torbjo"rn) the new divide and
-conquer division code for GMP 4.3.  Niels also helped implement the new
-Toom multiply code for GMP 4.3 and implemented helper functions to
-simplify Toom evaluations for GMP 5.0.  He wrote the original version
-of mpn_mulmod_bnm1.
-
-   Alberto Zanoni and Marco Bodrato suggested the unbalanced multiply
-strategy, and found the optimal strategies for evaluation and
-interpolation in Toom multiplication.
-
-   Marco Bodrato helped implement the new Toom multiply code for GMP
-4.3 and implemented most of the new Toom multiply and squaring code for
-5.0.  He is the main author of the current mpn_mulmod_bnm1 and
-mpn_mullo_n.  Marco also wrote the functions mpn_invert and
-mpn_invertappr.
-
-   David Harvey suggested the internal function `mpn_bdiv_dbm1',
-implementing division relevant to Toom multiplication.  He also worked
-on fast assembly sequences, in particular on a fast AMD64
-`mpn_mul_basecase'.
-
-   Martin Boij wrote `mpn_perfect_power_p'.
-
-   (This list is chronological, not ordered after significance.  If you
-have contributed to GMP but are not listed above, please tell
-<gmp-devel@gmplib.org> about the omission!)
-
-   The development of floating point functions of GNU MP 2, were
-supported in part by the ESPRIT-BRA (Basic Research Activities) 6846
-project POSSO (POlynomial System SOlving).
-
-   The development of GMP 2, 3, and 4 was supported in part by the IDA
-Center for Computing Sciences.
-
-   Thanks go to Hans Thorsen for donating an SGI system for the GMP
-test system environment.
-
-
-File: gmp.info,  Node: References,  Next: GNU Free Documentation License,  Prev: Contributors,  Up: Top
-
-Appendix B References
-*********************
-
-B.1 Books
-=========
-
-   * Jonathan M. Borwein and Peter B. Borwein, "Pi and the AGM: A Study
-     in Analytic Number Theory and Computational Complexity", Wiley,
-     1998.
-
-   * Richard Crandall and Carl Pomerance, "Prime Numbers: A
-     Computational Perspective", 2nd edition, Springer-Verlag, 2005.
-     `http://math.dartmouth.edu/~carlp/'
-
-   * Henri Cohen, "A Course in Computational Algebraic Number Theory",
-     Graduate Texts in Mathematics number 138, Springer-Verlag, 1993.
-     `http://www.math.u-bordeaux.fr/~cohen/'
-
-   * Donald E. Knuth, "The Art of Computer Programming", volume 2,
-     "Seminumerical Algorithms", 3rd edition, Addison-Wesley, 1998.
-     `http://www-cs-faculty.stanford.edu/~knuth/taocp.html'
-
-   * John D. Lipson, "Elements of Algebra and Algebraic Computing", The
-     Benjamin Cummings Publishing Company Inc, 1981.
-
-   * Alfred J. Menezes, Paul C. van Oorschot and Scott A. Vanstone,
-     "Handbook of Applied Cryptography",
-     `http://www.cacr.math.uwaterloo.ca/hac/'
-
-   * Richard M. Stallman and the GCC Developer Community, "Using the
-     GNU Compiler Collection", Free Software Foundation, 2008,
-     available online `http://gcc.gnu.org/onlinedocs/', and in the GCC
-     package `ftp://ftp.gnu.org/gnu/gcc/'
-
-B.2 Papers
-==========
-
-   * Yves Bertot, Nicolas Magaud and Paul Zimmermann, "A Proof of GMP
-     Square Root", Journal of Automated Reasoning, volume 29, 2002, pp.
-     225-252.  Also available online as INRIA Research Report 4475,
-     June 2001, `http://www.inria.fr/rrrt/rr-4475.html'
-
-   * Christoph Burnikel and Joachim Ziegler, "Fast Recursive Division",
-     Max-Planck-Institut fuer Informatik Research Report MPI-I-98-1-022,
-     `http://data.mpi-sb.mpg.de/internet/reports.nsf/NumberView/1998-1-022'
-
-   * Torbjo"rn Granlund and Peter L. Montgomery, "Division by Invariant
-     Integers using Multiplication", in Proceedings of the SIGPLAN
-     PLDI'94 Conference, June 1994.  Also available
-     `ftp://ftp.cwi.nl/pub/pmontgom/divcnst.psa4.gz' (and .psl.gz).
-
-   * Niels Mo"ller and Torbjo"rn Granlund, "Improved division by
-     invariant integers", IEEE Transactions on Computers, 11 June 2010.
-     `http://gmplib.org/~tege/division-paper.pdf'
-
-   * Torbjo"rn Granlund and Niels Mo"ller, "Division of integers large
-     and small", to appear.
-
-   * Tudor Jebelean, "An algorithm for exact division", Journal of
-     Symbolic Computation, volume 15, 1993, pp. 169-180.  Research
-     report version available
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-35.ps.gz'
-
-   * Tudor Jebelean, "Exact Division with Karatsuba Complexity -
-     Extended Abstract", RISC-Linz technical report 96-31,
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-31.ps.gz'
-
-   * Tudor Jebelean, "Practical Integer Division with Karatsuba
-     Complexity", ISSAC 97, pp. 339-341.  Technical report available
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-29.ps.gz'
-
-   * Tudor Jebelean, "A Generalization of the Binary GCD Algorithm",
-     ISSAC 93, pp. 111-116.  Technical report version available
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1993/93-01.ps.gz'
-
-   * Tudor Jebelean, "A Double-Digit Lehmer-Euclid Algorithm for
-     Finding the GCD of Long Integers", Journal of Symbolic
-     Computation, volume 19, 1995, pp. 145-157.  Technical report
-     version also available
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-69.ps.gz'
-
-   * Werner Krandick and Tudor Jebelean, "Bidirectional Exact Integer
-     Division", Journal of Symbolic Computation, volume 21, 1996, pp.
-     441-455.  Early technical report version also available
-     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1994/94-50.ps.gz'
-
-   * Makoto Matsumoto and Takuji Nishimura, "Mersenne Twister: A
-     623-dimensionally equidistributed uniform pseudorandom number
-     generator", ACM Transactions on Modelling and Computer Simulation,
-     volume 8, January 1998, pp. 3-30.  Available online
-     `http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.ps.gz'
-     (or .pdf)
-
-   * R. Moenck and A. Borodin, "Fast Modular Transforms via Division",
-     Proceedings of the 13th Annual IEEE Symposium on Switching and
-     Automata Theory, October 1972, pp. 90-96.  Reprinted as "Fast
-     Modular Transforms", Journal of Computer and System Sciences,
-     volume 8, number 3, June 1974, pp. 366-386.
-
-   * Niels Mo"ller, "On Scho"nhage's algorithm and subquadratic integer
-     GCD   computation", in Mathematics of Computation, volume 77,
-     January 2008, pp.    589-607.
-
-   * Peter L. Montgomery, "Modular Multiplication Without Trial
-     Division", in Mathematics of Computation, volume 44, number 170,
-     April 1985.
-
-   * Arnold Scho"nhage and Volker Strassen, "Schnelle Multiplikation
-     grosser Zahlen", Computing 7, 1971, pp. 281-292.
-
-   * Kenneth Weber, "The accelerated integer GCD algorithm", ACM
-     Transactions on Mathematical Software, volume 21, number 1, March
-     1995, pp. 111-122.
-
-   * Paul Zimmermann, "Karatsuba Square Root", INRIA Research Report
-     3805, November 1999, `http://www.inria.fr/rrrt/rr-3805.html'
-
-   * Paul Zimmermann, "A Proof of GMP Fast Division and Square Root
-     Implementations",
-     `http://www.loria.fr/~zimmerma/papers/proof-div-sqrt.ps.gz'
-
-   * Dan Zuras, "On Squaring and Multiplying Large Integers", ARITH-11:
-     IEEE Symposium on Computer Arithmetic, 1993, pp. 260 to 271.
-     Reprinted as "More on Multiplying and Squaring Large Integers",
-     IEEE Transactions on Computers, volume 43, number 8, August 1994,
-     pp. 899-908.
-
-
-File: gmp.info,  Node: GNU Free Documentation License,  Next: Concept Index,  Prev: References,  Up: Top
-
-Appendix C GNU Free Documentation License
-*****************************************
-
-                     Version 1.3, 3 November 2008
-
-     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
-     `http://fsf.org/'
-
-     Everyone is permitted to copy and distribute verbatim copies
-     of this license document, but changing it is not allowed.
-
-  0. PREAMBLE
-
-     The purpose of this License is to make a manual, textbook, or other
-     functional and useful document "free" in the sense of freedom: to
-     assure everyone the effective freedom to copy and redistribute it,
-     with or without modifying it, either commercially or
-     noncommercially.  Secondarily, this License preserves for the
-     author and publisher a way to get credit for their work, while not
-     being considered responsible for modifications made by others.
-
-     This License is a kind of "copyleft", which means that derivative
-     works of the document must themselves be free in the same sense.
-     It complements the GNU General Public License, which is a copyleft
-     license designed for free software.
-
-     We have designed this License in order to use it for manuals for
-     free software, because free software needs free documentation: a
-     free program should come with manuals providing the same freedoms
-     that the software does.  But this License is not limited to
-     software manuals; it can be used for any textual work, regardless
-     of subject matter or whether it is published as a printed book.
-     We recommend this License principally for works whose purpose is
-     instruction or reference.
-
-  1. APPLICABILITY AND DEFINITIONS
-
-     This License applies to any manual or other work, in any medium,
-     that contains a notice placed by the copyright holder saying it
-     can be distributed under the terms of this License.  Such a notice
-     grants a world-wide, royalty-free license, unlimited in duration,
-     to use that work under the conditions stated herein.  The
-     "Document", below, refers to any such manual or work.  Any member
-     of the public is a licensee, and is addressed as "you".  You
-     accept the license if you copy, modify or distribute the work in a
-     way requiring permission under copyright law.
-
-     A "Modified Version" of the Document means any work containing the
-     Document or a portion of it, either copied verbatim, or with
-     modifications and/or translated into another language.
-
-     A "Secondary Section" is a named appendix or a front-matter section
-     of the Document that deals exclusively with the relationship of the
-     publishers or authors of the Document to the Document's overall
-     subject (or to related matters) and contains nothing that could
-     fall directly within that overall subject.  (Thus, if the Document
-     is in part a textbook of mathematics, a Secondary Section may not
-     explain any mathematics.)  The relationship could be a matter of
-     historical connection with the subject or with related matters, or
-     of legal, commercial, philosophical, ethical or political position
-     regarding them.
-
-     The "Invariant Sections" are certain Secondary Sections whose
-     titles are designated, as being those of Invariant Sections, in
-     the notice that says that the Document is released under this
-     License.  If a section does not fit the above definition of
-     Secondary then it is not allowed to be designated as Invariant.
-     The Document may contain zero Invariant Sections.  If the Document
-     does not identify any Invariant Sections then there are none.
-
-     The "Cover Texts" are certain short passages of text that are
-     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
-     that says that the Document is released under this License.  A
-     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
-     be at most 25 words.
-
-     A "Transparent" copy of the Document means a machine-readable copy,
-     represented in a format whose specification is available to the
-     general public, that is suitable for revising the document
-     straightforwardly with generic text editors or (for images
-     composed of pixels) generic paint programs or (for drawings) some
-     widely available drawing editor, and that is suitable for input to
-     text formatters or for automatic translation to a variety of
-     formats suitable for input to text formatters.  A copy made in an
-     otherwise Transparent file format whose markup, or absence of
-     markup, has been arranged to thwart or discourage subsequent
-     modification by readers is not Transparent.  An image format is
-     not Transparent if used for any substantial amount of text.  A
-     copy that is not "Transparent" is called "Opaque".
-
-     Examples of suitable formats for Transparent copies include plain
-     ASCII without markup, Texinfo input format, LaTeX input format,
-     SGML or XML using a publicly available DTD, and
-     standard-conforming simple HTML, PostScript or PDF designed for
-     human modification.  Examples of transparent image formats include
-     PNG, XCF and JPG.  Opaque formats include proprietary formats that
-     can be read and edited only by proprietary word processors, SGML or
-     XML for which the DTD and/or processing tools are not generally
-     available, and the machine-generated HTML, PostScript or PDF
-     produced by some word processors for output purposes only.
-
-     The "Title Page" means, for a printed book, the title page itself,
-     plus such following pages as are needed to hold, legibly, the
-     material this License requires to appear in the title page.  For
-     works in formats which do not have any title page as such, "Title
-     Page" means the text near the most prominent appearance of the
-     work's title, preceding the beginning of the body of the text.
-
-     The "publisher" means any person or entity that distributes copies
-     of the Document to the public.
-
-     A section "Entitled XYZ" means a named subunit of the Document
-     whose title either is precisely XYZ or contains XYZ in parentheses
-     following text that translates XYZ in another language.  (Here XYZ
-     stands for a specific section name mentioned below, such as
-     "Acknowledgements", "Dedications", "Endorsements", or "History".)
-     To "Preserve the Title" of such a section when you modify the
-     Document means that it remains a section "Entitled XYZ" according
-     to this definition.
-
-     The Document may include Warranty Disclaimers next to the notice
-     which states that this License applies to the Document.  These
-     Warranty Disclaimers are considered to be included by reference in
-     this License, but only as regards disclaiming warranties: any other
-     implication that these Warranty Disclaimers may have is void and
-     has no effect on the meaning of this License.
-
-  2. VERBATIM COPYING
-
-     You may copy and distribute the Document in any medium, either
-     commercially or noncommercially, provided that this License, the
-     copyright notices, and the license notice saying this License
-     applies to the Document are reproduced in all copies, and that you
-     add no other conditions whatsoever to those of this License.  You
-     may not use technical measures to obstruct or control the reading
-     or further copying of the copies you make or distribute.  However,
-     you may accept compensation in exchange for copies.  If you
-     distribute a large enough number of copies you must also follow
-     the conditions in section 3.
-
-     You may also lend copies, under the same conditions stated above,
-     and you may publicly display copies.
-
-  3. COPYING IN QUANTITY
-
-     If you publish printed copies (or copies in media that commonly
-     have printed covers) of the Document, numbering more than 100, and
-     the Document's license notice requires Cover Texts, you must
-     enclose the copies in covers that carry, clearly and legibly, all
-     these Cover Texts: Front-Cover Texts on the front cover, and
-     Back-Cover Texts on the back cover.  Both covers must also clearly
-     and legibly identify you as the publisher of these copies.  The
-     front cover must present the full title with all words of the
-     title equally prominent and visible.  You may add other material
-     on the covers in addition.  Copying with changes limited to the
-     covers, as long as they preserve the title of the Document and
-     satisfy these conditions, can be treated as verbatim copying in
-     other respects.
-
-     If the required texts for either cover are too voluminous to fit
-     legibly, you should put the first ones listed (as many as fit
-     reasonably) on the actual cover, and continue the rest onto
-     adjacent pages.
-
-     If you publish or distribute Opaque copies of the Document
-     numbering more than 100, you must either include a
-     machine-readable Transparent copy along with each Opaque copy, or
-     state in or with each Opaque copy a computer-network location from
-     which the general network-using public has access to download
-     using public-standard network protocols a complete Transparent
-     copy of the Document, free of added material.  If you use the
-     latter option, you must take reasonably prudent steps, when you
-     begin distribution of Opaque copies in quantity, to ensure that
-     this Transparent copy will remain thus accessible at the stated
-     location until at least one year after the last time you
-     distribute an Opaque copy (directly or through your agents or
-     retailers) of that edition to the public.
-
-     It is requested, but not required, that you contact the authors of
-     the Document well before redistributing any large number of
-     copies, to give them a chance to provide you with an updated
-     version of the Document.
-
-  4. MODIFICATIONS
-
-     You may copy and distribute a Modified Version of the Document
-     under the conditions of sections 2 and 3 above, provided that you
-     release the Modified Version under precisely this License, with
-     the Modified Version filling the role of the Document, thus
-     licensing distribution and modification of the Modified Version to
-     whoever possesses a copy of it.  In addition, you must do these
-     things in the Modified Version:
-
-       A. Use in the Title Page (and on the covers, if any) a title
-          distinct from that of the Document, and from those of
-          previous versions (which should, if there were any, be listed
-          in the History section of the Document).  You may use the
-          same title as a previous version if the original publisher of
-          that version gives permission.
-
-       B. List on the Title Page, as authors, one or more persons or
-          entities responsible for authorship of the modifications in
-          the Modified Version, together with at least five of the
-          principal authors of the Document (all of its principal
-          authors, if it has fewer than five), unless they release you
-          from this requirement.
-
-       C. State on the Title page the name of the publisher of the
-          Modified Version, as the publisher.
-
-       D. Preserve all the copyright notices of the Document.
-
-       E. Add an appropriate copyright notice for your modifications
-          adjacent to the other copyright notices.
-
-       F. Include, immediately after the copyright notices, a license
-          notice giving the public permission to use the Modified
-          Version under the terms of this License, in the form shown in
-          the Addendum below.
-
-       G. Preserve in that license notice the full lists of Invariant
-          Sections and required Cover Texts given in the Document's
-          license notice.
-
-       H. Include an unaltered copy of this License.
-
-       I. Preserve the section Entitled "History", Preserve its Title,
-          and add to it an item stating at least the title, year, new
-          authors, and publisher of the Modified Version as given on
-          the Title Page.  If there is no section Entitled "History" in
-          the Document, create one stating the title, year, authors,
-          and publisher of the Document as given on its Title Page,
-          then add an item describing the Modified Version as stated in
-          the previous sentence.
-
-       J. Preserve the network location, if any, given in the Document
-          for public access to a Transparent copy of the Document, and
-          likewise the network locations given in the Document for
-          previous versions it was based on.  These may be placed in
-          the "History" section.  You may omit a network location for a
-          work that was published at least four years before the
-          Document itself, or if the original publisher of the version
-          it refers to gives permission.
-
-       K. For any section Entitled "Acknowledgements" or "Dedications",
-          Preserve the Title of the section, and preserve in the
-          section all the substance and tone of each of the contributor
-          acknowledgements and/or dedications given therein.
-
-       L. Preserve all the Invariant Sections of the Document,
-          unaltered in their text and in their titles.  Section numbers
-          or the equivalent are not considered part of the section
-          titles.
-
-       M. Delete any section Entitled "Endorsements".  Such a section
-          may not be included in the Modified Version.
-
-       N. Do not retitle any existing section to be Entitled
-          "Endorsements" or to conflict in title with any Invariant
-          Section.
-
-       O. Preserve any Warranty Disclaimers.
-
-     If the Modified Version includes new front-matter sections or
-     appendices that qualify as Secondary Sections and contain no
-     material copied from the Document, you may at your option
-     designate some or all of these sections as invariant.  To do this,
-     add their titles to the list of Invariant Sections in the Modified
-     Version's license notice.  These titles must be distinct from any
-     other section titles.
-
-     You may add a section Entitled "Endorsements", provided it contains
-     nothing but endorsements of your Modified Version by various
-     parties--for example, statements of peer review or that the text
-     has been approved by an organization as the authoritative
-     definition of a standard.
-
-     You may add a passage of up to five words as a Front-Cover Text,
-     and a passage of up to 25 words as a Back-Cover Text, to the end
-     of the list of Cover Texts in the Modified Version.  Only one
-     passage of Front-Cover Text and one of Back-Cover Text may be
-     added by (or through arrangements made by) any one entity.  If the
-     Document already includes a cover text for the same cover,
-     previously added by you or by arrangement made by the same entity
-     you are acting on behalf of, you may not add another; but you may
-     replace the old one, on explicit permission from the previous
-     publisher that added the old one.
-
-     The author(s) and publisher(s) of the Document do not by this
-     License give permission to use their names for publicity for or to
-     assert or imply endorsement of any Modified Version.
-
-  5. COMBINING DOCUMENTS
-
-     You may combine the Document with other documents released under
-     this License, under the terms defined in section 4 above for
-     modified versions, provided that you include in the combination
-     all of the Invariant Sections of all of the original documents,
-     unmodified, and list them all as Invariant Sections of your
-     combined work in its license notice, and that you preserve all
-     their Warranty Disclaimers.
-
-     The combined work need only contain one copy of this License, and
-     multiple identical Invariant Sections may be replaced with a single
-     copy.  If there are multiple Invariant Sections with the same name
-     but different contents, make the title of each such section unique
-     by adding at the end of it, in parentheses, the name of the
-     original author or publisher of that section if known, or else a
-     unique number.  Make the same adjustment to the section titles in
-     the list of Invariant Sections in the license notice of the
-     combined work.
-
-     In the combination, you must combine any sections Entitled
-     "History" in the various original documents, forming one section
-     Entitled "History"; likewise combine any sections Entitled
-     "Acknowledgements", and any sections Entitled "Dedications".  You
-     must delete all sections Entitled "Endorsements."
-
-  6. COLLECTIONS OF DOCUMENTS
-
-     You may make a collection consisting of the Document and other
-     documents released under this License, and replace the individual
-     copies of this License in the various documents with a single copy
-     that is included in the collection, provided that you follow the
-     rules of this License for verbatim copying of each of the
-     documents in all other respects.
-
-     You may extract a single document from such a collection, and
-     distribute it individually under this License, provided you insert
-     a copy of this License into the extracted document, and follow
-     this License in all other respects regarding verbatim copying of
-     that document.
-
-  7. AGGREGATION WITH INDEPENDENT WORKS
-
-     A compilation of the Document or its derivatives with other
-     separate and independent documents or works, in or on a volume of
-     a storage or distribution medium, is called an "aggregate" if the
-     copyright resulting from the compilation is not used to limit the
-     legal rights of the compilation's users beyond what the individual
-     works permit.  When the Document is included in an aggregate, this
-     License does not apply to the other works in the aggregate which
-     are not themselves derivative works of the Document.
-
-     If the Cover Text requirement of section 3 is applicable to these
-     copies of the Document, then if the Document is less than one half
-     of the entire aggregate, the Document's Cover Texts may be placed
-     on covers that bracket the Document within the aggregate, or the
-     electronic equivalent of covers if the Document is in electronic
-     form.  Otherwise they must appear on printed covers that bracket
-     the whole aggregate.
-
-  8. TRANSLATION
-
-     Translation is considered a kind of modification, so you may
-     distribute translations of the Document under the terms of section
-     4.  Replacing Invariant Sections with translations requires special
-     permission from their copyright holders, but you may include
-     translations of some or all Invariant Sections in addition to the
-     original versions of these Invariant Sections.  You may include a
-     translation of this License, and all the license notices in the
-     Document, and any Warranty Disclaimers, provided that you also
-     include the original English version of this License and the
-     original versions of those notices and disclaimers.  In case of a
-     disagreement between the translation and the original version of
-     this License or a notice or disclaimer, the original version will
-     prevail.
-
-     If a section in the Document is Entitled "Acknowledgements",
-     "Dedications", or "History", the requirement (section 4) to
-     Preserve its Title (section 1) will typically require changing the
-     actual title.
-
-  9. TERMINATION
-
-     You may not copy, modify, sublicense, or distribute the Document
-     except as expressly provided under this License.  Any attempt
-     otherwise to copy, modify, sublicense, or distribute it is void,
-     and will automatically terminate your rights under this License.
-
-     However, if you cease all violation of this License, then your
-     license from a particular copyright holder is reinstated (a)
-     provisionally, unless and until the copyright holder explicitly
-     and finally terminates your license, and (b) permanently, if the
-     copyright holder fails to notify you of the violation by some
-     reasonable means prior to 60 days after the cessation.
-
-     Moreover, your license from a particular copyright holder is
-     reinstated permanently if the copyright holder notifies you of the
-     violation by some reasonable means, this is the first time you have
-     received notice of violation of this License (for any work) from
-     that copyright holder, and you cure the violation prior to 30 days
-     after your receipt of the notice.
-
-     Termination of your rights under this section does not terminate
-     the licenses of parties who have received copies or rights from
-     you under this License.  If your rights have been terminated and
-     not permanently reinstated, receipt of a copy of some or all of
-     the same material does not give you any rights to use it.
-
- 10. FUTURE REVISIONS OF THIS LICENSE
-
-     The Free Software Foundation may publish new, revised versions of
-     the GNU Free Documentation License from time to time.  Such new
-     versions will be similar in spirit to the present version, but may
-     differ in detail to address new problems or concerns.  See
-     `http://www.gnu.org/copyleft/'.
-
-     Each version of the License is given a distinguishing version
-     number.  If the Document specifies that a particular numbered
-     version of this License "or any later version" applies to it, you
-     have the option of following the terms and conditions either of
-     that specified version or of any later version that has been
-     published (not as a draft) by the Free Software Foundation.  If
-     the Document does not specify a version number of this License,
-     you may choose any version ever published (not as a draft) by the
-     Free Software Foundation.  If the Document specifies that a proxy
-     can decide which future versions of this License can be used, that
-     proxy's public statement of acceptance of a version permanently
-     authorizes you to choose that version for the Document.
-
- 11. RELICENSING
-
-     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
-     World Wide Web server that publishes copyrightable works and also
-     provides prominent facilities for anybody to edit those works.  A
-     public wiki that anybody can edit is an example of such a server.
-     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
-     site means any set of copyrightable works thus published on the MMC
-     site.
-
-     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
-     license published by Creative Commons Corporation, a not-for-profit
-     corporation with a principal place of business in San Francisco,
-     California, as well as future copyleft versions of that license
-     published by that same organization.
-
-     "Incorporate" means to publish or republish a Document, in whole or
-     in part, as part of another Document.
-
-     An MMC is "eligible for relicensing" if it is licensed under this
-     License, and if all works that were first published under this
-     License somewhere other than this MMC, and subsequently
-     incorporated in whole or in part into the MMC, (1) had no cover
-     texts or invariant sections, and (2) were thus incorporated prior
-     to November 1, 2008.
-
-     The operator of an MMC Site may republish an MMC contained in the
-     site under CC-BY-SA on the same site at any time before August 1,
-     2009, provided the MMC is eligible for relicensing.
-
-
-ADDENDUM: How to use this License for your documents
-====================================================
-
-To use this License in a document you have written, include a copy of
-the License in the document and put the following copyright and license
-notices just after the title page:
-
-       Copyright (C)  YEAR  YOUR NAME.
-       Permission is granted to copy, distribute and/or modify this document
-       under the terms of the GNU Free Documentation License, Version 1.3
-       or any later version published by the Free Software Foundation;
-       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
-       Texts.  A copy of the license is included in the section entitled ``GNU
-       Free Documentation License''.
-
-   If you have Invariant Sections, Front-Cover Texts and Back-Cover
-Texts, replace the "with...Texts." line with this:
-
-         with the Invariant Sections being LIST THEIR TITLES, with
-         the Front-Cover Texts being LIST, and with the Back-Cover Texts
-         being LIST.
-
-   If you have Invariant Sections without Cover Texts, or some other
-combination of the three, merge those two alternatives to suit the
-situation.
-
-   If your document contains nontrivial examples of program code, we
-recommend releasing these examples in parallel under your choice of
-free software license, such as the GNU General Public License, to
-permit their use in free software.
-
-
-File: gmp.info,  Node: Concept Index,  Next: Function Index,  Prev: GNU Free Documentation License,  Up: Top
-
-Concept Index
-*************
-
- [index ]
-* Menu:
-
-* #include:                              Headers and Libraries.
-                                                              (line   6)
-* --build:                               Build Options.       (line  52)
-* --disable-fft:                         Build Options.       (line 317)
-* --disable-shared:                      Build Options.       (line  45)
-* --disable-static:                      Build Options.       (line  45)
-* --enable-alloca:                       Build Options.       (line 278)
-* --enable-assert:                       Build Options.       (line 327)
-* --enable-cxx:                          Build Options.       (line 230)
-* --enable-fat:                          Build Options.       (line 164)
-* --enable-mpbsd:                        Build Options.       (line 322)
-* --enable-profiling <1>:                Profiling.           (line   6)
-* --enable-profiling:                    Build Options.       (line 331)
-* --exec-prefix:                         Build Options.       (line  32)
-* --host:                                Build Options.       (line  66)
-* --prefix:                              Build Options.       (line  32)
-* -finstrument-functions:                Profiling.           (line  66)
-* 2exp functions:                        Efficiency.          (line  43)
-* 68000:                                 Notes for Particular Systems.
-                                                              (line  80)
-* 80x86:                                 Notes for Particular Systems.
-                                                              (line 126)
-* ABI <1>:                               Build Options.       (line 171)
-* ABI:                                   ABI and ISA.         (line   6)
-* About this manual:                     Introduction to GMP. (line  58)
-* AC_CHECK_LIB:                          Autoconf.            (line  11)
-* AIX <1>:                               ABI and ISA.         (line 184)
-* AIX <2>:                               Notes for Particular Systems.
-                                                              (line   7)
-* AIX:                                   ABI and ISA.         (line 169)
-* Algorithms:                            Algorithms.          (line   6)
-* alloca:                                Build Options.       (line 278)
-* Allocation of memory:                  Custom Allocation.   (line   6)
-* AMD64:                                 ABI and ISA.         (line  44)
-* Anonymous FTP of latest version:       Introduction to GMP. (line  38)
-* Application Binary Interface:          ABI and ISA.         (line   6)
-* Arithmetic functions <1>:              Float Arithmetic.    (line   6)
-* Arithmetic functions <2>:              Integer Arithmetic.  (line   6)
-* Arithmetic functions:                  Rational Arithmetic. (line   6)
-* ARM:                                   Notes for Particular Systems.
-                                                              (line  20)
-* Assembly cache handling:               Assembly Cache Handling.
-                                                              (line   6)
-* Assembly carry propagation:            Assembly Carry Propagation.
-                                                              (line   6)
-* Assembly code organisation:            Assembly Code Organisation.
-                                                              (line   6)
-* Assembly coding:                       Assembly Coding.     (line   6)
-* Assembly floating Point:               Assembly Floating Point.
-                                                              (line   6)
-* Assembly loop unrolling:               Assembly Loop Unrolling.
-                                                              (line   6)
-* Assembly SIMD:                         Assembly SIMD Instructions.
-                                                              (line   6)
-* Assembly software pipelining:          Assembly Software Pipelining.
-                                                              (line   6)
-* Assembly writing guide:                Assembly Writing Guide.
-                                                              (line   6)
-* Assertion checking <1>:                Debugging.           (line  79)
-* Assertion checking:                    Build Options.       (line 327)
-* Assignment functions <1>:              Assigning Floats.    (line   6)
-* Assignment functions <2>:              Initializing Rationals.
-                                                              (line   6)
-* Assignment functions <3>:              Simultaneous Integer Init & Assign.
-                                                              (line   6)
-* Assignment functions <4>:              Simultaneous Float Init & Assign.
-                                                              (line   6)
-* Assignment functions:                  Assigning Integers.  (line   6)
-* Autoconf:                              Autoconf.            (line   6)
-* Basics:                                GMP Basics.          (line   6)
-* Berkeley MP compatible functions <1>:  Build Options.       (line 322)
-* Berkeley MP compatible functions:      BSD Compatible Functions.
-                                                              (line   6)
-* Binomial coefficient algorithm:        Binomial Coefficients Algorithm.
-                                                              (line   6)
-* Binomial coefficient functions:        Number Theoretic Functions.
-                                                              (line 100)
-* Binutils strip:                        Known Build Problems.
-                                                              (line  28)
-* Bit manipulation functions:            Integer Logic and Bit Fiddling.
-                                                              (line   6)
-* Bit scanning functions:                Integer Logic and Bit Fiddling.
-                                                              (line  38)
-* Bit shift left:                        Integer Arithmetic.  (line  35)
-* Bit shift right:                       Integer Division.    (line  53)
-* Bits per limb:                         Useful Macros and Constants.
-                                                              (line   7)
-* BSD MP compatible functions <1>:       Build Options.       (line 322)
-* BSD MP compatible functions:           BSD Compatible Functions.
-                                                              (line   6)
-* Bug reporting:                         Reporting Bugs.      (line   6)
-* Build directory:                       Build Options.       (line  19)
-* Build notes for binary packaging:      Notes for Package Builds.
-                                                              (line   6)
-* Build notes for particular systems:    Notes for Particular Systems.
-                                                              (line   6)
-* Build options:                         Build Options.       (line   6)
-* Build problems known:                  Known Build Problems.
-                                                              (line   6)
-* Build system:                          Build Options.       (line  52)
-* Building GMP:                          Installing GMP.      (line   6)
-* Bus error:                             Debugging.           (line   7)
-* C compiler:                            Build Options.       (line 182)
-* C++ compiler:                          Build Options.       (line 254)
-* C++ interface:                         C++ Class Interface. (line   6)
-* C++ interface internals:               C++ Interface Internals.
-                                                              (line   6)
-* C++ istream input:                     C++ Formatted Input. (line   6)
-* C++ ostream output:                    C++ Formatted Output.
-                                                              (line   6)
-* C++ support:                           Build Options.       (line 230)
-* CC:                                    Build Options.       (line 182)
-* CC_FOR_BUILD:                          Build Options.       (line 217)
-* CFLAGS:                                Build Options.       (line 182)
-* Checker:                               Debugging.           (line 115)
-* checkergcc:                            Debugging.           (line 122)
-* Code organisation:                     Assembly Code Organisation.
-                                                              (line   6)
-* Compaq C++:                            Notes for Particular Systems.
-                                                              (line  25)
-* Comparison functions <1>:              Integer Comparisons. (line   6)
-* Comparison functions <2>:              Comparing Rationals. (line   6)
-* Comparison functions:                  Float Comparison.    (line   6)
-* Compatibility with older versions:     Compatibility with older versions.
-                                                              (line   6)
-* Conditions for copying GNU MP:         Copying.             (line   6)
-* Configuring GMP:                       Installing GMP.      (line   6)
-* Congruence algorithm:                  Exact Remainder.     (line  29)
-* Congruence functions:                  Integer Division.    (line 124)
-* Constants:                             Useful Macros and Constants.
-                                                              (line   6)
-* Contributors:                          Contributors.        (line   6)
-* Conventions for parameters:            Parameter Conventions.
-                                                              (line   6)
-* Conventions for variables:             Variable Conventions.
-                                                              (line   6)
-* Conversion functions <1>:              Converting Integers. (line   6)
-* Conversion functions <2>:              Converting Floats.   (line   6)
-* Conversion functions:                  Rational Conversions.
-                                                              (line   6)
-* Copying conditions:                    Copying.             (line   6)
-* CPPFLAGS:                              Build Options.       (line 208)
-* CPU types <1>:                         Introduction to GMP. (line  24)
-* CPU types:                             Build Options.       (line 108)
-* Cross compiling:                       Build Options.       (line  66)
-* Custom allocation:                     Custom Allocation.   (line   6)
-* CXX:                                   Build Options.       (line 254)
-* CXXFLAGS:                              Build Options.       (line 254)
-* Cygwin:                                Notes for Particular Systems.
-                                                              (line  43)
-* Darwin:                                Known Build Problems.
-                                                              (line  51)
-* Debugging:                             Debugging.           (line   6)
-* Demonstration programs:                Demonstration Programs.
-                                                              (line   6)
-* Digits in an integer:                  Miscellaneous Integer Functions.
-                                                              (line  23)
-* Divisibility algorithm:                Exact Remainder.     (line  29)
-* Divisibility functions:                Integer Division.    (line 124)
-* Divisibility testing:                  Efficiency.          (line  91)
-* Division algorithms:                   Division Algorithms. (line   6)
-* Division functions <1>:                Rational Arithmetic. (line  22)
-* Division functions <2>:                Integer Division.    (line   6)
-* Division functions:                    Float Arithmetic.    (line  33)
-* DJGPP <1>:                             Notes for Particular Systems.
-                                                              (line  43)
-* DJGPP:                                 Known Build Problems.
-                                                              (line  18)
-* DLLs:                                  Notes for Particular Systems.
-                                                              (line  56)
-* DocBook:                               Build Options.       (line 354)
-* Documentation formats:                 Build Options.       (line 347)
-* Documentation license:                 GNU Free Documentation License.
-                                                              (line   6)
-* DVI:                                   Build Options.       (line 350)
-* Efficiency:                            Efficiency.          (line   6)
-* Emacs:                                 Emacs.               (line   6)
-* Exact division functions:              Integer Division.    (line 102)
-* Exact remainder:                       Exact Remainder.     (line   6)
-* Example programs:                      Demonstration Programs.
-                                                              (line   6)
-* Exec prefix:                           Build Options.       (line  32)
-* Execution profiling <1>:               Profiling.           (line   6)
-* Execution profiling:                   Build Options.       (line 331)
-* Exponentiation functions <1>:          Integer Exponentiation.
-                                                              (line   6)
-* Exponentiation functions:              Float Arithmetic.    (line  41)
-* Export:                                Integer Import and Export.
-                                                              (line  45)
-* Expression parsing demo:               Demonstration Programs.
-                                                              (line  18)
-* Extended GCD:                          Number Theoretic Functions.
-                                                              (line  45)
-* Factor removal functions:              Number Theoretic Functions.
-                                                              (line  90)
-* Factorial algorithm:                   Factorial Algorithm. (line   6)
-* Factorial functions:                   Number Theoretic Functions.
-                                                              (line  95)
-* Factorization demo:                    Demonstration Programs.
-                                                              (line  25)
-* Fast Fourier Transform:                FFT Multiplication.  (line   6)
-* Fat binary:                            Build Options.       (line 164)
-* FFT multiplication <1>:                FFT Multiplication.  (line   6)
-* FFT multiplication:                    Build Options.       (line 317)
-* Fibonacci number algorithm:            Fibonacci Numbers Algorithm.
-                                                              (line   6)
-* Fibonacci sequence functions:          Number Theoretic Functions.
-                                                              (line 108)
-* Float arithmetic functions:            Float Arithmetic.    (line   6)
-* Float assignment functions <1>:        Simultaneous Float Init & Assign.
-                                                              (line   6)
-* Float assignment functions:            Assigning Floats.    (line   6)
-* Float comparison functions:            Float Comparison.    (line   6)
-* Float conversion functions:            Converting Floats.   (line   6)
-* Float functions:                       Floating-point Functions.
-                                                              (line   6)
-* Float initialization functions <1>:    Simultaneous Float Init & Assign.
-                                                              (line   6)
-* Float initialization functions:        Initializing Floats. (line   6)
-* Float input and output functions:      I/O of Floats.       (line   6)
-* Float internals:                       Float Internals.     (line   6)
-* Float miscellaneous functions:         Miscellaneous Float Functions.
-                                                              (line   6)
-* Float random number functions:         Miscellaneous Float Functions.
-                                                              (line  27)
-* Float rounding functions:              Miscellaneous Float Functions.
-                                                              (line   9)
-* Float sign tests:                      Float Comparison.    (line  33)
-* Floating point mode:                   Notes for Particular Systems.
-                                                              (line  34)
-* Floating-point functions:              Floating-point Functions.
-                                                              (line   6)
-* Floating-point number:                 Nomenclature and Types.
-                                                              (line  21)
-* fnccheck:                              Profiling.           (line  77)
-* Formatted input:                       Formatted Input.     (line   6)
-* Formatted output:                      Formatted Output.    (line   6)
-* Free Documentation License:            GNU Free Documentation License.
-                                                              (line   6)
-* frexp <1>:                             Converting Floats.   (line  23)
-* frexp:                                 Converting Integers. (line  42)
-* FTP of latest version:                 Introduction to GMP. (line  38)
-* Function classes:                      Function Classes.    (line   6)
-* FunctionCheck:                         Profiling.           (line  77)
-* GCC Checker:                           Debugging.           (line 115)
-* GCD algorithms:                        Greatest Common Divisor Algorithms.
-                                                              (line   6)
-* GCD extended:                          Number Theoretic Functions.
-                                                              (line  45)
-* GCD functions:                         Number Theoretic Functions.
-                                                              (line  30)
-* GDB:                                   Debugging.           (line  58)
-* Generic C:                             Build Options.       (line 153)
-* GMP Perl module:                       Demonstration Programs.
-                                                              (line  35)
-* GMP version number:                    Useful Macros and Constants.
-                                                              (line  12)
-* gmp.h:                                 Headers and Libraries.
-                                                              (line   6)
-* gmpxx.h:                               C++ Interface General.
-                                                              (line   8)
-* GNU Debugger:                          Debugging.           (line  58)
-* GNU Free Documentation License:        GNU Free Documentation License.
-                                                              (line   6)
-* GNU strip:                             Known Build Problems.
-                                                              (line  28)
-* gprof:                                 Profiling.           (line  41)
-* Greatest common divisor algorithms:    Greatest Common Divisor Algorithms.
-                                                              (line   6)
-* Greatest common divisor functions:     Number Theoretic Functions.
-                                                              (line  30)
-* Hardware floating point mode:          Notes for Particular Systems.
-                                                              (line  34)
-* Headers:                               Headers and Libraries.
-                                                              (line   6)
-* Heap problems:                         Debugging.           (line  24)
-* Home page:                             Introduction to GMP. (line  34)
-* Host system:                           Build Options.       (line  66)
-* HP-UX:                                 ABI and ISA.         (line 107)
-* HPPA:                                  ABI and ISA.         (line  68)
-* I/O functions <1>:                     I/O of Integers.     (line   6)
-* I/O functions <2>:                     I/O of Rationals.    (line   6)
-* I/O functions:                         I/O of Floats.       (line   6)
-* i386:                                  Notes for Particular Systems.
-                                                              (line 126)
-* IA-64:                                 ABI and ISA.         (line 107)
-* Import:                                Integer Import and Export.
-                                                              (line  11)
-* In-place operations:                   Efficiency.          (line  57)
-* Include files:                         Headers and Libraries.
-                                                              (line   6)
-* info-lookup-symbol:                    Emacs.               (line   6)
-* Initialization functions <1>:          Initializing Integers.
-                                                              (line   6)
-* Initialization functions <2>:          Initializing Rationals.
-                                                              (line   6)
-* Initialization functions <3>:          Random State Initialization.
-                                                              (line   6)
-* Initialization functions <4>:          Simultaneous Float Init & Assign.
-                                                              (line   6)
-* Initialization functions <5>:          Simultaneous Integer Init & Assign.
-                                                              (line   6)
-* Initialization functions:              Initializing Floats. (line   6)
-* Initializing and clearing:             Efficiency.          (line  21)
-* Input functions <1>:                   I/O of Integers.     (line   6)
-* Input functions <2>:                   I/O of Rationals.    (line   6)
-* Input functions <3>:                   I/O of Floats.       (line   6)
-* Input functions:                       Formatted Input Functions.
-                                                              (line   6)
-* Install prefix:                        Build Options.       (line  32)
-* Installing GMP:                        Installing GMP.      (line   6)
-* Instruction Set Architecture:          ABI and ISA.         (line   6)
-* instrument-functions:                  Profiling.           (line  66)
-* Integer:                               Nomenclature and Types.
-                                                              (line   6)
-* Integer arithmetic functions:          Integer Arithmetic.  (line   6)
-* Integer assignment functions <1>:      Simultaneous Integer Init & Assign.
-                                                              (line   6)
-* Integer assignment functions:          Assigning Integers.  (line   6)
-* Integer bit manipulation functions:    Integer Logic and Bit Fiddling.
-                                                              (line   6)
-* Integer comparison functions:          Integer Comparisons. (line   6)
-* Integer conversion functions:          Converting Integers. (line   6)
-* Integer division functions:            Integer Division.    (line   6)
-* Integer exponentiation functions:      Integer Exponentiation.
-                                                              (line   6)
-* Integer export:                        Integer Import and Export.
-                                                              (line  45)
-* Integer functions:                     Integer Functions.   (line   6)
-* Integer import:                        Integer Import and Export.
-                                                              (line  11)
-* Integer initialization functions <1>:  Simultaneous Integer Init & Assign.
-                                                              (line   6)
-* Integer initialization functions:      Initializing Integers.
-                                                              (line   6)
-* Integer input and output functions:    I/O of Integers.     (line   6)
-* Integer internals:                     Integer Internals.   (line   6)
-* Integer logical functions:             Integer Logic and Bit Fiddling.
-                                                              (line   6)
-* Integer miscellaneous functions:       Miscellaneous Integer Functions.
-                                                              (line   6)
-* Integer random number functions:       Integer Random Numbers.
-                                                              (line   6)
-* Integer root functions:                Integer Roots.       (line   6)
-* Integer sign tests:                    Integer Comparisons. (line  28)
-* Integer special functions:             Integer Special Functions.
-                                                              (line   6)
-* Interix:                               Notes for Particular Systems.
-                                                              (line  51)
-* Internals:                             Internals.           (line   6)
-* Introduction:                          Introduction to GMP. (line   6)
-* Inverse modulo functions:              Number Theoretic Functions.
-                                                              (line  60)
-* IRIX <1>:                              Known Build Problems.
-                                                              (line  38)
-* IRIX:                                  ABI and ISA.         (line 132)
-* ISA:                                   ABI and ISA.         (line   6)
-* istream input:                         C++ Formatted Input. (line   6)
-* Jacobi symbol algorithm:               Jacobi Symbol.       (line   6)
-* Jacobi symbol functions:               Number Theoretic Functions.
-                                                              (line  66)
-* Karatsuba multiplication:              Karatsuba Multiplication.
-                                                              (line   6)
-* Karatsuba square root algorithm:       Square Root Algorithm.
-                                                              (line   6)
-* Kronecker symbol functions:            Number Theoretic Functions.
-                                                              (line  78)
-* Language bindings:                     Language Bindings.   (line   6)
-* Latest version of GMP:                 Introduction to GMP. (line  38)
-* LCM functions:                         Number Theoretic Functions.
-                                                              (line  55)
-* Least common multiple functions:       Number Theoretic Functions.
-                                                              (line  55)
-* Legendre symbol functions:             Number Theoretic Functions.
-                                                              (line  69)
-* libgmp:                                Headers and Libraries.
-                                                              (line  22)
-* libgmpxx:                              Headers and Libraries.
-                                                              (line  27)
-* Libraries:                             Headers and Libraries.
-                                                              (line  22)
-* Libtool:                               Headers and Libraries.
-                                                              (line  33)
-* Libtool versioning:                    Notes for Package Builds.
-                                                              (line   9)
-* License conditions:                    Copying.             (line   6)
-* Limb:                                  Nomenclature and Types.
-                                                              (line  31)
-* Limb size:                             Useful Macros and Constants.
-                                                              (line   7)
-* Linear congruential algorithm:         Random Number Algorithms.
-                                                              (line  25)
-* Linear congruential random numbers:    Random State Initialization.
-                                                              (line  32)
-* Linking:                               Headers and Libraries.
-                                                              (line  22)
-* Logical functions:                     Integer Logic and Bit Fiddling.
-                                                              (line   6)
-* Low-level functions:                   Low-level Functions. (line   6)
-* Lucas number algorithm:                Lucas Numbers Algorithm.
-                                                              (line   6)
-* Lucas number functions:                Number Theoretic Functions.
-                                                              (line 119)
-* MacOS X:                               Known Build Problems.
-                                                              (line  51)
-* Mailing lists:                         Introduction to GMP. (line  45)
-* Malloc debugger:                       Debugging.           (line  30)
-* Malloc problems:                       Debugging.           (line  24)
-* Memory allocation:                     Custom Allocation.   (line   6)
-* Memory management:                     Memory Management.   (line   6)
-* Mersenne twister algorithm:            Random Number Algorithms.
-                                                              (line  17)
-* Mersenne twister random numbers:       Random State Initialization.
-                                                              (line  13)
-* MINGW:                                 Notes for Particular Systems.
-                                                              (line  43)
-* MIPS:                                  ABI and ISA.         (line 132)
-* Miscellaneous float functions:         Miscellaneous Float Functions.
-                                                              (line   6)
-* Miscellaneous integer functions:       Miscellaneous Integer Functions.
-                                                              (line   6)
-* MMX:                                   Notes for Particular Systems.
-                                                              (line 132)
-* Modular inverse functions:             Number Theoretic Functions.
-                                                              (line  60)
-* Most significant bit:                  Miscellaneous Integer Functions.
-                                                              (line  34)
-* mp.h:                                  BSD Compatible Functions.
-                                                              (line  21)
-* MPN_PATH:                              Build Options.       (line 335)
-* MS Windows:                            Notes for Particular Systems.
-                                                              (line  56)
-* MS-DOS:                                Notes for Particular Systems.
-                                                              (line  43)
-* Multi-threading:                       Reentrancy.          (line   6)
-* Multiplication algorithms:             Multiplication Algorithms.
-                                                              (line   6)
-* Nails:                                 Low-level Functions. (line 479)
-* Native compilation:                    Build Options.       (line  52)
-* NeXT:                                  Known Build Problems.
-                                                              (line  57)
-* Next prime function:                   Number Theoretic Functions.
-                                                              (line  23)
-* Nomenclature:                          Nomenclature and Types.
-                                                              (line   6)
-* Non-Unix systems:                      Build Options.       (line  11)
-* Nth root algorithm:                    Nth Root Algorithm.  (line   6)
-* Number sequences:                      Efficiency.          (line 147)
-* Number theoretic functions:            Number Theoretic Functions.
-                                                              (line   6)
-* Numerator and denominator:             Applying Integer Functions.
-                                                              (line   6)
-* obstack output:                        Formatted Output Functions.
-                                                              (line  81)
-* OpenBSD:                               Notes for Particular Systems.
-                                                              (line  86)
-* Optimizing performance:                Performance optimization.
-                                                              (line   6)
-* ostream output:                        C++ Formatted Output.
-                                                              (line   6)
-* Other languages:                       Language Bindings.   (line   6)
-* Output functions <1>:                  I/O of Floats.       (line   6)
-* Output functions <2>:                  I/O of Rationals.    (line   6)
-* Output functions <3>:                  Formatted Output Functions.
-                                                              (line   6)
-* Output functions:                      I/O of Integers.     (line   6)
-* Packaged builds:                       Notes for Package Builds.
-                                                              (line   6)
-* Parameter conventions:                 Parameter Conventions.
-                                                              (line   6)
-* Parsing expressions demo:              Demonstration Programs.
-                                                              (line  21)
-* Particular systems:                    Notes for Particular Systems.
-                                                              (line   6)
-* Past GMP versions:                     Compatibility with older versions.
-                                                              (line   6)
-* PDF:                                   Build Options.       (line 350)
-* Perfect power algorithm:               Perfect Power Algorithm.
-                                                              (line   6)
-* Perfect power functions:               Integer Roots.       (line  27)
-* Perfect square algorithm:              Perfect Square Algorithm.
-                                                              (line   6)
-* Perfect square functions:              Integer Roots.       (line  36)
-* perl:                                  Demonstration Programs.
-                                                              (line  35)
-* Perl module:                           Demonstration Programs.
-                                                              (line  35)
-* Postscript:                            Build Options.       (line 350)
-* Power/PowerPC <1>:                     Known Build Problems.
-                                                              (line  63)
-* Power/PowerPC:                         Notes for Particular Systems.
-                                                              (line  92)
-* Powering algorithms:                   Powering Algorithms. (line   6)
-* Powering functions <1>:                Float Arithmetic.    (line  41)
-* Powering functions:                    Integer Exponentiation.
-                                                              (line   6)
-* PowerPC:                               ABI and ISA.         (line 167)
-* Precision of floats:                   Floating-point Functions.
-                                                              (line   6)
-* Precision of hardware floating point:  Notes for Particular Systems.
-                                                              (line  34)
-* Prefix:                                Build Options.       (line  32)
-* Prime testing algorithms:              Prime Testing Algorithm.
-                                                              (line   6)
-* Prime testing functions:               Number Theoretic Functions.
-                                                              (line   7)
-* printf formatted output:               Formatted Output.    (line   6)
-* Probable prime testing functions:      Number Theoretic Functions.
-                                                              (line   7)
-* prof:                                  Profiling.           (line  24)
-* Profiling:                             Profiling.           (line   6)
-* Radix conversion algorithms:           Radix Conversion Algorithms.
-                                                              (line   6)
-* Random number algorithms:              Random Number Algorithms.
-                                                              (line   6)
-* Random number functions <1>:           Integer Random Numbers.
-                                                              (line   6)
-* Random number functions <2>:           Miscellaneous Float Functions.
-                                                              (line  27)
-* Random number functions:               Random Number Functions.
-                                                              (line   6)
-* Random number seeding:                 Random State Seeding.
-                                                              (line   6)
-* Random number state:                   Random State Initialization.
-                                                              (line   6)
-* Random state:                          Nomenclature and Types.
-                                                              (line  46)
-* Rational arithmetic:                   Efficiency.          (line 113)
-* Rational arithmetic functions:         Rational Arithmetic. (line   6)
-* Rational assignment functions:         Initializing Rationals.
-                                                              (line   6)
-* Rational comparison functions:         Comparing Rationals. (line   6)
-* Rational conversion functions:         Rational Conversions.
-                                                              (line   6)
-* Rational initialization functions:     Initializing Rationals.
-                                                              (line   6)
-* Rational input and output functions:   I/O of Rationals.    (line   6)
-* Rational internals:                    Rational Internals.  (line   6)
-* Rational number:                       Nomenclature and Types.
-                                                              (line  16)
-* Rational number functions:             Rational Number Functions.
-                                                              (line   6)
-* Rational numerator and denominator:    Applying Integer Functions.
-                                                              (line   6)
-* Rational sign tests:                   Comparing Rationals. (line  27)
-* Raw output internals:                  Raw Output Internals.
-                                                              (line   6)
-* Reallocations:                         Efficiency.          (line  30)
-* Reentrancy:                            Reentrancy.          (line   6)
-* References:                            References.          (line   6)
-* Remove factor functions:               Number Theoretic Functions.
-                                                              (line  90)
-* Reporting bugs:                        Reporting Bugs.      (line   6)
-* Root extraction algorithm:             Nth Root Algorithm.  (line   6)
-* Root extraction algorithms:            Root Extraction Algorithms.
-                                                              (line   6)
-* Root extraction functions <1>:         Float Arithmetic.    (line  37)
-* Root extraction functions:             Integer Roots.       (line   6)
-* Root testing functions:                Integer Roots.       (line  36)
-* Rounding functions:                    Miscellaneous Float Functions.
-                                                              (line   9)
-* Sample programs:                       Demonstration Programs.
-                                                              (line   6)
-* Scan bit functions:                    Integer Logic and Bit Fiddling.
-                                                              (line  38)
-* scanf formatted input:                 Formatted Input.     (line   6)
-* SCO:                                   Known Build Problems.
-                                                              (line  38)
-* Seeding random numbers:                Random State Seeding.
-                                                              (line   6)
-* Segmentation violation:                Debugging.           (line   7)
-* Sequent Symmetry:                      Known Build Problems.
-                                                              (line  68)
-* Services for Unix:                     Notes for Particular Systems.
-                                                              (line  51)
-* Shared library versioning:             Notes for Package Builds.
-                                                              (line   9)
-* Sign tests <1>:                        Float Comparison.    (line  33)
-* Sign tests <2>:                        Integer Comparisons. (line  28)
-* Sign tests:                            Comparing Rationals. (line  27)
-* Size in digits:                        Miscellaneous Integer Functions.
-                                                              (line  23)
-* Small operands:                        Efficiency.          (line   7)
-* Solaris <1>:                           ABI and ISA.         (line 201)
-* Solaris:                               Known Build Problems.
-                                                              (line  78)
-* Sparc:                                 Notes for Particular Systems.
-                                                              (line 108)
-* Sparc V9:                              ABI and ISA.         (line 201)
-* Special integer functions:             Integer Special Functions.
-                                                              (line   6)
-* Square root algorithm:                 Square Root Algorithm.
-                                                              (line   6)
-* SSE2:                                  Notes for Particular Systems.
-                                                              (line 132)
-* Stack backtrace:                       Debugging.           (line  50)
-* Stack overflow <1>:                    Debugging.           (line   7)
-* Stack overflow:                        Build Options.       (line 278)
-* Static linking:                        Efficiency.          (line  14)
-* stdarg.h:                              Headers and Libraries.
-                                                              (line  17)
-* stdio.h:                               Headers and Libraries.
-                                                              (line  11)
-* Stripped libraries:                    Known Build Problems.
-                                                              (line  28)
-* Sun:                                   ABI and ISA.         (line 201)
-* SunOS:                                 Notes for Particular Systems.
-                                                              (line 120)
-* Systems:                               Notes for Particular Systems.
-                                                              (line   6)
-* Temporary memory:                      Build Options.       (line 278)
-* Texinfo:                               Build Options.       (line 347)
-* Text input/output:                     Efficiency.          (line 153)
-* Thread safety:                         Reentrancy.          (line   6)
-* Toom multiplication <1>:               Other Multiplication.
-                                                              (line   6)
-* Toom multiplication <2>:               Toom 4-Way Multiplication.
-                                                              (line   6)
-* Toom multiplication:                   Toom 3-Way Multiplication.
-                                                              (line   6)
-* Types:                                 Nomenclature and Types.
-                                                              (line   6)
-* ui and si functions:                   Efficiency.          (line  50)
-* Unbalanced multiplication:             Unbalanced Multiplication.
-                                                              (line   6)
-* Upward compatibility:                  Compatibility with older versions.
-                                                              (line   6)
-* Useful macros and constants:           Useful Macros and Constants.
-                                                              (line   6)
-* User-defined precision:                Floating-point Functions.
-                                                              (line   6)
-* Valgrind:                              Debugging.           (line 130)
-* Variable conventions:                  Variable Conventions.
-                                                              (line   6)
-* Version number:                        Useful Macros and Constants.
-                                                              (line  12)
-* Web page:                              Introduction to GMP. (line  34)
-* Windows:                               Notes for Particular Systems.
-                                                              (line  56)
-* x86:                                   Notes for Particular Systems.
-                                                              (line 126)
-* x87:                                   Notes for Particular Systems.
-                                                              (line  34)
-* XML:                                   Build Options.       (line 354)
-
-
-File: gmp.info,  Node: Function Index,  Prev: Concept Index,  Up: Top
-
-Function and Type Index
-***********************
-
- [index ]
-* Menu:
-
-* __GMP_CC:                              Useful Macros and Constants.
-                                                              (line  23)
-* __GMP_CFLAGS:                          Useful Macros and Constants.
-                                                              (line  24)
-* __GNU_MP_VERSION:                      Useful Macros and Constants.
-                                                              (line  10)
-* __GNU_MP_VERSION_MINOR:                Useful Macros and Constants.
-                                                              (line  11)
-* __GNU_MP_VERSION_PATCHLEVEL:           Useful Macros and Constants.
-                                                              (line  12)
-* _mpz_realloc:                          Integer Special Functions.
-                                                              (line  51)
-* abs <1>:                               C++ Interface Floats.
-                                                              (line  79)
-* abs <2>:                               C++ Interface Rationals.
-                                                              (line  43)
-* abs:                                   C++ Interface Integers.
-                                                              (line  42)
-* ceil:                                  C++ Interface Floats.
-                                                              (line  80)
-* cmp <1>:                               C++ Interface Floats.
-                                                              (line  81)
-* cmp <2>:                               C++ Interface Integers.
-                                                              (line  43)
-* cmp <3>:                               C++ Interface Floats.
-                                                              (line  82)
-* cmp <4>:                               C++ Interface Rationals.
-                                                              (line  45)
-* cmp:                                   C++ Interface Integers.
-                                                              (line  44)
-* floor:                                 C++ Interface Floats.
-                                                              (line  89)
-* gcd:                                   BSD Compatible Functions.
-                                                              (line  82)
-* gmp_asprintf:                          Formatted Output Functions.
-                                                              (line  65)
-* gmp_errno:                             Random State Initialization.
-                                                              (line  55)
-* GMP_ERROR_INVALID_ARGUMENT:            Random State Initialization.
-                                                              (line  55)
-* GMP_ERROR_UNSUPPORTED_ARGUMENT:        Random State Initialization.
-                                                              (line  55)
-* gmp_fprintf:                           Formatted Output Functions.
-                                                              (line  29)
-* gmp_fscanf:                            Formatted Input Functions.
-                                                              (line  25)
-* GMP_LIMB_BITS:                         Low-level Functions. (line 509)
-* GMP_NAIL_BITS:                         Low-level Functions. (line 507)
-* GMP_NAIL_MASK:                         Low-level Functions. (line 517)
-* GMP_NUMB_BITS:                         Low-level Functions. (line 508)
-* GMP_NUMB_MASK:                         Low-level Functions. (line 518)
-* GMP_NUMB_MAX:                          Low-level Functions. (line 526)
-* gmp_obstack_printf:                    Formatted Output Functions.
-                                                              (line  79)
-* gmp_obstack_vprintf:                   Formatted Output Functions.
-                                                              (line  81)
-* gmp_printf:                            Formatted Output Functions.
-                                                              (line  24)
-* GMP_RAND_ALG_DEFAULT:                  Random State Initialization.
-                                                              (line  49)
-* GMP_RAND_ALG_LC:                       Random State Initialization.
-                                                              (line  49)
-* gmp_randclass:                         C++ Interface Random Numbers.
-                                                              (line   7)
-* gmp_randclass::get_f:                  C++ Interface Random Numbers.
-                                                              (line  45)
-* gmp_randclass::get_z_bits:             C++ Interface Random Numbers.
-                                                              (line  38)
-* gmp_randclass::get_z_range:            C++ Interface Random Numbers.
-                                                              (line  42)
-* gmp_randclass::gmp_randclass:          C++ Interface Random Numbers.
-                                                              (line  27)
-* gmp_randclass::seed:                   C++ Interface Random Numbers.
-                                                              (line  34)
-* gmp_randclear:                         Random State Initialization.
-                                                              (line  62)
-* gmp_randinit:                          Random State Initialization.
-                                                              (line  47)
-* gmp_randinit_default:                  Random State Initialization.
-                                                              (line   7)
-* gmp_randinit_lc_2exp:                  Random State Initialization.
-                                                              (line  18)
-* gmp_randinit_lc_2exp_size:             Random State Initialization.
-                                                              (line  32)
-* gmp_randinit_mt:                       Random State Initialization.
-                                                              (line  13)
-* gmp_randinit_set:                      Random State Initialization.
-                                                              (line  43)
-* gmp_randseed:                          Random State Seeding.
-                                                              (line   7)
-* gmp_randseed_ui:                       Random State Seeding.
-                                                              (line   9)
-* gmp_randstate_t:                       Nomenclature and Types.
-                                                              (line  46)
-* gmp_scanf:                             Formatted Input Functions.
-                                                              (line  21)
-* gmp_snprintf:                          Formatted Output Functions.
-                                                              (line  46)
-* gmp_sprintf:                           Formatted Output Functions.
-                                                              (line  34)
-* gmp_sscanf:                            Formatted Input Functions.
-                                                              (line  29)
-* gmp_urandomb_ui:                       Random State Miscellaneous.
-                                                              (line   8)
-* gmp_urandomm_ui:                       Random State Miscellaneous.
-                                                              (line  14)
-* gmp_vasprintf:                         Formatted Output Functions.
-                                                              (line  66)
-* gmp_version:                           Useful Macros and Constants.
-                                                              (line  18)
-* gmp_vfprintf:                          Formatted Output Functions.
-                                                              (line  30)
-* gmp_vfscanf:                           Formatted Input Functions.
-                                                              (line  26)
-* gmp_vprintf:                           Formatted Output Functions.
-                                                              (line  25)
-* gmp_vscanf:                            Formatted Input Functions.
-                                                              (line  22)
-* gmp_vsnprintf:                         Formatted Output Functions.
-                                                              (line  48)
-* gmp_vsprintf:                          Formatted Output Functions.
-                                                              (line  35)
-* gmp_vsscanf:                           Formatted Input Functions.
-                                                              (line  31)
-* hypot:                                 C++ Interface Floats.
-                                                              (line  90)
-* itom:                                  BSD Compatible Functions.
-                                                              (line  29)
-* madd:                                  BSD Compatible Functions.
-                                                              (line  43)
-* mcmp:                                  BSD Compatible Functions.
-                                                              (line  85)
-* mdiv:                                  BSD Compatible Functions.
-                                                              (line  53)
-* mfree:                                 BSD Compatible Functions.
-                                                              (line 105)
-* min:                                   BSD Compatible Functions.
-                                                              (line  89)
-* MINT:                                  BSD Compatible Functions.
-                                                              (line  21)
-* mout:                                  BSD Compatible Functions.
-                                                              (line  94)
-* move:                                  BSD Compatible Functions.
-                                                              (line  39)
-* mp_bitcnt_t:                           Nomenclature and Types.
-                                                              (line  42)
-* mp_bits_per_limb:                      Useful Macros and Constants.
-                                                              (line   7)
-* mp_exp_t:                              Nomenclature and Types.
-                                                              (line  27)
-* mp_get_memory_functions:               Custom Allocation.   (line  93)
-* mp_limb_t:                             Nomenclature and Types.
-                                                              (line  31)
-* mp_set_memory_functions:               Custom Allocation.   (line  21)
-* mp_size_t:                             Nomenclature and Types.
-                                                              (line  37)
-* mpf_abs:                               Float Arithmetic.    (line  47)
-* mpf_add:                               Float Arithmetic.    (line   7)
-* mpf_add_ui:                            Float Arithmetic.    (line   9)
-* mpf_ceil:                              Miscellaneous Float Functions.
-                                                              (line   7)
-* mpf_class:                             C++ Interface General.
-                                                              (line  20)
-* mpf_class::fits_sint_p:                C++ Interface Floats.
-                                                              (line  83)
-* mpf_class::fits_slong_p:               C++ Interface Floats.
-                                                              (line  84)
-* mpf_class::fits_sshort_p:              C++ Interface Floats.
-                                                              (line  85)
-* mpf_class::fits_uint_p:                C++ Interface Floats.
-                                                              (line  86)
-* mpf_class::fits_ulong_p:               C++ Interface Floats.
-                                                              (line  87)
-* mpf_class::fits_ushort_p:              C++ Interface Floats.
-                                                              (line  88)
-* mpf_class::get_d:                      C++ Interface Floats.
-                                                              (line  91)
-* mpf_class::get_mpf_t:                  C++ Interface General.
-                                                              (line  66)
-* mpf_class::get_prec:                   C++ Interface Floats.
-                                                              (line 109)
-* mpf_class::get_si:                     C++ Interface Floats.
-                                                              (line  92)
-* mpf_class::get_str:                    C++ Interface Floats.
-                                                              (line  94)
-* mpf_class::get_ui:                     C++ Interface Floats.
-                                                              (line  95)
-* mpf_class::mpf_class:                  C++ Interface Floats.
-                                                              (line  12)
-* mpf_class::operator=:                  C++ Interface Floats.
-                                                              (line  56)
-* mpf_class::set_prec:                   C++ Interface Floats.
-                                                              (line 110)
-* mpf_class::set_prec_raw:               C++ Interface Floats.
-                                                              (line 111)
-* mpf_class::set_str:                    C++ Interface Floats.
-                                                              (line  97)
-* mpf_clear:                             Initializing Floats. (line  37)
-* mpf_clears:                            Initializing Floats. (line  41)
-* mpf_cmp:                               Float Comparison.    (line   7)
-* mpf_cmp_d:                             Float Comparison.    (line   8)
-* mpf_cmp_si:                            Float Comparison.    (line  10)
-* mpf_cmp_ui:                            Float Comparison.    (line   9)
-* mpf_div:                               Float Arithmetic.    (line  29)
-* mpf_div_2exp:                          Float Arithmetic.    (line  53)
-* mpf_div_ui:                            Float Arithmetic.    (line  33)
-* mpf_eq:                                Float Comparison.    (line  17)
-* mpf_fits_sint_p:                       Miscellaneous Float Functions.
-                                                              (line  20)
-* mpf_fits_slong_p:                      Miscellaneous Float Functions.
-                                                              (line  18)
-* mpf_fits_sshort_p:                     Miscellaneous Float Functions.
-                                                              (line  22)
-* mpf_fits_uint_p:                       Miscellaneous Float Functions.
-                                                              (line  19)
-* mpf_fits_ulong_p:                      Miscellaneous Float Functions.
-                                                              (line  17)
-* mpf_fits_ushort_p:                     Miscellaneous Float Functions.
-                                                              (line  21)
-* mpf_floor:                             Miscellaneous Float Functions.
-                                                              (line   8)
-* mpf_get_d:                             Converting Floats.   (line   7)
-* mpf_get_d_2exp:                        Converting Floats.   (line  16)
-* mpf_get_default_prec:                  Initializing Floats. (line  12)
-* mpf_get_prec:                          Initializing Floats. (line  62)
-* mpf_get_si:                            Converting Floats.   (line  27)
-* mpf_get_str:                           Converting Floats.   (line  37)
-* mpf_get_ui:                            Converting Floats.   (line  28)
-* mpf_init:                              Initializing Floats. (line  19)
-* mpf_init2:                             Initializing Floats. (line  26)
-* mpf_init_set:                          Simultaneous Float Init & Assign.
-                                                              (line  16)
-* mpf_init_set_d:                        Simultaneous Float Init & Assign.
-                                                              (line  19)
-* mpf_init_set_si:                       Simultaneous Float Init & Assign.
-                                                              (line  18)
-* mpf_init_set_str:                      Simultaneous Float Init & Assign.
-                                                              (line  25)
-* mpf_init_set_ui:                       Simultaneous Float Init & Assign.
-                                                              (line  17)
-* mpf_inits:                             Initializing Floats. (line  31)
-* mpf_inp_str:                           I/O of Floats.       (line  39)
-* mpf_integer_p:                         Miscellaneous Float Functions.
-                                                              (line  14)
-* mpf_mul:                               Float Arithmetic.    (line  19)
-* mpf_mul_2exp:                          Float Arithmetic.    (line  50)
-* mpf_mul_ui:                            Float Arithmetic.    (line  21)
-* mpf_neg:                               Float Arithmetic.    (line  44)
-* mpf_out_str:                           I/O of Floats.       (line  19)
-* mpf_pow_ui:                            Float Arithmetic.    (line  41)
-* mpf_random2:                           Miscellaneous Float Functions.
-                                                              (line  37)
-* mpf_reldiff:                           Float Comparison.    (line  29)
-* mpf_set:                               Assigning Floats.    (line  10)
-* mpf_set_d:                             Assigning Floats.    (line  13)
-* mpf_set_default_prec:                  Initializing Floats. (line   7)
-* mpf_set_prec:                          Initializing Floats. (line  65)
-* mpf_set_prec_raw:                      Initializing Floats. (line  72)
-* mpf_set_q:                             Assigning Floats.    (line  15)
-* mpf_set_si:                            Assigning Floats.    (line  12)
-* mpf_set_str:                           Assigning Floats.    (line  18)
-* mpf_set_ui:                            Assigning Floats.    (line  11)
-* mpf_set_z:                             Assigning Floats.    (line  14)
-* mpf_sgn:                               Float Comparison.    (line  33)
-* mpf_sqrt:                              Float Arithmetic.    (line  36)
-* mpf_sqrt_ui:                           Float Arithmetic.    (line  37)
-* mpf_sub:                               Float Arithmetic.    (line  12)
-* mpf_sub_ui:                            Float Arithmetic.    (line  16)
-* mpf_swap:                              Assigning Floats.    (line  52)
-* mpf_t:                                 Nomenclature and Types.
-                                                              (line  21)
-* mpf_trunc:                             Miscellaneous Float Functions.
-                                                              (line   9)
-* mpf_ui_div:                            Float Arithmetic.    (line  31)
-* mpf_ui_sub:                            Float Arithmetic.    (line  14)
-* mpf_urandomb:                          Miscellaneous Float Functions.
-                                                              (line  27)
-* mpn_add:                               Low-level Functions. (line  69)
-* mpn_add_1:                             Low-level Functions. (line  64)
-* mpn_add_n:                             Low-level Functions. (line  54)
-* mpn_addmul_1:                          Low-level Functions. (line 148)
-* mpn_and_n:                             Low-level Functions. (line 421)
-* mpn_andn_n:                            Low-level Functions. (line 436)
-* mpn_cmp:                               Low-level Functions. (line 284)
-* mpn_com:                               Low-level Functions. (line 461)
-* mpn_copyd:                             Low-level Functions. (line 470)
-* mpn_copyi:                             Low-level Functions. (line 466)
-* mpn_divexact_by3:                      Low-level Functions. (line 229)
-* mpn_divexact_by3c:                     Low-level Functions. (line 231)
-* mpn_divmod:                            Low-level Functions. (line 224)
-* mpn_divmod_1:                          Low-level Functions. (line 208)
-* mpn_divrem:                            Low-level Functions. (line 182)
-* mpn_divrem_1:                          Low-level Functions. (line 206)
-* mpn_gcd:                               Low-level Functions. (line 289)
-* mpn_gcd_1:                             Low-level Functions. (line 299)
-* mpn_gcdext:                            Low-level Functions. (line 305)
-* mpn_get_str:                           Low-level Functions. (line 346)
-* mpn_hamdist:                           Low-level Functions. (line 410)
-* mpn_ior_n:                             Low-level Functions. (line 426)
-* mpn_iorn_n:                            Low-level Functions. (line 441)
-* mpn_lshift:                            Low-level Functions. (line 260)
-* mpn_mod_1:                             Low-level Functions. (line 255)
-* mpn_mul:                               Low-level Functions. (line 114)
-* mpn_mul_1:                             Low-level Functions. (line 133)
-* mpn_mul_n:                             Low-level Functions. (line 103)
-* mpn_nand_n:                            Low-level Functions. (line 446)
-* mpn_neg:                               Low-level Functions. (line  98)
-* mpn_nior_n:                            Low-level Functions. (line 451)
-* mpn_perfect_square_p:                  Low-level Functions. (line 416)
-* mpn_popcount:                          Low-level Functions. (line 406)
-* mpn_random:                            Low-level Functions. (line 395)
-* mpn_random2:                           Low-level Functions. (line 396)
-* mpn_rshift:                            Low-level Functions. (line 272)
-* mpn_scan0:                             Low-level Functions. (line 380)
-* mpn_scan1:                             Low-level Functions. (line 388)
-* mpn_set_str:                           Low-level Functions. (line 361)
-* mpn_sqr:                               Low-level Functions. (line 125)
-* mpn_sqrtrem:                           Low-level Functions. (line 328)
-* mpn_sub:                               Low-level Functions. (line  90)
-* mpn_sub_1:                             Low-level Functions. (line  85)
-* mpn_sub_n:                             Low-level Functions. (line  76)
-* mpn_submul_1:                          Low-level Functions. (line 159)
-* mpn_tdiv_qr:                           Low-level Functions. (line 171)
-* mpn_xnor_n:                            Low-level Functions. (line 456)
-* mpn_xor_n:                             Low-level Functions. (line 431)
-* mpn_zero:                              Low-level Functions. (line 473)
-* mpq_abs:                               Rational Arithmetic. (line  31)
-* mpq_add:                               Rational Arithmetic. (line   7)
-* mpq_canonicalize:                      Rational Number Functions.
-                                                              (line  22)
-* mpq_class:                             C++ Interface General.
-                                                              (line  19)
-* mpq_class::canonicalize:               C++ Interface Rationals.
-                                                              (line  37)
-* mpq_class::get_d:                      C++ Interface Rationals.
-                                                              (line  46)
-* mpq_class::get_den:                    C++ Interface Rationals.
-                                                              (line  58)
-* mpq_class::get_den_mpz_t:              C++ Interface Rationals.
-                                                              (line  68)
-* mpq_class::get_mpq_t:                  C++ Interface General.
-                                                              (line  65)
-* mpq_class::get_num:                    C++ Interface Rationals.
-                                                              (line  57)
-* mpq_class::get_num_mpz_t:              C++ Interface Rationals.
-                                                              (line  67)
-* mpq_class::get_str:                    C++ Interface Rationals.
-                                                              (line  47)
-* mpq_class::mpq_class:                  C++ Interface Rationals.
-                                                              (line  30)
-* mpq_class::set_str:                    C++ Interface Rationals.
-                                                              (line  48)
-* mpq_clear:                             Initializing Rationals.
-                                                              (line  16)
-* mpq_clears:                            Initializing Rationals.
-                                                              (line  20)
-* mpq_cmp:                               Comparing Rationals. (line   7)
-* mpq_cmp_si:                            Comparing Rationals. (line  17)
-* mpq_cmp_ui:                            Comparing Rationals. (line  15)
-* mpq_denref:                            Applying Integer Functions.
-                                                              (line  18)
-* mpq_div:                               Rational Arithmetic. (line  22)
-* mpq_div_2exp:                          Rational Arithmetic. (line  25)
-* mpq_equal:                             Comparing Rationals. (line  33)
-* mpq_get_d:                             Rational Conversions.
-                                                              (line   7)
-* mpq_get_den:                           Applying Integer Functions.
-                                                              (line  24)
-* mpq_get_num:                           Applying Integer Functions.
-                                                              (line  23)
-* mpq_get_str:                           Rational Conversions.
-                                                              (line  22)
-* mpq_init:                              Initializing Rationals.
-                                                              (line   7)
-* mpq_inits:                             Initializing Rationals.
-                                                              (line  12)
-* mpq_inp_str:                           I/O of Rationals.    (line  26)
-* mpq_inv:                               Rational Arithmetic. (line  34)
-* mpq_mul:                               Rational Arithmetic. (line  15)
-* mpq_mul_2exp:                          Rational Arithmetic. (line  18)
-* mpq_neg:                               Rational Arithmetic. (line  28)
-* mpq_numref:                            Applying Integer Functions.
-                                                              (line  17)
-* mpq_out_str:                           I/O of Rationals.    (line  18)
-* mpq_set:                               Initializing Rationals.
-                                                              (line  24)
-* mpq_set_d:                             Rational Conversions.
-                                                              (line  17)
-* mpq_set_den:                           Applying Integer Functions.
-                                                              (line  26)
-* mpq_set_f:                             Rational Conversions.
-                                                              (line  18)
-* mpq_set_num:                           Applying Integer Functions.
-                                                              (line  25)
-* mpq_set_si:                            Initializing Rationals.
-                                                              (line  31)
-* mpq_set_str:                           Initializing Rationals.
-                                                              (line  36)
-* mpq_set_ui:                            Initializing Rationals.
-                                                              (line  29)
-* mpq_set_z:                             Initializing Rationals.
-                                                              (line  25)
-* mpq_sgn:                               Comparing Rationals. (line  27)
-* mpq_sub:                               Rational Arithmetic. (line  11)
-* mpq_swap:                              Initializing Rationals.
-                                                              (line  56)
-* mpq_t:                                 Nomenclature and Types.
-                                                              (line  16)
-* mpz_abs:                               Integer Arithmetic.  (line  42)
-* mpz_add:                               Integer Arithmetic.  (line   7)
-* mpz_add_ui:                            Integer Arithmetic.  (line   9)
-* mpz_addmul:                            Integer Arithmetic.  (line  25)
-* mpz_addmul_ui:                         Integer Arithmetic.  (line  27)
-* mpz_and:                               Integer Logic and Bit Fiddling.
-                                                              (line  11)
-* mpz_array_init:                        Integer Special Functions.
-                                                              (line  11)
-* mpz_bin_ui:                            Number Theoretic Functions.
-                                                              (line  98)
-* mpz_bin_uiui:                          Number Theoretic Functions.
-                                                              (line 100)
-* mpz_cdiv_q:                            Integer Division.    (line  13)
-* mpz_cdiv_q_2exp:                       Integer Division.    (line  24)
-* mpz_cdiv_q_ui:                         Integer Division.    (line  17)
-* mpz_cdiv_qr:                           Integer Division.    (line  15)
-* mpz_cdiv_qr_ui:                        Integer Division.    (line  21)
-* mpz_cdiv_r:                            Integer Division.    (line  14)
-* mpz_cdiv_r_2exp:                       Integer Division.    (line  25)
-* mpz_cdiv_r_ui:                         Integer Division.    (line  19)
-* mpz_cdiv_ui:                           Integer Division.    (line  23)
-* mpz_class:                             C++ Interface General.
-                                                              (line  18)
-* mpz_class::fits_sint_p:                C++ Interface Integers.
-                                                              (line  45)
-* mpz_class::fits_slong_p:               C++ Interface Integers.
-                                                              (line  46)
-* mpz_class::fits_sshort_p:              C++ Interface Integers.
-                                                              (line  47)
-* mpz_class::fits_uint_p:                C++ Interface Integers.
-                                                              (line  48)
-* mpz_class::fits_ulong_p:               C++ Interface Integers.
-                                                              (line  49)
-* mpz_class::fits_ushort_p:              C++ Interface Integers.
-                                                              (line  50)
-* mpz_class::get_d:                      C++ Interface Integers.
-                                                              (line  51)
-* mpz_class::get_mpz_t:                  C++ Interface General.
-                                                              (line  64)
-* mpz_class::get_si:                     C++ Interface Integers.
-                                                              (line  52)
-* mpz_class::get_str:                    C++ Interface Integers.
-                                                              (line  53)
-* mpz_class::get_ui:                     C++ Interface Integers.
-                                                              (line  54)
-* mpz_class::mpz_class:                  C++ Interface Integers.
-                                                              (line  20)
-* mpz_class::set_str:                    C++ Interface Integers.
-                                                              (line  55)
-* mpz_clear:                             Initializing Integers.
-                                                              (line  44)
-* mpz_clears:                            Initializing Integers.
-                                                              (line  48)
-* mpz_clrbit:                            Integer Logic and Bit Fiddling.
-                                                              (line  54)
-* mpz_cmp:                               Integer Comparisons. (line   7)
-* mpz_cmp_d:                             Integer Comparisons. (line   8)
-* mpz_cmp_si:                            Integer Comparisons. (line   9)
-* mpz_cmp_ui:                            Integer Comparisons. (line  10)
-* mpz_cmpabs:                            Integer Comparisons. (line  18)
-* mpz_cmpabs_d:                          Integer Comparisons. (line  19)
-* mpz_cmpabs_ui:                         Integer Comparisons. (line  20)
-* mpz_com:                               Integer Logic and Bit Fiddling.
-                                                              (line  20)
-* mpz_combit:                            Integer Logic and Bit Fiddling.
-                                                              (line  57)
-* mpz_congruent_2exp_p:                  Integer Division.    (line 124)
-* mpz_congruent_p:                       Integer Division.    (line 121)
-* mpz_congruent_ui_p:                    Integer Division.    (line 123)
-* mpz_divexact:                          Integer Division.    (line 101)
-* mpz_divexact_ui:                       Integer Division.    (line 102)
-* mpz_divisible_2exp_p:                  Integer Division.    (line 112)
-* mpz_divisible_p:                       Integer Division.    (line 110)
-* mpz_divisible_ui_p:                    Integer Division.    (line 111)
-* mpz_even_p:                            Miscellaneous Integer Functions.
-                                                              (line  18)
-* mpz_export:                            Integer Import and Export.
-                                                              (line  45)
-* mpz_fac_ui:                            Number Theoretic Functions.
-                                                              (line  95)
-* mpz_fdiv_q:                            Integer Division.    (line  27)
-* mpz_fdiv_q_2exp:                       Integer Division.    (line  38)
-* mpz_fdiv_q_ui:                         Integer Division.    (line  31)
-* mpz_fdiv_qr:                           Integer Division.    (line  29)
-* mpz_fdiv_qr_ui:                        Integer Division.    (line  35)
-* mpz_fdiv_r:                            Integer Division.    (line  28)
-* mpz_fdiv_r_2exp:                       Integer Division.    (line  39)
-* mpz_fdiv_r_ui:                         Integer Division.    (line  33)
-* mpz_fdiv_ui:                           Integer Division.    (line  37)
-* mpz_fib2_ui:                           Number Theoretic Functions.
-                                                              (line 108)
-* mpz_fib_ui:                            Number Theoretic Functions.
-                                                              (line 106)
-* mpz_fits_sint_p:                       Miscellaneous Integer Functions.
-                                                              (line  10)
-* mpz_fits_slong_p:                      Miscellaneous Integer Functions.
-                                                              (line   8)
-* mpz_fits_sshort_p:                     Miscellaneous Integer Functions.
-                                                              (line  12)
-* mpz_fits_uint_p:                       Miscellaneous Integer Functions.
-                                                              (line   9)
-* mpz_fits_ulong_p:                      Miscellaneous Integer Functions.
-                                                              (line   7)
-* mpz_fits_ushort_p:                     Miscellaneous Integer Functions.
-                                                              (line  11)
-* mpz_gcd:                               Number Theoretic Functions.
-                                                              (line  30)
-* mpz_gcd_ui:                            Number Theoretic Functions.
-                                                              (line  35)
-* mpz_gcdext:                            Number Theoretic Functions.
-                                                              (line  45)
-* mpz_get_d:                             Converting Integers. (line  27)
-* mpz_get_d_2exp:                        Converting Integers. (line  35)
-* mpz_get_si:                            Converting Integers. (line  18)
-* mpz_get_str:                           Converting Integers. (line  46)
-* mpz_get_ui:                            Converting Integers. (line  11)
-* mpz_getlimbn:                          Integer Special Functions.
-                                                              (line  60)
-* mpz_hamdist:                           Integer Logic and Bit Fiddling.
-                                                              (line  29)
-* mpz_import:                            Integer Import and Export.
-                                                              (line  11)
-* mpz_init:                              Initializing Integers.
-                                                              (line  26)
-* mpz_init2:                             Initializing Integers.
-                                                              (line  33)
-* mpz_init_set:                          Simultaneous Integer Init & Assign.
-                                                              (line  27)
-* mpz_init_set_d:                        Simultaneous Integer Init & Assign.
-                                                              (line  30)
-* mpz_init_set_si:                       Simultaneous Integer Init & Assign.
-                                                              (line  29)
-* mpz_init_set_str:                      Simultaneous Integer Init & Assign.
-                                                              (line  34)
-* mpz_init_set_ui:                       Simultaneous Integer Init & Assign.
-                                                              (line  28)
-* mpz_inits:                             Initializing Integers.
-                                                              (line  29)
-* mpz_inp_raw:                           I/O of Integers.     (line  61)
-* mpz_inp_str:                           I/O of Integers.     (line  30)
-* mpz_invert:                            Number Theoretic Functions.
-                                                              (line  60)
-* mpz_ior:                               Integer Logic and Bit Fiddling.
-                                                              (line  14)
-* mpz_jacobi:                            Number Theoretic Functions.
-                                                              (line  66)
-* mpz_kronecker:                         Number Theoretic Functions.
-                                                              (line  74)
-* mpz_kronecker_si:                      Number Theoretic Functions.
-                                                              (line  75)
-* mpz_kronecker_ui:                      Number Theoretic Functions.
-                                                              (line  76)
-* mpz_lcm:                               Number Theoretic Functions.
-                                                              (line  54)
-* mpz_lcm_ui:                            Number Theoretic Functions.
-                                                              (line  55)
-* mpz_legendre:                          Number Theoretic Functions.
-                                                              (line  69)
-* mpz_lucnum2_ui:                        Number Theoretic Functions.
-                                                              (line 119)
-* mpz_lucnum_ui:                         Number Theoretic Functions.
-                                                              (line 117)
-* mpz_mod:                               Integer Division.    (line  91)
-* mpz_mod_ui:                            Integer Division.    (line  93)
-* mpz_mul:                               Integer Arithmetic.  (line  19)
-* mpz_mul_2exp:                          Integer Arithmetic.  (line  35)
-* mpz_mul_si:                            Integer Arithmetic.  (line  20)
-* mpz_mul_ui:                            Integer Arithmetic.  (line  22)
-* mpz_neg:                               Integer Arithmetic.  (line  39)
-* mpz_nextprime:                         Number Theoretic Functions.
-                                                              (line  23)
-* mpz_odd_p:                             Miscellaneous Integer Functions.
-                                                              (line  17)
-* mpz_out_raw:                           I/O of Integers.     (line  45)
-* mpz_out_str:                           I/O of Integers.     (line  18)
-* mpz_perfect_power_p:                   Integer Roots.       (line  27)
-* mpz_perfect_square_p:                  Integer Roots.       (line  36)
-* mpz_popcount:                          Integer Logic and Bit Fiddling.
-                                                              (line  23)
-* mpz_pow_ui:                            Integer Exponentiation.
-                                                              (line  31)
-* mpz_powm:                              Integer Exponentiation.
-                                                              (line   8)
-* mpz_powm_sec:                          Integer Exponentiation.
-                                                              (line  18)
-* mpz_powm_ui:                           Integer Exponentiation.
-                                                              (line  10)
-* mpz_probab_prime_p:                    Number Theoretic Functions.
-                                                              (line   7)
-* mpz_random:                            Integer Random Numbers.
-                                                              (line  42)
-* mpz_random2:                           Integer Random Numbers.
-                                                              (line  51)
-* mpz_realloc2:                          Initializing Integers.
-                                                              (line  52)
-* mpz_remove:                            Number Theoretic Functions.
-                                                              (line  90)
-* mpz_root:                              Integer Roots.       (line   7)
-* mpz_rootrem:                           Integer Roots.       (line  13)
-* mpz_rrandomb:                          Integer Random Numbers.
-                                                              (line  31)
-* mpz_scan0:                             Integer Logic and Bit Fiddling.
-                                                              (line  37)
-* mpz_scan1:                             Integer Logic and Bit Fiddling.
-                                                              (line  38)
-* mpz_set:                               Assigning Integers.  (line  10)
-* mpz_set_d:                             Assigning Integers.  (line  13)
-* mpz_set_f:                             Assigning Integers.  (line  15)
-* mpz_set_q:                             Assigning Integers.  (line  14)
-* mpz_set_si:                            Assigning Integers.  (line  12)
-* mpz_set_str:                           Assigning Integers.  (line  21)
-* mpz_set_ui:                            Assigning Integers.  (line  11)
-* mpz_setbit:                            Integer Logic and Bit Fiddling.
-                                                              (line  51)
-* mpz_sgn:                               Integer Comparisons. (line  28)
-* mpz_si_kronecker:                      Number Theoretic Functions.
-                                                              (line  77)
-* mpz_size:                              Integer Special Functions.
-                                                              (line  68)
-* mpz_sizeinbase:                        Miscellaneous Integer Functions.
-                                                              (line  23)
-* mpz_sqrt:                              Integer Roots.       (line  17)
-* mpz_sqrtrem:                           Integer Roots.       (line  20)
-* mpz_sub:                               Integer Arithmetic.  (line  12)
-* mpz_sub_ui:                            Integer Arithmetic.  (line  14)
-* mpz_submul:                            Integer Arithmetic.  (line  30)
-* mpz_submul_ui:                         Integer Arithmetic.  (line  32)
-* mpz_swap:                              Assigning Integers.  (line  37)
-* mpz_t:                                 Nomenclature and Types.
-                                                              (line   6)
-* mpz_tdiv_q:                            Integer Division.    (line  41)
-* mpz_tdiv_q_2exp:                       Integer Division.    (line  52)
-* mpz_tdiv_q_ui:                         Integer Division.    (line  45)
-* mpz_tdiv_qr:                           Integer Division.    (line  43)
-* mpz_tdiv_qr_ui:                        Integer Division.    (line  49)
-* mpz_tdiv_r:                            Integer Division.    (line  42)
-* mpz_tdiv_r_2exp:                       Integer Division.    (line  53)
-* mpz_tdiv_r_ui:                         Integer Division.    (line  47)
-* mpz_tdiv_ui:                           Integer Division.    (line  51)
-* mpz_tstbit:                            Integer Logic and Bit Fiddling.
-                                                              (line  60)
-* mpz_ui_kronecker:                      Number Theoretic Functions.
-                                                              (line  78)
-* mpz_ui_pow_ui:                         Integer Exponentiation.
-                                                              (line  33)
-* mpz_ui_sub:                            Integer Arithmetic.  (line  16)
-* mpz_urandomb:                          Integer Random Numbers.
-                                                              (line  14)
-* mpz_urandomm:                          Integer Random Numbers.
-                                                              (line  23)
-* mpz_xor:                               Integer Logic and Bit Fiddling.
-                                                              (line  17)
-* msqrt:                                 BSD Compatible Functions.
-                                                              (line  63)
-* msub:                                  BSD Compatible Functions.
-                                                              (line  46)
-* mtox:                                  BSD Compatible Functions.
-                                                              (line  98)
-* mult:                                  BSD Compatible Functions.
-                                                              (line  49)
-* operator%:                             C++ Interface Integers.
-                                                              (line  30)
-* operator/:                             C++ Interface Integers.
-                                                              (line  29)
-* operator<<:                            C++ Formatted Output.
-                                                              (line  11)
-* operator>> <1>:                        C++ Formatted Input. (line  11)
-* operator>> <2>:                        C++ Interface Rationals.
-                                                              (line  77)
-* operator>>:                            C++ Formatted Input. (line  14)
-* pow:                                   BSD Compatible Functions.
-                                                              (line  71)
-* rpow:                                  BSD Compatible Functions.
-                                                              (line  79)
-* sdiv:                                  BSD Compatible Functions.
-                                                              (line  55)
-* sgn <1>:                               C++ Interface Rationals.
-                                                              (line  50)
-* sgn <2>:                               C++ Interface Integers.
-                                                              (line  57)
-* sgn:                                   C++ Interface Floats.
-                                                              (line  98)
-* sqrt <1>:                              C++ Interface Floats.
-                                                              (line  99)
-* sqrt:                                  C++ Interface Integers.
-                                                              (line  58)
-* trunc:                                 C++ Interface Floats.
-                                                              (line 100)
-* xtom:                                  BSD Compatible Functions.
-                                                              (line  34)
-
-
diff --git a/mpc/doc/mpc.info b/mpc/doc/mpc.info
deleted file mode 100644
index 1542a0d..0000000
--- a/mpc/doc/mpc.info
+++ /dev/null
@@ -1,1322 +0,0 @@
-This is mpc.info, produced by makeinfo version 4.13 from mpc.texi.
-
-START-INFO-DIR-ENTRY
-* mpc: (mpc.info).               Multiple Precision Complex Library.
-END-INFO-DIR-ENTRY
-
-   This is the manual for MPC, a library for multiple precision complex
-arithmetic, version 0.9, of February 2011.
-
-
-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-2011 INRIA
-
-
-
-   Permission is granted to make and distribute verbatim copies of this
-manual provided the copyright notice and this permission notice are
-preserved on all copies.
-
-   Permission is granted to copy and distribute modified versions of
-this manual under the conditions for verbatim copying, provided that
-the entire resulting derived work is distributed under the terms of a
-permission notice identical to this one.
-
-   Permission is granted to copy and distribute translations of this
-manual into another language, under the above conditions for modified
-versions.
-
-
-File: mpc.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)
-
-MPC
-***
-
-This manual documents how to install and use the Multiple Precision
-Complex Library, version 0.9
-
-* Menu:
-
-* Copying::                     MPC Copying Conditions (LGPL).
-* Introduction to MPC::         Brief introduction to MPC.
-* Installing MPC::              How to configure and compile the MPC library.
-* Reporting Bugs::              How to usefully report bugs.
-* MPC Basics::                  What every MPC user should know.
-* Complex Functions::           Functions for arithmetic on complex numbers.
-* Contributors::
-* References::
-* Concept Index::
-* Function Index::
-
-
-File: mpc.info,  Node: Copying,  Next: Introduction to MPC,  Prev: Top,  Up: Top
-
-MPC Copying Conditions
-**********************
-
-The MPC Library is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as
-published by the Free Software Foundation; either version 2.1 of the
-License, or (at your option) any later version, see the file
-COPYING.LIB.
-
-   The MPC Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-
-File: mpc.info,  Node: Introduction to MPC,  Next: Installing MPC,  Prev: Copying,  Up: Top
-
-1 Introduction to MPC
-*********************
-
-MPC is a portable library written in C for arbitrary precision
-arithmetic on complex numbers providing correct rounding. Ultimately, it
-should implement a multiprecision equivalent of the C99 standard.  It
-builds upon the GNU MP and the GNU MPFR libraries.
-
-1.1 How to use this Manual
-==========================
-
-Everyone should read *note MPC Basics::.  If you need to install the
-library yourself, you need to read *note Installing MPC::, too.
-
-   The remainder of the manual can be used for later reference,
-although it is probably a good idea to skim through it.
-
-
-File: mpc.info,  Node: Installing MPC,  Next: Reporting Bugs,  Prev: Introduction to MPC,  Up: Top
-
-2 Installing MPC
-****************
-
-To build MPC, you first have to install GNU MP (version 4.3.2 or
-higher) and GNU MPFR (version 2.4.2 or higher) on your computer.  You
-need a C compiler, preferably GCC, but any reasonable compiler should
-work. And you need a standard Unix `make' program, plus some other
-standard Unix utility programs.
-
-   Here are the steps needed to install the library on Unix systems:
-
-  1. `tar xzf mpc-0.9.tar.gz'
-
-  2. `cd mpc-0.9'
-
-  3. `./configure'
-
-     if GMP and MPFR are installed into standard directories, that is,
-     directories that are searched by default by the compiler and the
-     linking tools.
-
-     `./configure --with-gmp=<gmp_install_dir>'
-
-     is used to indicate a different location where GMP is installed.
-     Alternatively, you can specify directly GMP include and GMP lib
-     directories with `./configure --with-gmp-lib=<gmp_lib_dir>
-     --with-gmp-include=<gmp_include_dir>'.
-
-     `./configure --with-mpfr=<mpfr_install_dir>'
-
-     is used to indicate a different location where MPFR is installed.
-     Alternatively, you can specify directly MPFR include and MPFR lib
-     directories with `./configure --with-mpf-lib=<mpfr_lib_dir>
-     --with-mpfr-include=<mpfr_include_dir>'.
-
-     Another useful parameter is `--prefix', which can be used to
-     specify an alternative installation location instead of
-     `/usr/local'; see `make install' below.
-
-     If for debugging purposes you wish to log calls to MPC functions
-     from within your code, add the parameter `--enable-logging'.  In
-     your code, replace the inclusion of `mpc.h' by `mpc-log.h' and
-     link the executable dynamically.  Then all calls to functions with
-     only complex arguments are printed to `stderr' in the following
-     form: First, the function name is given, followed by its type such
-     as `c_cc', meaning that the function has one complex result (one
-     `c' in front of the `_'), computed from two complex arguments (two
-     `c' after the `_'). Then, the precisions of the real and the
-     imaginary part of the first result is given, followed by the
-     second one and so on. Finally, for each argument, the precisions
-     of its real and imaginary part are specified and the argument
-     itself is printed in hexadecimal via the function `mpc_out_str'
-     (*note String and Stream Input and Output: string-io.).
-
-     Use `./configure --help' for an exhaustive list of parameters.
-
-  4. `make'
-
-     This compiles MPC in the working directory.
-
-  5. `make check'
-
-     This will make sure MPC was built correctly.
-
-     If you get error messages, please report them to
-     `mpc-discuss@lists.gforge.inria.fr' (*Note Reporting Bugs::, for
-     information on what to include in useful bug reports).
-
-  6. `make install'
-
-     This will copy the file `mpc.h' to the directory
-     `/usr/local/include', the file `libmpc.a' to the directory
-     `/usr/local/lib', and the file `mpc.info' to the directory
-     `/usr/local/share/info' (or if you passed the `--prefix' option to
-     `configure', using the prefix directory given as argument to
-     `--prefix' instead of `/usr/local'). Note: you need write
-     permissions on these directories.
-
-
-2.1 Other `make' Targets
-========================
-
-There are some other useful make targets:
-
-   * `info'
-
-     Create an info version of the manual, in `mpc.info'.
-
-   * `pdf'
-
-     Create a PDF version of the manual, in `doc/mpc.pdf'.
-
-   * `dvi'
-
-     Create a DVI version of the manual, in `doc/mpc.dvi'.
-
-   * `ps'
-
-     Create a Postscript version of the manual, in `doc/mpc.ps'.
-
-   * `html'
-
-     Create an HTML version of the manual, in several pages in the
-     directory `doc/mpc.html'; if you want only one output HTML file,
-     then type `makeinfo --html --no-split mpc.texi' instead.
-
-   * `clean'
-
-     Delete all object files and archive files, but not the
-     configuration files.
-
-   * `distclean'
-
-     Delete all files not included in the distribution.
-
-   * `uninstall'
-
-     Delete all files copied by `make install'.
-
-2.2 Known Build Problems
-========================
-
-On AIX, if GMP was built with the 64-bit ABI, before building and
-testing MPC, it might be necessary to set the `OBJECT_MODE' environment
-variable to 64 by, e.g.,
-
-   `export OBJECT_MODE=64'
-
-   This has been tested with the C compiler IBM XL C/C++ Enterprise
-Edition V8.0 for AIX, version: 08.00.0000.0021, GMP 4.2.4 and MPFR
-2.4.1.
-
-   Please report any other problems you encounter to
-`mpc-discuss@lists.gforge.inria.fr'.  *Note Reporting Bugs::.
-
-
-File: mpc.info,  Node: Reporting Bugs,  Next: MPC Basics,  Prev: Installing MPC,  Up: Top
-
-3 Reporting Bugs
-****************
-
-If you think you have found a bug in the MPC library, please investigate
-and report it. We have made this library available to you, and it is
-not to ask too much from you, to ask you to report the bugs that you
-find.
-
-   There are a few things you should think about when you put your bug
-report together.
-
-   You have to send us a test case that makes it possible for us to
-reproduce the bug.  Include instructions on how to run the test case.
-
-   You also have to explain what is wrong; if you get a crash, or if
-the results printed are incorrect and in that case, in what way.
-
-   Please include compiler version information in your bug report.
-This can be extracted using `gcc -v', or `cc -V' on some machines.
-Also, include the output from `uname -a'.
-
-   If your bug report is good, we will do our best to help you to get a
-corrected version of the library; if the bug report is poor, we will
-not do anything about it (aside of chiding you to send better bug
-reports).
-
-   Send your bug report to: `mpc-discuss@lists.gforge.inria.fr'.
-
-   If you think something in this manual is unclear, or downright
-incorrect, or if the language needs to be improved, please send a note
-to the same address.
-
-
-File: mpc.info,  Node: MPC Basics,  Next: Complex Functions,  Prev: Reporting Bugs,  Up: Top
-
-4 MPC Basics
-************
-
-All declarations needed to use MPC are collected in the include file
-`mpc.h'.  It is designed to work with both C and C++ compilers.  You
-should include that file in any program using the MPC library by adding
-the line
-        #include "mpc.h"
-
-4.1 Nomenclature and Types
-==========================
-
-"Complex number" or "Complex" for short, is a pair of two arbitrary
-precision floating-point numbers (for the real and imaginary parts).
-The C data type for such objects is `mpc_t'.
-
-The "Precision" is the number of bits used to represent the mantissa of
-the real and imaginary parts; the corresponding C data type is
-`mpfr_prec_t'.  For more details on the allowed precision range, *note
-Nomenclature and Types: (mpfr.info)Nomenclature and Types.
-
-The "rounding mode" specifies the way to round the result of a complex
-operation, in case the exact result can not be represented exactly in
-the destination mantissa; the corresponding C data type is `mpc_rnd_t'.
-A complex rounding mode is a pair of two rounding modes: one for the
-real part, one for the imaginary part.
-
-4.2 Function Classes
-====================
-
-There is only one class of functions in the MPC library, namely
-functions for complex arithmetic. The function names begin with `mpc_'.
-The associated type is `mpc_t'.
-
-4.3 MPC Variable Conventions
-============================
-
-As a general rule, all MPC functions expect output arguments before
-input arguments.  This notation is based on an analogy with the
-assignment operator.
-
-   MPC allows you to use the same variable for both input and output in
-the same expression.  For example, the main function for floating-point
-multiplication, `mpc_mul', can be used like this: `mpc_mul (x, x, x,
-rnd_mode)'.  This computes the square of X with rounding mode `rnd_mode'
-and puts the result back in X.
-
-   Before you can assign to an MPC variable, you need to initialize it
-by calling one of the special initialization functions.  When you are
-done with a variable, you need to clear it out, using one of the
-functions for that purpose.
-
-   A variable should only be initialized once, or at least cleared out
-between each initialization.  After a variable has been initialized, it
-may be assigned to any number of times.
-
-   For efficiency reasons, avoid to initialize and clear out a variable
-in loops.  Instead, initialize it before entering the loop, and clear
-it out after the loop has exited.
-
-   You do not need to be concerned about allocating additional space
-for MPC variables, since each of its real and imaginary part has a
-mantissa of fixed size.  Hence unless you change its precision, or
-clear and reinitialize it, a complex variable will have the same
-allocated space during all its life.
-
-4.4 Rounding Modes
-==================
-
-A complex rounding mode is of the form `MPC_RNDxy' where `x' and `y'
-are one of `N' (to nearest), `Z' (towards zero), `U' (towards plus
-infinity), `D' (towards minus infinity).  The first letter refers to
-the rounding mode for the real part, and the second one for the
-imaginary part.  For example `MPC_RNDZU' indicates to round the real
-part towards zero, and the imaginary part towards plus infinity.
-
-   The `round to nearest' mode works as in the IEEE P754 standard: in
-case the number to be rounded lies exactly in the middle of two
-representable numbers, it is rounded to the one with the least
-significant bit set to zero.  For example, the number 5, which is
-represented by (101) in binary, is rounded to (100)=4 with a precision
-of two bits, and not to (110)=6.
-
-4.5 Return Value
-================
-
-Most MPC functions have a return value of type `int', which is used to
-indicate the position of the rounded real and imaginary parts with
-respect to the exact (infinite precision) values.  If this integer is
-`i', the macros `MPC_INEX_RE(i)' and `MPC_INEX_IM(i)' give 0 if the
-corresponding rounded value is exact, a negative value if the rounded
-value is less than the exact one, and a positive value if it is greater
-than the exact one.  Similarly, functions computing a result of type
-`mpfr_t' return an integer that is 0, positive or negative depending on
-whether the rounded value is the same, larger or smaller then the exact
-result.
-
-   Some functions, such as `mpc_sin_cos', compute two complex results;
-the macros `MPC_INEX1(i)' and `MPC_INEX2(i)', applied to the return
-value `i' of such a function, yield the exactness value corresponding
-to the first or the second computed value, respectively.
-
-4.6 Branch Cuts And Special Values
-==================================
-
-Some complex functions have branch cuts, across which the function is
-discontinous. In MPC, the branch cuts chosen are the same as those
-specified for the corresponding functions in the ISO C99 standard.
-
-   Likewise, when evaluated at a point whose real or imaginary part is
-either infinite or a NaN or a signed zero, a function returns the same
-value as those specified for the corresponding function in the ISO C99
-standard.
-
-
-File: mpc.info,  Node: Complex Functions,  Next: Contributors,  Prev: MPC Basics,  Up: Top
-
-5 Complex Functions
-*******************
-
-The complex functions expect arguments of type `mpc_t'.
-
-   The MPC floating-point functions have an interface that is similar
-to the GNU MP integer functions.  The function prefix for operations on
-complex numbers is `mpc_'.
-
-   The precision of a computation is defined as follows: Compute the
-requested operation exactly (with "infinite precision"), and round the
-result to the destination variable precision with the given rounding
-mode.
-
-   The MPC complex functions are intended to be a smooth extension of
-the IEEE P754 arithmetic. The results obtained on one computer should
-not differ from the results obtained on a computer with a different
-word size.
-
-* Menu:
-
-* Initializing Complex Numbers::
-* Assigning Complex Numbers::
-* Converting Complex Numbers::
-* String and Stream Input and Output::
-* Complex Comparison::
-* Projection & Decomposing::
-* Basic Arithmetic::
-* Power Functions and Logarithm::
-* Trigonometric Functions::
-* Miscellaneous Complex Functions::
-* Advanced Functions::
-* Internals::
-
-
-File: mpc.info,  Node: Initializing Complex Numbers,  Next: Assigning Complex Numbers,  Prev: Complex Functions,  Up: Complex Functions
-
-5.1 Initialization Functions
-============================
-
-An `mpc_t' object must be initialized before storing the first value in
-it.  The functions `mpc_init2' and `mpc_init3' are used for that
-purpose.
-
- -- Function: void mpc_init2 (mpc_t Z, mpfr_prec_t PREC)
-     Initialize Z to precision PREC bits and set its real and imaginary
-     parts to NaN.  Normally, a variable should be initialized once only
-     or at least be cleared, using `mpc_clear', between initializations.
-
- -- Function: void mpc_init3 (mpc_t Z, mpfr_prec_t PREC_R, mpfr_prec_t
-          PREC_I)
-     Initialize Z with the precision of its real part being PREC_R bits
-     and the precision of its imaginary part being PREC_I bits, and set
-     the real and imaginary parts to NaN.
-
- -- Function: void mpc_clear (mpc_t Z)
-     Free the space occupied by Z.  Make sure to call this function for
-     all `mpc_t' variables when you are done with them.
-
-   Here is an example on how to initialize complex variables:
-     {
-       mpc_t x, y;
-       mpc_init2 (x, 256);		/* precision _exactly_ 256 bits */
-       mpc_init3 (y, 100, 50);	/* 100/50 bits for the real/imaginary part */
-       ...
-       mpc_clear (x);
-       mpc_clear (y);
-     }
-
-   The following function is useful for changing the precision during a
-calculation.  A typical use would be for adjusting the precision
-gradually in iterative algorithms like Newton-Raphson, making the
-computation precision closely match the actual accurate part of the
-numbers.
-
- -- Function: void mpc_set_prec (mpc_t X, mpfr_prec_t PREC)
-     Reset the precision of X to be *exactly* PREC bits, and set its
-     real/imaginary parts to NaN.  The previous value stored in X is
-     lost. It is equivalent to a call to `mpc_clear(x)' followed by a
-     call to `mpc_init2(x, prec)', but more efficient as no allocation
-     is done in case the current allocated space for the mantissa of X
-     is sufficient.
-
- -- Function: mpfr_prec_t mpc_get_prec (mpc_t X)
-     If the real and imaginary part of X have the same precision, it is
-     returned, otherwise, 0 is returned.
-
- -- Function: void mpc_get_prec2 (mpfr_prec_t* PR, mpfr_prec_t* PI,
-          mpc_t X)
-     Returns the precision of the real part of X via PR and of its
-     imaginary part via PI.
-
-
-File: mpc.info,  Node: Assigning Complex Numbers,  Next: Converting Complex Numbers,  Prev: Initializing Complex Numbers,  Up: Complex Functions
-
-5.2 Assignment Functions
-========================
-
-These functions assign new values to already initialized complex numbers
-(*note Initializing Complex Numbers::).  When using any functions with
-`intmax_t' or `uintmax_t' parameters, you must include `<stdint.h>' or
-`<inttypes.h>' _before_ `mpc.h', to allow `mpc.h' to define prototypes
-for these functions.  Similarly, functions with parameters of type
-`complex' or `long complex' are defined only if `<complex.h>' is
-included _before_ `mpc.h'.  If you need assignment functions that are
-not in the current API, you can define them using the `MPC_SET_X_Y'
-macro (*note Advanced Functions::).
-
- -- Function: int mpc_set (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set the value of ROP from OP, rounded to the precision of ROP with
-     the given rounding mode RND.
-
- -- Function: int mpc_set_ui (mpc_t ROP, unsigned long int OP,
-          mpc_rnd_t RND)
- -- Function: int mpc_set_si (mpc_t ROP, long int OP, mpc_rnd_t RND)
- -- Function: int mpc_set_uj (mpc_t ROP, uintmax_t OP, mpc_rnd_t RND)
- -- Function: int mpc_set_sj (mpc_t ROP, intmax_t OP, mpc_rnd_t RND)
- -- Function: int mpc_set_d (mpc_t ROP, double OP, mpc_rnd_t RND)
- -- Function: int mpc_set_ld (mpc_t ROP, long double OP, mpc_rnd_t RND)
- -- Function: int mpc_set_dc (mpc_t ROP, double _Complex OP, mpc_rnd_t
-          RND)
- -- Function: int mpc_set_ldc (mpc_t ROP, long double _Complex OP,
-          mpc_rnd_t RND)
- -- Function: int mpc_set_z (mpc_t ROP, mpz_t OP mpc_rnd_t RND)
- -- Function: int mpc_set_q (mpc_t ROP, mpq_t OP mpc_rnd_t RND)
- -- Function: int mpc_set_f (mpc_t ROP, mpf_t OP mpc_rnd_t RND)
- -- Function: int mpc_set_fr (mpc_t ROP, mpfr_t OP, mpc_rnd_t RND)
-     Set the value of ROP from OP, rounded to the precision of ROP with
-     the given rounding mode RND.  The argument OP is interpreted as
-     real, so the imaginary part of ROP is set to zero with a positive
-     sign.  Please note that even a `long int' may have to be rounded,
-     if the destination precision is less than the machine word width.
-     For `mpc_set_d', be careful that the input number OP may not be
-     exactly representable as a double-precision number (this happens
-     for 0.1 for instance), in which case it is first rounded by the C
-     compiler to a double-precision number, and then only to a complex
-     number.
-
- -- Function: int mpc_set_ui_ui (mpc_t ROP, unsigned long int OP1,
-          unsigned long int OP2, mpc_rnd_t RND)
- -- Function: int mpc_set_si_si (mpc_t ROP, long int OP1, long int OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_set_uj_uj (mpc_t ROP, uintmax_t OP1, uintmax_t
-          OP2, mpc_rnd_t RND)
- -- Function: int mpc_set_sj_sj (mpc_t ROP, intmax_t OP1, intmax_t OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_set_d_d (mpc_t ROP, double OP1, double OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_set_ld_ld (mpc_t ROP, long double OP1, long
-          double OP2, mpc_rnd_t RND)
- -- Function: int mpc_set_z_z (mpc_t ROP, mpz_t OP1, mpz_t OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_set_q_q (mpc_t ROP, mpq_t OP1, mpq_t OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_set_f_f (mpc_t ROP, mpf_t OP1, mpf_t OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_set_fr_fr (mpc_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpc_rnd_t RND)
-     Set the real part of ROP from OP1, and its imaginary part from
-     OP2, according to the rounding mode RND.
-
-     Beware that the behaviour of `mpc_set_fr_fr' is undefined if OP1
-     or OP2 is a pointer to the real or imaginary part of ROP.  To
-     exchange the real and the imaginary part of a complex number,
-     either use `mpfr_swap (mpc_realref (rop), mpc_imagref (rop))',
-     which also exchanges the precisions of the two parts; or use a
-     temporary variable.
-
-   For functions assigning complex variables from strings or input
-streams, *note String and Stream Input and Output: string-io.
-
- -- Function: void mpc_set_nan (mpc_t ROP)
-     Set ROP to Nan+i*NaN.
-
- -- Function: void mpc_swap (mpc_t OP1, mpc_t OP2)
-     Swap the values of OP1 and OP2 efficiently. Warning: The
-     precisions are exchanged, too; in case these are different,
-     `mpc_swap' is thus not equivalent to three `mpc_set' calls using a
-     third auxiliary variable.
-
-
-File: mpc.info,  Node: Converting Complex Numbers,  Next: String and Stream Input and Output,  Prev: Assigning Complex Numbers,  Up: Complex Functions
-
-5.3 Conversion Functions
-========================
-
-The following functions are available only if `<complex.h>' is included
-_before_ `mpc.h'.
-
- -- Function: double _Complex mpc_get_dc (mpc_t OP, mpc_rnd_t RND)
- -- Function: long double _Complex mpc_get_ldc (mpc_t OP, mpc_rnd_t RND)
-     Convert OP to a C complex number, using the rounding mode RND.
-
-   For functions converting complex variables to strings or stream
-output, *note String and Stream Input and Output: string-io.
-
-
-File: mpc.info,  Node: String and Stream Input and Output,  Next: Complex Comparison,  Prev: Converting Complex Numbers,  Up: Complex Functions
-
-5.4 String and Stream Input and Output
-======================================
-
- -- Function: int mpc_strtoc (mpc_t ROP, const char *NPTR, char
-          **ENDPTR, int BASE, mpc_rnd_t RND)
-     Read a complex number from a string NPTR in base BASE, rounded to
-     the precision of ROP with the given rounding mode RND.  The BASE
-     must be either 0 or a number from 2 to 36 (otherwise the behaviour
-     is undefined).  If NPTR starts with valid data, the result is
-     stored in ROP, the usual inexact value is returned (*note Return
-     Value: return-value.) and, if ENDPTR is not the null pointer,
-     *ENDPTR points to the character just after the valid data.
-     Otherwise, ROP is set to `NaN + i * NaN', -1 is returned and, if
-     ENDPTR is not the null pointer, the value of NPTR is stored in the
-     location referenced by ENDPTR.
-
-     The expected form of a complex number string is either a real
-     number (an optional leading whitespace, an optional sign followed
-     by a floating-point number), or a pair of real numbers in
-     parentheses separated by whitespace. If a real number is read, the
-     missing imaginary part is set to +0.  The form of a floating-point
-     number depends on the base and is described in the documentation
-     of `mpfr_strtofr' (*note Assignment Functions:
-     (mpfr.info)Assignment Functions.).  For instance, `"3.1415926"',
-     `"(1.25e+7 +.17)"', `"(@nan@ 2)"' and `"(-0 -7)"' are valid
-     strings for BASE = 10.  If BASE = 0, then a prefix may be used to
-     indicate the base in which the floating-point number is written.
-     Use prefix '0b' for binary numbers, prefix '0x' for hexadecimal
-     numbers, and no prefix for decimal numbers.  The real and
-     imaginary part may then be written in different bases.  For
-     instance, `"(1.024e+3 +2.05e+3)"' and `"(0b1p+10 +0x802)"' are
-     valid strings for `base'=0 and represent the same value.
-
- -- Function: int mpc_set_str (mpc_t ROP, const char *S, int BASE,
-          mpc_rnd_t rnd)
-     Set ROP to the value of the string S in base BASE, rounded to the
-     precision of ROP with the given rounding mode RND.  See the
-     documentation of `mpc_strtoc' for a detailed description of the
-     valid string formats.  Contrarily to `mpc_strtoc', `mpc_set_str'
-     requires the _whole_ string to represent a valid complex number
-     (potentially followed by additional white space).  This function
-     returns the usual inexact value (*note Return Value:
-     return-value.) if the entire string up to the final null character
-     is a valid number in base BASE; otherwise it returns -1, and ROP
-     is set to NaN+i*NaN.
-
- -- Function: char * mpc_get_str (int B, size_t N, mpc_t OP, mpc_rnd_t
-          RND)
-     Convert OP to a string containing its real and imaginary parts,
-     separated by a space and enclosed in a pair of parentheses.  The
-     numbers are written in base B (which may vary from 2 to 36) and
-     rounded according to RND. The number of significant digits, at
-     least 2, is given by N. It is also possible to let N be zero, in
-     which case the number of digits is chosen large enough so that
-     re-reading the printed value with the same precision, assuming
-     both output and input use rounding to nearest, will recover the
-     original value of OP.  Note that `mpc_get_str' uses the decimal
-     point of the current locale if available, and `.' otherwise.
-
-     The string is generated using the current memory allocation
-     function (`malloc' by default, unless it has been modified using
-     the custom memory allocation interface of `gmp'); once it is not
-     needed any more, it should be freed by calling `mpc_free_str'.
-
- -- Function: void mpc_free_str (char *STR)
-     Free the string STR, which needs to have been allocated by a call
-     to `mpc_get_str'.
-
-   The following two functions read numbers from input streams and write
-them to output streams.  When using any of these functions, you need to
-include `stdio.h' _before_ `mpc.h'.
-
- -- Function: int mpc_inp_str (mpc_t ROP, FILE *STREAM, size_t *READ,
-          int BASE, mpc_rnd_t RND)
-     Input a string in base BASE in the same format as for `mpc_strtoc'
-     from stdio stream STREAM, rounded according to RND, and put the
-     read complex number into ROP.  If STREAM is the null pointer, ROP
-     is read from `stdin'.  Return the usual inexact value; if an error
-     occurs, set ROP to `NaN + i * NaN' and return -1.  If READ is not
-     the null pointer, it is set to the number of read characters.
-
-     Unlike `mpc_strtoc', the function `mpc_inp_str' does not possess
-     perfect knowledge of the string to transform and has to read it
-     character by character, so it behaves slightly differently: It
-     tries to read a string describing a complex number and processes
-     this string through a call to `mpc_set_str'. Precisely, after
-     skipping optional whitespace, a minimal string is read according
-     to the regular expression `mpfr | '(' \s* mpfr \s+ mpfr \s* ')'',
-     where `\s' denotes a whitespace, and `mpfr' is either a string
-     containing neither whitespaces nor parentheses, or
-     `nan(n-char-sequence)' or `@nan@(n-char-sequence)' (regardless of
-     capitalisation) with `n-char-sequence' a string of ascii letters,
-     digits or `'_''.
-
-     For instance, upon input of `"nan(13 1)"', the function
-     `mpc_inp_str' starts to recognise a value of NaN followed by an
-     n-char-sequence indicated by the opening parenthesis; as soon as
-     the space is reached, it becocmes clear that the expression in
-     parentheses is not an n-char-sequence, and the error flag -1 is
-     returned after 6 characters have been consumed from the stream
-     (the whitespace itself remaining in the stream).  The function
-     `mpc_strtoc', on the other hand, may track back when reaching the
-     whitespace; it treats the string as the two successive complex
-     numbers `NaN + i * 0' and `13 + i'.  It is thus recommended to
-     have a whitespace follow each floating point number to avoid this
-     problem.
-
- -- Function: size_t mpc_out_str (FILE *STREAM, int BASE, size_t
-          N_DIGITS, mpc_t OP, mpc_rnd_t RND)
-     Output OP on stdio stream STREAM in base BASE, rounded according
-     to RND, in the same format as for `mpc_strtoc' If STREAM is the
-     null pointer, ROP is written to `stdout'.
-
-     Return the number of characters written.
-
-
-File: mpc.info,  Node: Complex Comparison,  Next: Projection & Decomposing,  Prev: String and Stream Input and Output,  Up: Complex Functions
-
-5.5 Comparison Functions
-========================
-
- -- Function: int mpc_cmp (mpc_t OP1, mpc_t OP2)
- -- Function: int mpc_cmp_si_si (mpc_t OP1, long int OP2R, long int
-          OP2I)
- -- Macro: int mpc_cmp_si (mpc_t OP1, long int OP2)
-     Compare OP1 and OP2, where in the case of `mpc_cmp_si_si', OP2 is
-     taken to be OP2R + i OP2I.  The return value C can be decomposed
-     into `x = MPC_INEX_RE(c)' and `y = MPC_INEX_IM(c)', such that X is
-     positive if the real part of OP1 is greater than that of OP2, zero
-     if both real parts are equal, and negative if the real part of OP1
-     is less than that of OP2, and likewise for Y.  Both OP1 and OP2
-     are considered to their full own precision, which may differ.  It
-     is not allowed that one of the operands has a NaN (Not-a-Number)
-     part.
-
-     The storage of the return value is such that equality can be
-     simply checked with `mpc_cmp (op1, op2) == 0'.
-
-
-File: mpc.info,  Node: Projection & Decomposing,  Next: Basic Arithmetic,  Prev: Complex Comparison,  Up: Complex Functions
-
-5.6 Projection and Decomposing Functions
-========================================
-
- -- Function: int mpc_real (mpfr_t ROP, mpc_t OP, mpfr_rnd_t RND)
-     Set ROP to the value of the real part of OP rounded in the
-     direction RND.
-
- -- Function: int mpc_imag (mpfr_t ROP, mpc_t OP, mpfr_rnd_t RND)
-     Set ROP to the value of the imaginary part of OP rounded in the
-     direction RND.
-
- -- Macro: mpfr_t mpc_realref (mpc_t OP)
- -- Macro: mpfr_t mpc_imagref (mpc_t OP)
-     Return a reference to the real part and imaginary part of OP,
-     respectively. The `mpfr' functions can be used on the result of
-     these macros (note that the `mpfr_t' type is itself a pointer).
-
- -- Function: int mpc_arg (mpfr_t ROP, mpc_t OP, mpfr_rnd_t RND)
-     Set ROP to the argument of OP, with a branch cut along the
-     negative real axis.
-
- -- Function: int mpc_proj (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Compute a projection of OP onto the Riemann sphere. Set ROP to OP
-     rounded in the direction RND, except when at least one part of OP
-     is infinite (even if the other part is a NaN) in which case the
-     real part of ROP is set to plus infinity and its imaginary part to
-     a signed zero with the same sign as the imaginary part of OP.
-
-
-File: mpc.info,  Node: Basic Arithmetic,  Next: Power Functions and Logarithm,  Prev: Projection & Decomposing,  Up: Complex Functions
-
-5.7 Basic Arithmetic Functions
-==============================
-
-All the following functions are designed in such a way that, when
-working with real numbers instead of complex numbers, their complexity
-should essentially be the same as with the MPFR library, with only a
-marginal overhead due to the MPC layer.
-
- -- Function: int mpc_add (mpc_t ROP, mpc_t OP1, mpc_t OP2, mpc_rnd_t
-          RND)
- -- Function: int mpc_add_ui (mpc_t ROP, mpc_t OP1, unsigned long int
-          OP2, mpc_rnd_t RND)
- -- Function: int mpc_add_fr (mpc_t ROP, mpc_t OP1, mpfr_t OP2,
-          mpc_rnd_t RND)
-     Set ROP to OP1 + OP2 rounded according to RND.
-
- -- Function: int mpc_sub (mpc_t ROP, mpc_t OP1, mpc_t OP2, mpc_rnd_t
-          RND)
- -- Function: int mpc_sub_fr (mpc_t ROP, mpc_t OP1, mpfr_t OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_fr_sub (mpc_t ROP, mpfr_t OP1, mpc_t OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_sub_ui (mpc_t ROP, mpc_t OP1, unsigned long int
-          OP2, mpc_rnd_t RND)
- -- Macro: int mpc_ui_sub (mpc_t ROP, unsigned long int OP1, mpc_t OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_ui_ui_sub (mpc_t ROP, unsigned long int RE1,
-          unsigned long int IM1, mpc_t OP2, mpc_rnd_t RND)
-     Set ROP to OP1 - OP2 rounded according to RND.  For
-     `mpc_ui_ui_sub', OP1 is RE1 + IM1.
-
- -- Function: int mpc_mul (mpc_t ROP, mpc_t OP1, mpc_t OP2, mpc_rnd_t
-          RND)
- -- Function: int mpc_mul_ui (mpc_t ROP, mpc_t OP1, unsigned long int
-          OP2, mpc_rnd_t RND)
- -- Function: int mpc_mul_si (mpc_t ROP, mpc_t OP1, long int OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_mul_fr (mpc_t ROP, mpc_t OP1, mpfr_t OP2,
-          mpc_rnd_t RND)
-     Set ROP to OP1 times OP2 rounded according to RND.
-
- -- Function: int mpc_mul_i (mpc_t ROP, mpc_t OP, int SGN, mpc_rnd_t
-          RND)
-     Set ROP to OP times the imaginary unit i if SGN is non-negative,
-     set ROP to OP times -i otherwise, in both cases rounded according
-     to RND.
-
- -- Function: int mpc_sqr (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the square of OP rounded according to RND.
-
- -- Function: int mpc_div (mpc_t ROP, mpc_t OP1, mpc_t OP2, mpc_rnd_t
-          RND)
- -- Function: int mpc_div_ui (mpc_t ROP, mpc_t OP1, unsigned long int
-          OP2, mpc_rnd_t RND)
- -- Function: int mpc_ui_div (mpc_t ROP, unsigned long int OP1, mpc_t
-          OP2, mpc_rnd_t RND)
- -- Function: int mpc_div_fr (mpc_t ROP, mpc_t OP1, mpfr_t OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_fr_div (mpc_t ROP, mpfr_t OP1, mpc_t OP2,
-          mpc_rnd_t RND)
-     Set ROP to OP1/OP2 rounded according to RND.  For `mpc_div' and
-     `mpc_ui_div', the return value may fail to recognize some exact
-     results. The sign of returned value is significant only for
-     `mpc_div_ui'.
-
- -- Function: int mpc_neg (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to -OP rounded according to RND.  Just changes the sign if
-     ROP and OP are the same variable.
-
- -- Function: int mpc_conj (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the conjugate of OP rounded according to RND.  Just
-     changes the sign of the imaginary part if ROP and OP are the same
-     variable.
-
- -- Function: int mpc_abs (mpfr_t ROP, mpc_t OP, mpfr_rnd_t RND)
-     Set the floating-point number ROP to the absolute value of OP,
-     rounded in the direction RND.  The returned value is zero iff the
-     result is exact.
-
- -- Function: int mpc_norm (mpfr_t ROP, mpc_t OP, mpfr_rnd_t RND)
-     Set the floating-point number ROP to the norm of OP (i.e., the
-     square of its absolute value), rounded in the direction RND.  The
-     returned value is zero iff the result is exact.  Note that the
-     destination is of type `mpfr_t', not `mpc_t'.
-
- -- Function: int mpc_mul_2exp (mpc_t ROP, mpc_t OP1, unsigned long int
-          OP2, mpc_rnd_t RND)
-     Set ROP to OP1 times 2 raised to OP2 rounded according to RND.
-     Just increases the exponents of the real and imaginary parts by OP2
-     when ROP and OP1 are identical.
-
- -- Function: int mpc_div_2exp (mpc_t ROP, mpc_t OP1, unsigned long int
-          OP2, mpc_rnd_t RND)
-     Set ROP to OP1 divided by 2 raised to OP2 rounded according to
-     RND. Just decreases the exponents of the real and imaginary parts
-     by OP2 when ROP and OP1 are identical.
-
- -- Function: int mpc_fma (mpc_t ROP, mpc_t OP1, mpc_t OP2, mpc_t OP3,
-          mpc_rnd_t RND)
-     Set ROP to OP1 times OP2 plus OP3, rounded according to RND, with
-     only one final rounding.
-
-
-File: mpc.info,  Node: Power Functions and Logarithm,  Next: Trigonometric Functions,  Prev: Basic Arithmetic,  Up: Complex Functions
-
-5.8 Power Functions and Logarithm
-=================================
-
- -- Function: int mpc_sqrt (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the square root of OP rounded according to RND.
-
- -- Function: int mpc_pow (mpc_t ROP, mpc_t OP1, mpc_t OP2, mpc_rnd_t
-          RND)
- -- Function: int mpc_pow_d (mpc_t ROP, mpc_t OP1, double OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_pow_ld (mpc_t ROP, mpc_t OP1, long double OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_pow_si (mpc_t ROP, mpc_t OP1, long OP2, mpc_rnd_t
-          RND)
- -- Function: int mpc_pow_ui (mpc_t ROP, mpc_t OP1, unsigned long OP2,
-          mpc_rnd_t RND)
- -- Function: int mpc_pow_z (mpc_t ROP, mpc_t OP1, mpz_t OP2, mpc_rnd_t
-          RND)
- -- Function: int mpc_pow_fr (mpc_t ROP, mpc_t OP1, mpfr_t OP2,
-          mpc_rnd_t RND)
-     Set ROP to OP1 raised to the power OP2, rounded according to RND.
-     For `mpc_pow_d', `mpc_pow_ld', `mpc_pow_si', `mpc_pow_ui',
-     `mpc_pow_z' and `mpc_pow_fr', the imaginary part of OP2 is
-     considered as +0.
-
- -- Function: int mpc_exp (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the exponential of OP, rounded according to RND with
-     the precision of ROP.
-
- -- Function: int mpc_log (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the logarithm of OP, rounded according to RND with the
-     precision of ROP.  The principal branch is chosen, with the branch
-     cut on the negative real axis, so that the imaginary part of the
-     result lies in ]-\pi , \pi].
-
-
-File: mpc.info,  Node: Trigonometric Functions,  Next: Miscellaneous Complex Functions,  Prev: Power Functions and Logarithm,  Up: Complex Functions
-
-5.9 Trigonometric Functions
-===========================
-
- -- Function: int mpc_sin (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the sine of OP, rounded according to RND with the
-     precision of ROP.
-
- -- Function: int mpc_cos (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the cosine of OP, rounded according to RND with the
-     precision of ROP.
-
- -- Function: int mpc_sin_cos (mpc_t ROP_SIN, mpc_t ROP_COS, mpc_t OP,
-          mpc_rnd_t RND_SIN, mpc_rnd_t RND_COS)
-     Set ROP_SIN to the sine of OP, rounded according to RND_SIN with
-     the precision of ROP_SIN, and ROP_COS to the cosine of OP, rounded
-     according to RND_COS with the precision of ROP_COS.
-
- -- Function: int mpc_tan (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the tangent of OP, rounded according to RND with the
-     precision of ROP.
-
- -- Function: int mpc_sinh (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the hyperbolic sine of OP, rounded according to RND
-     with the precision of ROP.
-
- -- Function: int mpc_cosh (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the hyperbolic cosine of OP, rounded according to RND
-     with the precision of ROP.
-
- -- Function: int mpc_tanh (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the hyperbolic tangent of OP, rounded according to RND
-     with the precision of ROP.
-
- -- Function: int mpc_asin (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
- -- Function: int mpc_acos (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
- -- Function: int mpc_atan (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the inverse sine, inverse cosine, inverse tangent of OP,
-     rounded according to RND with the precision of ROP.
-
- -- Function: int mpc_asinh (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
- -- Function: int mpc_acosh (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
- -- Function: int mpc_atanh (mpc_t ROP, mpc_t OP, mpc_rnd_t RND)
-     Set ROP to the inverse hyperbolic sine, inverse hyperbolic cosine,
-     inverse hyperbolic tangent of OP, rounded according to RND with
-     the precision of ROP.  The branch cut of MPC_ACOSH is (-\infty, 1).
-
-
-File: mpc.info,  Node: Miscellaneous Complex Functions,  Next: Advanced Functions,  Prev: Trigonometric Functions,  Up: Complex Functions
-
-5.10 Miscellaneous Functions
-============================
-
- -- Function: int mpc_urandom (mpc_t ROP, gmp_randstate_t STATE)
-     Generate a uniformly distributed random complex in the unit square
-     [0, 1] * [0, 1]. Return 0, unless an exponent in the real or
-     imaginary part is not in the current exponent range, in which case
-     that part is set to NaN and a zero value is returned. The second
-     argument is a `gmp_randstate_t' structure which should be created
-     using the GMP `rand_init' function, see the GMP manual.
-
- -- Function: const char * mpc_get_version (void)
-     Return the MPC version, as a null-terminated string.
-
- -- Macro: MPC_VERSION
- -- Macro: MPC_VERSION_MAJOR
- -- Macro: MPC_VERSION_MINOR
- -- Macro: MPC_VERSION_PATCHLEVEL
- -- Macro: MPC_VERSION_STRING
-     `MPC_VERSION' is the version of MPC as a preprocessing constant.
-     `MPC_VERSION_MAJOR', `MPC_VERSION_MINOR' and
-     `MPC_VERSION_PATCHLEVEL' are respectively the major, minor and
-     patch level of MPC version, as preprocessing constants.
-     `MPC_VERSION_STRING' is the version as a string constant, which
-     can be compared to the result of `mpc_get_version' to check at run
-     time the header file and library used match:
-          if (strcmp (mpc_get_version (), MPC_VERSION_STRING))
-            fprintf (stderr, "Warning: header and library do not match\n");
-     Note: Obtaining different strings is not necessarily an error, as
-     in general, a program compiled with some old MPC version can be
-     dynamically linked with a newer MPC library version (if allowed by
-     the library versioning system).
-
- -- Macro: long MPC_VERSION_NUM (MAJOR, MINOR, PATCHLEVEL)
-     Create an integer in the same format as used by `MPC_VERSION' from
-     the given MAJOR, MINOR and PATCHLEVEL.  Here is an example of how
-     to check the MPC version at compile time:
-          #if (!defined(MPC_VERSION) || (MPC_VERSION<MPC_VERSION_NUM(2,1,0)))
-          # error "Wrong MPC version."
-          #endif
-
-
-File: mpc.info,  Node: Advanced Functions,  Next: Internals,  Prev: Miscellaneous Complex Functions,  Up: Complex Functions
-
-5.11 Advanced Functions
-=======================
-
- -- Macro: MPC_SET_X_Y (REAL_SUFFIX, IMAG_SUFFIX, ROP, REAL, IMAG, RND)
-     The macro MPC_SET_X_Y is designed to serve as the body of an
-     assignment function and cannot be used by itself.  The REAL_SUFFIX
-     and IMAG_SUFFIX parameters are the types of the real and imaginary
-     part, that is, the `x' in the `mpfr_set_x' function one would use
-     to set the part; for the mpfr type, use `fr'.  REAL (respectively
-     IMAG) is the value you want to assign to the real (resp.
-     imaginary) part, its type must conform to REAL_SUFFIX (resp.
-     IMAG_SUFFIX).  RND is the `mpc_rnd_t' rounding mode.  The return
-     value is the usual inexact value (*note Return Value:
-     return-value.).
-
-     For instance, you can define mpc_set_ui_fr as follows:
-          int mpc_set_ui_fr (mpc_t rop, long int re, double im, mpc_rnd_t rnd)
-              MPC_SET_X_Y (ui, fr, rop, re, im, rnd);
-
-
-File: mpc.info,  Node: Internals,  Prev: Advanced Functions,  Up: Complex Functions
-
-5.12 Internals
-==============
-
-These macros and functions are mainly designed for the implementation
-of MPC, but may be useful for users too.  However, no upward
-compatibility is guaranteed.  You need to include `mpc-impl.h' to use
-them.
-
-   The macro `MPC_MAX_PREC(z)' gives the maximum of the precisions of
-the real and imaginary parts of a complex number.
-
-
-File: mpc.info,  Node: Contributors,  Next: References,  Prev: Complex Functions,  Up: Top
-
-Contributors
-************
-
-The main developers of the MPC library are Andreas Enge, Philippe
-The'veny and Paul Zimmermann.  Patrick Pe'lissier has helped cleaning
-up the code.  Marc Helbling contributed the `mpc_ui_sub' and
-`mpc_ui_ui_sub' functions.
-
-
-File: mpc.info,  Node: References,  Next: Concept Index,  Prev: Contributors,  Up: Top
-
-References
-**********
-
-   * Torbjo"rn Granlund et al.  `gmp' - GNU multiprecision library.
-     Version 4.2.4, `http://gmplib.org/'.
-
-   * Guillaume Hanrot, Vincent Lefe`vre, Patrick Pe'lissier, Paul
-     Zimmermann et al.  `mpfr' - A library for multiple-precision
-     floating-point               computations with exact rounding.
-     Version 2.4.1, `http://www.mpfr.org'.
-
-   * IEEE standard for binary floating-point arithmetic, Technical
-     Report ANSI-IEEE Standard 754-1985, New York, 1985.  Approved
-     March 21, 1985: IEEE Standards Board; approved July 26,   1985:
-     American National Standards Institute, 18 pages.
-
-   * Donald E. Knuth, "The Art of Computer Programming", vol 2,
-     "Seminumerical Algorithms", 2nd edition, Addison-Wesley, 1981.
-
-   * ISO/IEC 9899:1999, Programming languages  C.
-
-
-
-File: mpc.info,  Node: Concept Index,  Next: Function Index,  Prev: References,  Up: Top
-
-Concept Index
-*************
-
- [index ]
-* Menu:
-
-* Arithmetic functions:                  Basic Arithmetic.     (line  6)
-* Comparison functions:                  Complex Comparison.   (line  3)
-* Complex arithmetic functions:          Basic Arithmetic.     (line  6)
-* Complex assignment functions:          Assigning Complex Numbers.
-                                                               (line  6)
-* Complex comparisons functions:         Complex Comparison.   (line  3)
-* Complex functions:                     Complex Functions.    (line  6)
-* Complex number:                        MPC Basics.           (line 15)
-* Conditions for copying MPC:            Copying.              (line  6)
-* Conversion functions:                  Converting Complex Numbers.
-                                                               (line  6)
-* Copying conditions:                    Copying.              (line  6)
-* Installation:                          Installing MPC.       (line  6)
-* Logarithm:                             Power Functions and Logarithm.
-                                                               (line  6)
-* Miscellaneous complex functions:       Miscellaneous Complex Functions.
-                                                               (line  6)
-* mpc.h:                                 MPC Basics.           (line  6)
-* Power functions:                       Power Functions and Logarithm.
-                                                               (line  6)
-* Precision:                             MPC Basics.           (line 19)
-* Projection and Decomposing Functions:  Projection & Decomposing.
-                                                               (line  6)
-* Reporting bugs:                        Reporting Bugs.       (line  6)
-* Rounding Mode:                         MPC Basics.           (line 24)
-* String and stream input and output:    String and Stream Input and Output.
-                                                               (line  3)
-* Trigonometric functions:               Trigonometric Functions.
-                                                               (line  6)
-* User-defined precision:                Complex Functions.    (line 12)
-
-
-File: mpc.info,  Node: Function Index,  Prev: Concept Index,  Up: Top
-
-Function and Type Index
-***********************
-
- [index ]
-* Menu:
-
-* _Complex:                              Converting Complex Numbers.
-                                                              (line  10)
-* mpc_abs:                               Basic Arithmetic.    (line  78)
-* mpc_acos:                              Trigonometric Functions.
-                                                              (line  38)
-* mpc_acosh:                             Trigonometric Functions.
-                                                              (line  44)
-* mpc_add:                               Basic Arithmetic.    (line  13)
-* mpc_add_fr:                            Basic Arithmetic.    (line  17)
-* mpc_add_ui:                            Basic Arithmetic.    (line  15)
-* mpc_arg:                               Projection & Decomposing.
-                                                              (line  21)
-* mpc_asin:                              Trigonometric Functions.
-                                                              (line  37)
-* mpc_asinh:                             Trigonometric Functions.
-                                                              (line  43)
-* mpc_atan:                              Trigonometric Functions.
-                                                              (line  39)
-* mpc_atanh:                             Trigonometric Functions.
-                                                              (line  45)
-* mpc_clear:                             Initializing Complex Numbers.
-                                                              (line  22)
-* mpc_cmp:                               Complex Comparison.  (line   7)
-* mpc_cmp_si:                            Complex Comparison.  (line  10)
-* mpc_cmp_si_si:                         Complex Comparison.  (line   9)
-* mpc_conj:                              Basic Arithmetic.    (line  73)
-* mpc_cos:                               Trigonometric Functions.
-                                                              (line  11)
-* mpc_cosh:                              Trigonometric Functions.
-                                                              (line  29)
-* mpc_div:                               Basic Arithmetic.    (line  55)
-* mpc_div_2exp:                          Basic Arithmetic.    (line  96)
-* mpc_div_fr:                            Basic Arithmetic.    (line  61)
-* mpc_div_ui:                            Basic Arithmetic.    (line  57)
-* mpc_exp:                               Power Functions and Logarithm.
-                                                              (line  29)
-* mpc_fma:                               Basic Arithmetic.    (line 102)
-* mpc_fr_div:                            Basic Arithmetic.    (line  63)
-* mpc_fr_sub:                            Basic Arithmetic.    (line  25)
-* mpc_free_str:                          String and Stream Input and Output.
-                                                              (line  68)
-* mpc_get_ldc:                           Converting Complex Numbers.
-                                                              (line  11)
-* mpc_get_prec:                          Initializing Complex Numbers.
-                                                              (line  50)
-* mpc_get_prec2:                         Initializing Complex Numbers.
-                                                              (line  55)
-* mpc_get_str:                           String and Stream Input and Output.
-                                                              (line  51)
-* mpc_get_version:                       Miscellaneous Complex Functions.
-                                                              (line  15)
-* mpc_imag:                              Projection & Decomposing.
-                                                              (line  11)
-* mpc_imagref:                           Projection & Decomposing.
-                                                              (line  16)
-* mpc_init2:                             Initializing Complex Numbers.
-                                                              (line  11)
-* mpc_init3:                             Initializing Complex Numbers.
-                                                              (line  17)
-* mpc_inp_str:                           String and Stream Input and Output.
-                                                              (line  77)
-* mpc_log:                               Power Functions and Logarithm.
-                                                              (line  33)
-* mpc_mul:                               Basic Arithmetic.    (line  36)
-* mpc_mul_2exp:                          Basic Arithmetic.    (line  90)
-* mpc_mul_fr:                            Basic Arithmetic.    (line  42)
-* mpc_mul_i:                             Basic Arithmetic.    (line  46)
-* mpc_mul_si:                            Basic Arithmetic.    (line  40)
-* mpc_mul_ui:                            Basic Arithmetic.    (line  38)
-* mpc_neg:                               Basic Arithmetic.    (line  69)
-* mpc_norm:                              Basic Arithmetic.    (line  83)
-* mpc_out_str:                           String and Stream Input and Output.
-                                                              (line 112)
-* mpc_pow:                               Power Functions and Logarithm.
-                                                              (line  11)
-* mpc_pow_d:                             Power Functions and Logarithm.
-                                                              (line  13)
-* mpc_pow_fr:                            Power Functions and Logarithm.
-                                                              (line  23)
-* mpc_pow_ld:                            Power Functions and Logarithm.
-                                                              (line  15)
-* mpc_pow_si:                            Power Functions and Logarithm.
-                                                              (line  17)
-* mpc_pow_ui:                            Power Functions and Logarithm.
-                                                              (line  19)
-* mpc_pow_z:                             Power Functions and Logarithm.
-                                                              (line  21)
-* mpc_proj:                              Projection & Decomposing.
-                                                              (line  25)
-* mpc_real:                              Projection & Decomposing.
-                                                              (line   7)
-* mpc_realref:                           Projection & Decomposing.
-                                                              (line  15)
-* mpc_rnd_t:                             MPC Basics.          (line  24)
-* mpc_set:                               Assigning Complex Numbers.
-                                                              (line  17)
-* mpc_set_d:                             Assigning Complex Numbers.
-                                                              (line  26)
-* mpc_set_d_d:                           Assigning Complex Numbers.
-                                                              (line  56)
-* mpc_set_dc:                            Assigning Complex Numbers.
-                                                              (line  29)
-* mpc_set_f:                             Assigning Complex Numbers.
-                                                              (line  34)
-* mpc_set_f_f:                           Assigning Complex Numbers.
-                                                              (line  64)
-* mpc_set_fr:                            Assigning Complex Numbers.
-                                                              (line  35)
-* mpc_set_fr_fr:                         Assigning Complex Numbers.
-                                                              (line  66)
-* mpc_set_ld:                            Assigning Complex Numbers.
-                                                              (line  27)
-* mpc_set_ld_ld:                         Assigning Complex Numbers.
-                                                              (line  58)
-* mpc_set_ldc:                           Assigning Complex Numbers.
-                                                              (line  31)
-* mpc_set_nan:                           Assigning Complex Numbers.
-                                                              (line  80)
-* mpc_set_prec:                          Initializing Complex Numbers.
-                                                              (line  42)
-* mpc_set_q:                             Assigning Complex Numbers.
-                                                              (line  33)
-* mpc_set_q_q:                           Assigning Complex Numbers.
-                                                              (line  62)
-* mpc_set_si:                            Assigning Complex Numbers.
-                                                              (line  23)
-* mpc_set_si_si:                         Assigning Complex Numbers.
-                                                              (line  50)
-* mpc_set_sj:                            Assigning Complex Numbers.
-                                                              (line  25)
-* mpc_set_sj_sj:                         Assigning Complex Numbers.
-                                                              (line  54)
-* mpc_set_str:                           String and Stream Input and Output.
-                                                              (line  38)
-* mpc_set_ui:                            Assigning Complex Numbers.
-                                                              (line  22)
-* mpc_set_ui_ui:                         Assigning Complex Numbers.
-                                                              (line  48)
-* mpc_set_uj:                            Assigning Complex Numbers.
-                                                              (line  24)
-* mpc_set_uj_uj:                         Assigning Complex Numbers.
-                                                              (line  52)
-* MPC_SET_X_Y:                           Advanced Functions.  (line   7)
-* mpc_set_z:                             Assigning Complex Numbers.
-                                                              (line  32)
-* mpc_set_z_z:                           Assigning Complex Numbers.
-                                                              (line  60)
-* mpc_sin:                               Trigonometric Functions.
-                                                              (line   7)
-* mpc_sin_cos:                           Trigonometric Functions.
-                                                              (line  16)
-* mpc_sinh:                              Trigonometric Functions.
-                                                              (line  25)
-* mpc_sqr:                               Basic Arithmetic.    (line  51)
-* mpc_sqrt:                              Power Functions and Logarithm.
-                                                              (line   7)
-* mpc_strtoc:                            String and Stream Input and Output.
-                                                              (line   8)
-* mpc_sub:                               Basic Arithmetic.    (line  21)
-* mpc_sub_fr:                            Basic Arithmetic.    (line  23)
-* mpc_sub_ui:                            Basic Arithmetic.    (line  27)
-* mpc_swap:                              Assigning Complex Numbers.
-                                                              (line  83)
-* mpc_t:                                 MPC Basics.          (line  15)
-* mpc_tan:                               Trigonometric Functions.
-                                                              (line  21)
-* mpc_tanh:                              Trigonometric Functions.
-                                                              (line  33)
-* mpc_ui_div:                            Basic Arithmetic.    (line  59)
-* mpc_ui_sub:                            Basic Arithmetic.    (line  29)
-* mpc_ui_ui_sub:                         Basic Arithmetic.    (line  31)
-* mpc_urandom:                           Miscellaneous Complex Functions.
-                                                              (line   7)
-* MPC_VERSION:                           Miscellaneous Complex Functions.
-                                                              (line  18)
-* MPC_VERSION_MAJOR:                     Miscellaneous Complex Functions.
-                                                              (line  19)
-* MPC_VERSION_MINOR:                     Miscellaneous Complex Functions.
-                                                              (line  20)
-* MPC_VERSION_NUM:                       Miscellaneous Complex Functions.
-                                                              (line  37)
-* MPC_VERSION_PATCHLEVEL:                Miscellaneous Complex Functions.
-                                                              (line  21)
-* MPC_VERSION_STRING:                    Miscellaneous Complex Functions.
-                                                              (line  22)
-* mpfr_prec_t:                           MPC Basics.          (line  19)
-
-
-
-Tag Table:
-Node: Top946
-Node: Copying1607
-Node: Introduction to MPC2265
-Node: Installing MPC2973
-Node: Reporting Bugs7632
-Node: MPC Basics8961
-Ref: return-value12611
-Node: Complex Functions14053
-Node: Initializing Complex Numbers15202
-Node: Assigning Complex Numbers17616
-Node: Converting Complex Numbers22024
-Node: String and Stream Input and Output22658
-Ref: string-io22805
-Node: Complex Comparison29237
-Node: Projection & Decomposing30316
-Node: Basic Arithmetic31691
-Node: Power Functions and Logarithm36331
-Node: Trigonometric Functions37986
-Node: Miscellaneous Complex Functions40211
-Node: Advanced Functions42356
-Node: Internals43429
-Node: Contributors43876
-Node: References44222
-Node: Concept Index45136
-Node: Function Index47450
-
-End Tag Table
diff --git a/mpfr/doc/mpfr.info b/mpfr/doc/mpfr.info
deleted file mode 100644
index 00683c3..0000000
--- a/mpfr/doc/mpfr.info
+++ /dev/null
@@ -1,4255 +0,0 @@
-This is mpfr.info, produced by makeinfo version 4.13 from mpfr.texi.
-
-This manual documents how to install and use the Multiple Precision
-Floating-Point Reliable Library, version 3.1.0.
-
-   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this
-document under the terms of the GNU Free Documentation License, Version
-1.2 or any later version published by the Free Software Foundation;
-with no Invariant Sections, with no Front-Cover Texts, and with no
-Back-Cover Texts.  A copy of the license is included in *note GNU Free
-Documentation License::.
-
-INFO-DIR-SECTION Software libraries
-START-INFO-DIR-ENTRY
-* mpfr: (mpfr).                 Multiple Precision Floating-Point Reliable Library.
-END-INFO-DIR-ENTRY
-
-
-File: mpfr.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)
-
-GNU MPFR
-********
-
-   This manual documents how to install and use the Multiple Precision
-Floating-Point Reliable Library, version 3.1.0.
-
-   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this
-document under the terms of the GNU Free Documentation License, Version
-1.2 or any later version published by the Free Software Foundation;
-with no Invariant Sections, with no Front-Cover Texts, and with no
-Back-Cover Texts.  A copy of the license is included in *note GNU Free
-Documentation License::.
-
-
-* Menu:
-
-* Copying::                     MPFR Copying Conditions (LGPL).
-* Introduction to MPFR::        Brief introduction to GNU MPFR.
-* Installing MPFR::             How to configure and compile the MPFR library.
-* Reporting Bugs::              How to usefully report bugs.
-* MPFR Basics::                 What every MPFR user should now.
-* MPFR Interface::              MPFR functions and macros.
-* API Compatibility::           API compatibility with previous MPFR versions.
-* Contributors::
-* References::
-* GNU Free Documentation License::
-* Concept Index::
-* Function and Type Index::
-
-
-File: mpfr.info,  Node: Copying,  Next: Introduction to MPFR,  Prev: Top,  Up: Top
-
-MPFR Copying Conditions
-***********************
-
-The GNU MPFR library (or MPFR for short) is "free"; this means that
-everyone is free to use it and free to redistribute it on a free basis.
-The library is not in the public domain; it is copyrighted and there
-are restrictions on its distribution, but these restrictions are
-designed to permit everything that a good cooperating citizen would
-want to do.  What is not allowed is to try to prevent others from
-further sharing any version of this library that they might get from
-you.
-
-   Specifically, we want to make sure that you have the right to give
-away copies of the library, that you receive source code or else can
-get it if you want it, that you can change this library or use pieces
-of it in new free programs, and that you know you can do these things.
-
-   To make sure that everyone has such rights, we have to forbid you to
-deprive anyone else of these rights.  For example, if you distribute
-copies of the GNU MPFR library, you must give the recipients all the
-rights that you have.  You must make sure that they, too, receive or
-can get the source code.  And you must tell them their rights.
-
-   Also, for our own protection, we must make certain that everyone
-finds out that there is no warranty for the GNU MPFR library.  If it is
-modified by someone else and passed on, we want their recipients to
-know that what they have is not what we distributed, so that any
-problems introduced by others will not reflect on our reputation.
-
-   The precise conditions of the license for the GNU MPFR library are
-found in the Lesser General Public License that accompanies the source
-code.  See the file COPYING.LESSER.
-
-
-File: mpfr.info,  Node: Introduction to MPFR,  Next: Installing MPFR,  Prev: Copying,  Up: Top
-
-1 Introduction to MPFR
-**********************
-
-MPFR is a portable library written in C for arbitrary precision
-arithmetic on floating-point numbers. It is based on the GNU MP library.
-It aims to provide a class of floating-point numbers with precise
-semantics. The main characteristics of MPFR, which make it differ from
-most arbitrary precision floating-point software tools, are:
-
-   * the MPFR code is portable, i.e., the result of any operation does
-     not depend on the machine word size `mp_bits_per_limb' (64 on most
-     current processors);
-
-   * the precision in bits can be set _exactly_ to any valid value for
-     each variable (including very small precision);
-
-   * MPFR provides the four rounding modes from the IEEE 754-1985
-     standard, plus away-from-zero, as well as for basic operations as
-     for other mathematical functions.
-
-   In particular, with a precision of 53 bits, MPFR is able to exactly
-reproduce all computations with double-precision machine floating-point
-numbers (e.g., `double' type in C, with a C implementation that
-rigorously follows Annex F of the ISO C99 standard and `FP_CONTRACT'
-pragma set to `OFF') on the four arithmetic operations and the square
-root, except the default exponent range is much wider and subnormal
-numbers are not implemented (but can be emulated).
-
-   This version of MPFR is released under the GNU Lesser General Public
-License, version 3 or any later version.  It is permitted to link MPFR
-to most non-free programs, as long as when distributing them the MPFR
-source code and a means to re-link with a modified MPFR library is
-provided.
-
-1.1 How to Use This Manual
-==========================
-
-Everyone should read *note MPFR Basics::.  If you need to install the
-library yourself, you need to read *note Installing MPFR::, too.  To
-use the library you will need to refer to *note MPFR Interface::.
-
-   The rest of the manual can be used for later reference, although it
-is probably a good idea to glance through it.
-
-
-File: mpfr.info,  Node: Installing MPFR,  Next: Reporting Bugs,  Prev: Introduction to MPFR,  Up: Top
-
-2 Installing MPFR
-*****************
-
-The MPFR library is already installed on some GNU/Linux distributions,
-but the development files necessary to the compilation such as `mpfr.h'
-are not always present. To check that MPFR is fully installed on your
-computer, you can check the presence of the file `mpfr.h' in
-`/usr/include', or try to compile a small program having `#include
-<mpfr.h>' (since `mpfr.h' may be installed somewhere else). For
-instance, you can try to compile:
-
-     #include <stdio.h>
-     #include <mpfr.h>
-     int main (void)
-     {
-       printf ("MPFR library: %-12s\nMPFR header:  %s (based on %d.%d.%d)\n",
-               mpfr_get_version (), MPFR_VERSION_STRING, MPFR_VERSION_MAJOR,
-               MPFR_VERSION_MINOR, MPFR_VERSION_PATCHLEVEL);
-       return 0;
-     }
-
-with
-
-     cc -o version version.c -lmpfr -lgmp
-
-and if you get errors whose first line looks like
-
-     version.c:2:19: error: mpfr.h: No such file or directory
-
-then MPFR is probably not installed. Running this program will give you
-the MPFR version.
-
-   If MPFR is not installed on your computer, or if you want to install
-a different version, please follow the steps below.
-
-2.1 How to Install
-==================
-
-Here are the steps needed to install the library on Unix systems (more
-details are provided in the `INSTALL' file):
-
-  1. To build MPFR, you first have to install GNU MP (version 4.1 or
-     higher) on your computer.  You need a C compiler, preferably GCC,
-     but any reasonable compiler should work.  And you need the
-     standard Unix `make' command, plus some other standard Unix
-     utility commands.
-
-     Then, in the MPFR build directory, type the following commands.
-
-  2. `./configure'
-
-     This will prepare the build and setup the options according to
-     your system.  You can give options to specify the install
-     directories (instead of the default `/usr/local'), threading
-     support, and so on. See the `INSTALL' file and/or the output of
-     `./configure --help' for more information, in particular if you
-     get error messages.
-
-  3. `make'
-
-     This will compile MPFR, and create a library archive file
-     `libmpfr.a'.  On most platforms, a dynamic library will be
-     produced too.
-
-  4. `make check'
-
-     This will make sure MPFR was built correctly.  If you get error
-     messages, please report this to the MPFR mailing-list
-     `mpfr@loria.fr'.  (*Note Reporting Bugs::, for information on what
-     to include in useful bug reports.)
-
-  5. `make install'
-
-     This will copy the files `mpfr.h' and `mpf2mpfr.h' to the directory
-     `/usr/local/include', the library files (`libmpfr.a' and possibly
-     others) to the directory `/usr/local/lib', the file `mpfr.info' to
-     the directory `/usr/local/share/info', and some other documentation
-     files to the directory `/usr/local/share/doc/mpfr' (or if you
-     passed the `--prefix' option to `configure', using the prefix
-     directory given as argument to `--prefix' instead of `/usr/local').
-
-2.2 Other `make' Targets
-========================
-
-There are some other useful make targets:
-
-   * `mpfr.info' or `info'
-
-     Create or update an info version of the manual, in `mpfr.info'.
-
-     This file is already provided in the MPFR archives.
-
-   * `mpfr.pdf' or `pdf'
-
-     Create a PDF version of the manual, in `mpfr.pdf'.
-
-   * `mpfr.dvi' or `dvi'
-
-     Create a DVI version of the manual, in `mpfr.dvi'.
-
-   * `mpfr.ps' or `ps'
-
-     Create a Postscript version of the manual, in `mpfr.ps'.
-
-   * `mpfr.html' or `html'
-
-     Create a HTML version of the manual, in several pages in the
-     directory `doc/mpfr.html'; if you want only one output HTML file,
-     then type `makeinfo --html --no-split mpfr.texi' from the `doc'
-     directory instead.
-
-   * `clean'
-
-     Delete all object files and archive files, but not the
-     configuration files.
-
-   * `distclean'
-
-     Delete all generated files not included in the distribution.
-
-   * `uninstall'
-
-     Delete all files copied by `make install'.
-
-2.3 Build Problems
-==================
-
-In case of problem, please read the `INSTALL' file carefully before
-reporting a bug, in particular section "In case of problem".  Some
-problems are due to bad configuration on the user side (not specific to
-MPFR). Problems are also mentioned in the FAQ
-`http://www.mpfr.org/faq.html'.
-
-   Please report problems to the MPFR mailing-list `mpfr@loria.fr'.
-*Note Reporting Bugs::.  Some bug fixes are available on the MPFR 3.1.0
-web page `http://www.mpfr.org/mpfr-3.1.0/'.
-
-2.4 Getting the Latest Version of MPFR
-======================================
-
-The latest version of MPFR is available from
-`ftp://ftp.gnu.org/gnu/mpfr/' or `http://www.mpfr.org/'.
-
-
-File: mpfr.info,  Node: Reporting Bugs,  Next: MPFR Basics,  Prev: Installing MPFR,  Up: Top
-
-3 Reporting Bugs
-****************
-
-If you think you have found a bug in the MPFR library, first have a look
-on the MPFR 3.1.0 web page `http://www.mpfr.org/mpfr-3.1.0/' and the
-FAQ `http://www.mpfr.org/faq.html': perhaps this bug is already known,
-in which case you may find there a workaround for it.  You might also
-look in the archives of the MPFR mailing-list:
-`http://websympa.loria.fr/wwsympa/arc/mpfr'.  Otherwise, please
-investigate and report it.  We have made this library available to you,
-and it is not to ask too much from you, to ask you to report the bugs
-that you find.
-
-   There are a few things you should think about when you put your bug
-report together.
-
-   You have to send us a test case that makes it possible for us to
-reproduce the bug, i.e., a small self-content program, using no other
-library than MPFR.  Include instructions on how to run the test case.
-
-   You also have to explain what is wrong; if you get a crash, or if
-the results you get are incorrect and in that case, in what way.
-
-   Please include compiler version information in your bug report. This
-can be extracted using `cc -V' on some machines, or, if you're using
-GCC, `gcc -v'. Also, include the output from `uname -a' and the MPFR
-version (the GMP version may be useful too).  If you get a failure
-while running `make' or `make check', please include the `config.log'
-file in your bug report.
-
-   If your bug report is good, we will do our best to help you to get a
-corrected version of the library; if the bug report is poor, we will
-not do anything about it (aside of chiding you to send better bug
-reports).
-
-   Send your bug report to the MPFR mailing-list `mpfr@loria.fr'.
-
-   If you think something in this manual is unclear, or downright
-incorrect, or if the language needs to be improved, please send a note
-to the same address.
-
-
-File: mpfr.info,  Node: MPFR Basics,  Next: MPFR Interface,  Prev: Reporting Bugs,  Up: Top
-
-4 MPFR Basics
-*************
-
-* Menu:
-
-* Headers and Libraries::
-* Nomenclature and Types::
-* MPFR Variable Conventions::
-* Rounding Modes::
-* Floating-Point Values on Special Numbers::
-* Exceptions::
-* Memory Handling::
-
-
-File: mpfr.info,  Node: Headers and Libraries,  Next: Nomenclature and Types,  Prev: MPFR Basics,  Up: MPFR Basics
-
-4.1 Headers and Libraries
-=========================
-
-All declarations needed to use MPFR are collected in the include file
-`mpfr.h'.  It is designed to work with both C and C++ compilers.  You
-should include that file in any program using the MPFR library:
-
-     #include <mpfr.h>
-
-   Note however that prototypes for MPFR functions with `FILE *'
-parameters are provided only if `<stdio.h>' is included too (before
-`mpfr.h'):
-
-     #include <stdio.h>
-     #include <mpfr.h>
-
-   Likewise `<stdarg.h>' (or `<varargs.h>') is required for prototypes
-with `va_list' parameters, such as `mpfr_vprintf'.
-
-   And for any functions using `intmax_t', you must include
-`<stdint.h>' or `<inttypes.h>' before `mpfr.h', to allow `mpfr.h' to
-define prototypes for these functions. Moreover, users of C++ compilers
-under some platforms may need to define `MPFR_USE_INTMAX_T' (and should
-do it for portability) before `mpfr.h' has been included; of course, it
-is possible to do that on the command line, e.g., with
-`-DMPFR_USE_INTMAX_T'.
-
-   Note: If `mpfr.h' and/or `gmp.h' (used by `mpfr.h') are included
-several times (possibly from another header file), `<stdio.h>' and/or
-`<stdarg.h>' (or `<varargs.h>') should be included *before the first
-inclusion* of `mpfr.h' or `gmp.h'.  Alternatively, you can define
-`MPFR_USE_FILE' (for MPFR I/O functions) and/or `MPFR_USE_VA_LIST' (for
-MPFR functions with `va_list' parameters) anywhere before the last
-inclusion of `mpfr.h'.  As a consequence, if your file is a public
-header that includes `mpfr.h', you need to use the latter method.
-
-   When calling a MPFR macro, it is not allowed to have previously
-defined a macro with the same name as some keywords (currently `do',
-`while' and `sizeof').
-
-   You can avoid the use of MPFR macros encapsulating functions by
-defining the `MPFR_USE_NO_MACRO' macro before `mpfr.h' is included.  In
-general this should not be necessary, but this can be useful when
-debugging user code: with some macros, the compiler may emit spurious
-warnings with some warning options, and macros can prevent some
-prototype checking.
-
-   All programs using MPFR must link against both `libmpfr' and
-`libgmp' libraries.  On a typical Unix-like system this can be done
-with `-lmpfr -lgmp' (in that order), for example:
-
-     gcc myprogram.c -lmpfr -lgmp
-
-   MPFR is built using Libtool and an application can use that to link
-if desired, *note GNU Libtool: (libtool.info)Top.
-
-   If MPFR has been installed to a non-standard location, then it may be
-necessary to set up environment variables such as `C_INCLUDE_PATH' and
-`LIBRARY_PATH', or use `-I' and `-L' compiler options, in order to
-point to the right directories. For a shared library, it may also be
-necessary to set up some sort of run-time library path (e.g.,
-`LD_LIBRARY_PATH') on some systems. Please read the `INSTALL' file for
-additional information.
-
-
-File: mpfr.info,  Node: Nomenclature and Types,  Next: MPFR Variable Conventions,  Prev: Headers and Libraries,  Up: MPFR Basics
-
-4.2 Nomenclature and Types
-==========================
-
-A "floating-point number", or "float" for short, is an arbitrary
-precision significand (also called mantissa) with a limited precision
-exponent. The C data type for such objects is `mpfr_t' (internally
-defined as a one-element array of a structure, and `mpfr_ptr' is the C
-data type representing a pointer to this structure). A floating-point
-number can have three special values: Not-a-Number (NaN) or plus or
-minus Infinity. NaN represents an uninitialized object, the result of
-an invalid operation (like 0 divided by 0), or a value that cannot be
-determined (like +Infinity minus +Infinity). Moreover, like in the IEEE
-754 standard, zero is signed, i.e., there are both +0 and -0; the
-behavior is the same as in the IEEE 754 standard and it is generalized
-to the other functions supported by MPFR. Unless documented otherwise,
-the sign bit of a NaN is unspecified.
-
-The "precision" is the number of bits used to represent the significand
-of a floating-point number; the corresponding C data type is
-`mpfr_prec_t'.  The precision can be any integer between
-`MPFR_PREC_MIN' and `MPFR_PREC_MAX'. In the current implementation,
-`MPFR_PREC_MIN' is equal to 2.
-
-   Warning! MPFR needs to increase the precision internally, in order to
-provide accurate results (and in particular, correct rounding). Do not
-attempt to set the precision to any value near `MPFR_PREC_MAX',
-otherwise MPFR will abort due to an assertion failure. Moreover, you
-may reach some memory limit on your platform, in which case the program
-may abort, crash or have undefined behavior (depending on your C
-implementation).
-
-The "rounding mode" specifies the way to round the result of a
-floating-point operation, in case the exact result can not be
-represented exactly in the destination significand; the corresponding C
-data type is `mpfr_rnd_t'.
-
-
-File: mpfr.info,  Node: MPFR Variable Conventions,  Next: Rounding Modes,  Prev: Nomenclature and Types,  Up: MPFR Basics
-
-4.3 MPFR Variable Conventions
-=============================
-
-Before you can assign to an MPFR variable, you need to initialize it by
-calling one of the special initialization functions.  When you're done
-with a variable, you need to clear it out, using one of the functions
-for that purpose.  A variable should only be initialized once, or at
-least cleared out between each initialization.  After a variable has
-been initialized, it may be assigned to any number of times.  For
-efficiency reasons, avoid to initialize and clear out a variable in
-loops.  Instead, initialize it before entering the loop, and clear it
-out after the loop has exited.  You do not need to be concerned about
-allocating additional space for MPFR variables, since any variable has
-a significand of fixed size.  Hence unless you change its precision, or
-clear and reinitialize it, a floating-point variable will have the same
-allocated space during all its life.
-
-   As a general rule, all MPFR functions expect output arguments before
-input arguments.  This notation is based on an analogy with the
-assignment operator.  MPFR allows you to use the same variable for both
-input and output in the same expression.  For example, the main
-function for floating-point multiplication, `mpfr_mul', can be used
-like this: `mpfr_mul (x, x, x, rnd)'.  This computes the square of X
-with rounding mode `rnd' and puts the result back in X.
-
-
-File: mpfr.info,  Node: Rounding Modes,  Next: Floating-Point Values on Special Numbers,  Prev: MPFR Variable Conventions,  Up: MPFR Basics
-
-4.4 Rounding Modes
-==================
-
-The following five rounding modes are supported:
-
-   * `MPFR_RNDN': round to nearest (roundTiesToEven in IEEE 754-2008),
-
-   * `MPFR_RNDZ': round toward zero (roundTowardZero in IEEE 754-2008),
-
-   * `MPFR_RNDU': round toward plus infinity (roundTowardPositive in
-     IEEE 754-2008),
-
-   * `MPFR_RNDD': round toward minus infinity (roundTowardNegative in
-     IEEE 754-2008),
-
-   * `MPFR_RNDA': round away from zero.
-
-   The `round to nearest' mode works as in the IEEE 754 standard: in
-case the number to be rounded lies exactly in the middle of two
-representable numbers, it is rounded to the one with the least
-significant bit set to zero.  For example, the number 2.5, which is
-represented by (10.1) in binary, is rounded to (10.0)=2 with a
-precision of two bits, and not to (11.0)=3.  This rule avoids the
-"drift" phenomenon mentioned by Knuth in volume 2 of The Art of
-Computer Programming (Section 4.2.2).
-
-   Most MPFR functions take as first argument the destination variable,
-as second and following arguments the input variables, as last argument
-a rounding mode, and have a return value of type `int', called the
-"ternary value". The value stored in the destination variable is
-correctly rounded, i.e., MPFR behaves as if it computed the result with
-an infinite precision, then rounded it to the precision of this
-variable.  The input variables are regarded as exact (in particular,
-their precision does not affect the result).
-
-   As a consequence, in case of a non-zero real rounded result, the
-error on the result is less or equal to 1/2 ulp (unit in the last
-place) of that result in the rounding to nearest mode, and less than 1
-ulp of that result in the directed rounding modes (a ulp is the weight
-of the least significant represented bit of the result after rounding).
-
-   Unless documented otherwise, functions returning an `int' return a
-ternary value.  If the ternary value is zero, it means that the value
-stored in the destination variable is the exact result of the
-corresponding mathematical function. If the ternary value is positive
-(resp. negative), it means the value stored in the destination variable
-is greater (resp. lower) than the exact result. For example with the
-`MPFR_RNDU' rounding mode, the ternary value is usually positive,
-except when the result is exact, in which case it is zero. In the case
-of an infinite result, it is considered as inexact when it was obtained
-by overflow, and exact otherwise. A NaN result (Not-a-Number) always
-corresponds to an exact return value.  The opposite of a returned
-ternary value is guaranteed to be representable in an `int'.
-
-   Unless documented otherwise, functions returning as result the value
-`1' (or any other value specified in this manual) for special cases
-(like `acos(0)') yield an overflow or an underflow if that value is not
-representable in the current exponent range.
-
-
-File: mpfr.info,  Node: Floating-Point Values on Special Numbers,  Next: Exceptions,  Prev: Rounding Modes,  Up: MPFR Basics
-
-4.5 Floating-Point Values on Special Numbers
-============================================
-
-This section specifies the floating-point values (of type `mpfr_t')
-returned by MPFR functions (where by "returned" we mean here the
-modified value of the destination object, which should not be mixed
-with the ternary return value of type `int' of those functions).  For
-functions returning several values (like `mpfr_sin_cos'), the rules
-apply to each result separately.
-
-   Functions can have one or several input arguments. An input point is
-a mapping from these input arguments to the set of the MPFR numbers.
-When none of its components are NaN, an input point can also be seen as
-a tuple in the extended real numbers (the set of the real numbers with
-both infinities).
-
-   When the input point is in the domain of the mathematical function,
-the result is rounded as described in Section "Rounding Modes" (but see
-below for the specification of the sign of an exact zero). Otherwise
-the general rules from this section apply unless stated otherwise in
-the description of the MPFR function (*note MPFR Interface::).
-
-   When the input point is not in the domain of the mathematical
-function but is in its closure in the extended real numbers and the
-function can be extended by continuity, the result is the obtained
-limit.  Examples: `mpfr_hypot' on (+Inf,0) gives +Inf. But `mpfr_pow'
-cannot be defined on (1,+Inf) using this rule, as one can find
-sequences (X_N,Y_N) such that X_N goes to 1, Y_N goes to +Inf and X_N
-to the Y_N goes to any positive value when N goes to the infinity.
-
-   When the input point is in the closure of the domain of the
-mathematical function and an input argument is +0 (resp. -0), one
-considers the limit when the corresponding argument approaches 0 from
-above (resp. below). If the limit is not defined (e.g., `mpfr_log' on
--0), the behavior is specified in the description of the MPFR function.
-
-   When the result is equal to 0, its sign is determined by considering
-the limit as if the input point were not in the domain: If one
-approaches 0 from above (resp. below), the result is +0 (resp. -0); for
-example, `mpfr_sin' on +0 gives +0.  In the other cases, the sign is
-specified in the description of the MPFR function; for example
-`mpfr_max' on -0 and +0 gives +0.
-
-   When the input point is not in the closure of the domain of the
-function, the result is NaN. Example: `mpfr_sqrt' on -17 gives NaN.
-
-   When an input argument is NaN, the result is NaN, possibly except
-when a partial function is constant on the finite floating-point
-numbers; such a case is always explicitly specified in *note MPFR
-Interface::.  Example: `mpfr_hypot' on (NaN,0) gives NaN, but
-`mpfr_hypot' on (NaN,+Inf) gives +Inf (as specified in *note Special
-Functions::), since for any finite input X, `mpfr_hypot' on (X,+Inf)
-gives +Inf.
-
-
-File: mpfr.info,  Node: Exceptions,  Next: Memory Handling,  Prev: Floating-Point Values on Special Numbers,  Up: MPFR Basics
-
-4.6 Exceptions
-==============
-
-MPFR supports 6 exception types:
-
-   * Underflow: An underflow occurs when the exact result of a function
-     is a non-zero real number and the result obtained after the
-     rounding, assuming an unbounded exponent range (for the rounding),
-     has an exponent smaller than the minimum value of the current
-     exponent range. (In the round-to-nearest mode, the halfway case is
-     rounded toward zero.)
-
-     Note: This is not the single possible definition of the underflow.
-     MPFR chooses to consider the underflow _after_ rounding. The
-     underflow before rounding can also be defined. For instance,
-     consider a function that has the exact result 7 multiplied by two
-     to the power E-4, where E is the smallest exponent (for a
-     significand between 1/2 and 1), with a 2-bit target precision and
-     rounding toward plus infinity.  The exact result has the exponent
-     E-1. With the underflow before rounding, such a function call
-     would yield an underflow, as E-1 is outside the current exponent
-     range. However, MPFR first considers the rounded result assuming
-     an unbounded exponent range.  The exact result cannot be
-     represented exactly in precision 2, and here, it is rounded to 0.5
-     times 2 to E, which is representable in the current exponent
-     range. As a consequence, this will not yield an underflow in MPFR.
-
-   * Overflow: An overflow occurs when the exact result of a function
-     is a non-zero real number and the result obtained after the
-     rounding, assuming an unbounded exponent range (for the rounding),
-     has an exponent larger than the maximum value of the current
-     exponent range. In the round-to-nearest mode, the result is
-     infinite.  Note: unlike the underflow case, there is only one
-     possible definition of overflow here.
-
-   * Divide-by-zero: An exact infinite result is obtained from finite
-     inputs.
-
-   * NaN: A NaN exception occurs when the result of a function is NaN.
-
-   * Inexact: An inexact exception occurs when the result of a function
-     cannot be represented exactly and must be rounded.
-
-   * Range error: A range exception occurs when a function that does
-     not return a MPFR number (such as comparisons and conversions to
-     an integer) has an invalid result (e.g., an argument is NaN in
-     `mpfr_cmp', or a conversion to an integer cannot be represented in
-     the target type).
-
-
-   MPFR has a global flag for each exception, which can be cleared, set
-or tested by functions described in *note Exception Related Functions::.
-
-   Differences with the ISO C99 standard:
-
-   * In C, only quiet NaNs are specified, and a NaN propagation does not
-     raise an invalid exception. Unless explicitly stated otherwise,
-     MPFR sets the NaN flag whenever a NaN is generated, even when a
-     NaN is propagated (e.g., in NaN + NaN), as if all NaNs were
-     signaling.
-
-   * An invalid exception in C corresponds to either a NaN exception or
-     a range error in MPFR.
-
-
-
-File: mpfr.info,  Node: Memory Handling,  Prev: Exceptions,  Up: MPFR Basics
-
-4.7 Memory Handling
-===================
-
-MPFR functions may create caches, e.g., when computing constants such
-as Pi, either because the user has called a function like
-`mpfr_const_pi' directly or because such a function was called
-internally by the MPFR library itself to compute some other function.
-
-   At any time, the user can free the various caches with
-`mpfr_free_cache'. It is strongly advised to do that before terminating
-a thread, or before exiting when using tools like `valgrind' (to avoid
-memory leaks being reported).
-
-   MPFR internal data such as flags, the exponent range, the default
-precision and rounding mode, and caches (i.e., data that are not
-accessed via parameters) are either global (if MPFR has not been
-compiled as thread safe) or per-thread (thread local storage, TLS).
-The initial values of TLS data after a thread is created entirely
-depend on the compiler and thread implementation (MPFR simply does a
-conventional variable initialization, the variables being declared with
-an implementation-defined TLS specifier).
-
-
-File: mpfr.info,  Node: MPFR Interface,  Next: API Compatibility,  Prev: MPFR Basics,  Up: Top
-
-5 MPFR Interface
-****************
-
-The floating-point functions expect arguments of type `mpfr_t'.
-
-   The MPFR floating-point functions have an interface that is similar
-to the GNU MP functions.  The function prefix for floating-point
-operations is `mpfr_'.
-
-   The user has to specify the precision of each variable.  A
-computation that assigns a variable will take place with the precision
-of the assigned variable; the cost of that computation should not
-depend on the precision of variables used as input (on average).
-
-   The semantics of a calculation in MPFR is specified as follows:
-Compute the requested operation exactly (with "infinite accuracy"), and
-round the result to the precision of the destination variable, with the
-given rounding mode.  The MPFR floating-point functions are intended to
-be a smooth extension of the IEEE 754 arithmetic. The results obtained
-on a given computer are identical to those obtained on a computer with
-a different word size, or with a different compiler or operating system.
-
-   MPFR _does not keep track_ of the accuracy of a computation. This is
-left to the user or to a higher layer (for example the MPFI library for
-interval arithmetic).  As a consequence, if two variables are used to
-store only a few significant bits, and their product is stored in a
-variable with large precision, then MPFR will still compute the result
-with full precision.
-
-   The value of the standard C macro `errno' may be set to non-zero by
-any MPFR function or macro, whether or not there is an error.
-
-* Menu:
-
-* Initialization Functions::
-* Assignment Functions::
-* Combined Initialization and Assignment Functions::
-* Conversion Functions::
-* Basic Arithmetic Functions::
-* Comparison Functions::
-* Special Functions::
-* Input and Output Functions::
-* Formatted Output Functions::
-* Integer Related Functions::
-* Rounding Related Functions::
-* Miscellaneous Functions::
-* Exception Related Functions::
-* Compatibility with MPF::
-* Custom Interface::
-* Internals::
-
-
-File: mpfr.info,  Node: Initialization Functions,  Next: Assignment Functions,  Prev: MPFR Interface,  Up: MPFR Interface
-
-5.1 Initialization Functions
-============================
-
-An `mpfr_t' object must be initialized before storing the first value in
-it.  The functions `mpfr_init' and `mpfr_init2' are used for that
-purpose.
-
- -- Function: void mpfr_init2 (mpfr_t X, mpfr_prec_t PREC)
-     Initialize X, set its precision to be *exactly* PREC bits and its
-     value to NaN. (Warning: the corresponding MPF function initializes
-     to zero instead.)
-
-     Normally, a variable should be initialized once only or at least
-     be cleared, using `mpfr_clear', between initializations.  To
-     change the precision of a variable which has already been
-     initialized, use `mpfr_set_prec'.  The precision PREC must be an
-     integer between `MPFR_PREC_MIN' and `MPFR_PREC_MAX' (otherwise the
-     behavior is undefined).
-
- -- Function: void mpfr_inits2 (mpfr_prec_t PREC, mpfr_t X, ...)
-     Initialize all the `mpfr_t' variables of the given variable
-     argument `va_list', set their precision to be *exactly* PREC bits
-     and their value to NaN.  See `mpfr_init2' for more details.  The
-     `va_list' is assumed to be composed only of type `mpfr_t' (or
-     equivalently `mpfr_ptr').  It begins from X, and ends when it
-     encounters a null pointer (whose type must also be `mpfr_ptr').
-
- -- Function: void mpfr_clear (mpfr_t X)
-     Free the space occupied by the significand of X.  Make sure to
-     call this function for all `mpfr_t' variables when you are done
-     with them.
-
- -- Function: void mpfr_clears (mpfr_t X, ...)
-     Free the space occupied by all the `mpfr_t' variables of the given
-     `va_list'. See `mpfr_clear' for more details.  The `va_list' is
-     assumed to be composed only of type `mpfr_t' (or equivalently
-     `mpfr_ptr').  It begins from X, and ends when it encounters a null
-     pointer (whose type must also be `mpfr_ptr').
-
-   Here is an example of how to use multiple initialization functions
-(since `NULL' is not necessarily defined in this context, we use
-`(mpfr_ptr) 0' instead, but `(mpfr_ptr) NULL' is also correct).
-
-     {
-       mpfr_t x, y, z, t;
-       mpfr_inits2 (256, x, y, z, t, (mpfr_ptr) 0);
-       ...
-       mpfr_clears (x, y, z, t, (mpfr_ptr) 0);
-     }
-
- -- Function: void mpfr_init (mpfr_t X)
-     Initialize X, set its precision to the default precision, and set
-     its value to NaN.  The default precision can be changed by a call
-     to `mpfr_set_default_prec'.
-
-     Warning! In a given program, some other libraries might change the
-     default precision and not restore it. Thus it is safer to use
-     `mpfr_init2'.
-
- -- Function: void mpfr_inits (mpfr_t X, ...)
-     Initialize all the `mpfr_t' variables of the given `va_list', set
-     their precision to the default precision and their value to NaN.
-     See `mpfr_init' for more details.  The `va_list' is assumed to be
-     composed only of type `mpfr_t' (or equivalently `mpfr_ptr').  It
-     begins from X, and ends when it encounters a null pointer (whose
-     type must also be `mpfr_ptr').
-
-     Warning! In a given program, some other libraries might change the
-     default precision and not restore it. Thus it is safer to use
-     `mpfr_inits2'.
-
- -- Macro: MPFR_DECL_INIT (NAME, PREC)
-     This macro declares NAME as an automatic variable of type `mpfr_t',
-     initializes it and sets its precision to be *exactly* PREC bits
-     and its value to NaN. NAME must be a valid identifier.  You must
-     use this macro in the declaration section.  This macro is much
-     faster than using `mpfr_init2' but has some drawbacks:
-
-        * You *must not* call `mpfr_clear' with variables created with
-          this macro (the storage is allocated at the point of
-          declaration and deallocated when the brace-level is exited).
-
-        * You *cannot* change their precision.
-
-        * You *should not* create variables with huge precision with
-          this macro.
-
-        * Your compiler must support `Non-Constant Initializers'
-          (standard in C++ and ISO C99) and `Token Pasting' (standard
-          in ISO C89). If PREC is not a constant expression, your
-          compiler must support `variable-length automatic arrays'
-          (standard in ISO C99). GCC 2.95.3 and above supports all
-          these features.  If you compile your program with GCC in C89
-          mode and with `-pedantic', you may want to define the
-          `MPFR_USE_EXTENSION' macro to avoid warnings due to the
-          `MPFR_DECL_INIT' implementation.
-
- -- Function: void mpfr_set_default_prec (mpfr_prec_t PREC)
-     Set the default precision to be *exactly* PREC bits, where PREC
-     can be any integer between `MPFR_PREC_MIN' and `MPFR_PREC_MAX'.
-     The precision of a variable means the number of bits used to store
-     its significand.  All subsequent calls to `mpfr_init' or
-     `mpfr_inits' will use this precision, but previously initialized
-     variables are unaffected.  The default precision is set to 53 bits
-     initially.
-
-     Note: when MPFR is built with the `--enable-thread-safe' configure
-     option, the default precision is local to each thread. *Note
-     Memory Handling::, for more information.
-
- -- Function: mpfr_prec_t mpfr_get_default_prec (void)
-     Return the current default MPFR precision in bits.  See the
-     documentation of `mpfr_set_default_prec'.
-
-   Here is an example on how to initialize floating-point variables:
-
-     {
-       mpfr_t x, y;
-       mpfr_init (x);                /* use default precision */
-       mpfr_init2 (y, 256);          /* precision _exactly_ 256 bits */
-       ...
-       /* When the program is about to exit, do ... */
-       mpfr_clear (x);
-       mpfr_clear (y);
-       mpfr_free_cache ();           /* free the cache for constants like pi */
-     }
-
-   The following functions are useful for changing the precision during
-a calculation.  A typical use would be for adjusting the precision
-gradually in iterative algorithms like Newton-Raphson, making the
-computation precision closely match the actual accurate part of the
-numbers.
-
- -- Function: void mpfr_set_prec (mpfr_t X, mpfr_prec_t PREC)
-     Reset the precision of X to be *exactly* PREC bits, and set its
-     value to NaN.  The previous value stored in X is lost. It is
-     equivalent to a call to `mpfr_clear(x)' followed by a call to
-     `mpfr_init2(x, prec)', but more efficient as no allocation is done
-     in case the current allocated space for the significand of X is
-     enough.  The precision PREC can be any integer between
-     `MPFR_PREC_MIN' and `MPFR_PREC_MAX'.  In case you want to keep the
-     previous value stored in X, use `mpfr_prec_round' instead.
-
- -- Function: mpfr_prec_t mpfr_get_prec (mpfr_t X)
-     Return the precision of X, i.e., the number of bits used to store
-     its significand.
-
-
-File: mpfr.info,  Node: Assignment Functions,  Next: Combined Initialization and Assignment Functions,  Prev: Initialization Functions,  Up: MPFR Interface
-
-5.2 Assignment Functions
-========================
-
-These functions assign new values to already initialized floats (*note
-Initialization Functions::).
-
- -- Function: int mpfr_set (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_set_ui (mpfr_t ROP, unsigned long int OP,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_set_si (mpfr_t ROP, long int OP, mpfr_rnd_t RND)
- -- Function: int mpfr_set_uj (mpfr_t ROP, uintmax_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_set_sj (mpfr_t ROP, intmax_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_set_flt (mpfr_t ROP, float OP, mpfr_rnd_t RND)
- -- Function: int mpfr_set_d (mpfr_t ROP, double OP, mpfr_rnd_t RND)
- -- Function: int mpfr_set_ld (mpfr_t ROP, long double OP, mpfr_rnd_t
-          RND)
- -- Function: int mpfr_set_decimal64 (mpfr_t ROP, _Decimal64 OP,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_set_z (mpfr_t ROP, mpz_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_set_q (mpfr_t ROP, mpq_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_set_f (mpfr_t ROP, mpf_t OP, mpfr_rnd_t RND)
-     Set the value of ROP from OP, rounded toward the given direction
-     RND.  Note that the input 0 is converted to +0 by `mpfr_set_ui',
-     `mpfr_set_si', `mpfr_set_uj', `mpfr_set_sj', `mpfr_set_z',
-     `mpfr_set_q' and `mpfr_set_f', regardless of the rounding mode.
-     If the system does not support the IEEE 754 standard,
-     `mpfr_set_flt', `mpfr_set_d', `mpfr_set_ld' and
-     `mpfr_set_decimal64' might not preserve the signed zeros.  The
-     `mpfr_set_decimal64' function is built only with the configure
-     option `--enable-decimal-float', which also requires
-     `--with-gmp-build', and when the compiler or system provides the
-     `_Decimal64' data type (recent versions of GCC support this data
-     type).  `mpfr_set_q' might fail if the numerator (or the
-     denominator) can not be represented as a `mpfr_t'.
-
-     Note: If you want to store a floating-point constant to a `mpfr_t',
-     you should use `mpfr_set_str' (or one of the MPFR constant
-     functions, such as `mpfr_const_pi' for Pi) instead of
-     `mpfr_set_flt', `mpfr_set_d', `mpfr_set_ld' or
-     `mpfr_set_decimal64'.  Otherwise the floating-point constant will
-     be first converted into a reduced-precision (e.g., 53-bit) binary
-     (or decimal, for `mpfr_set_decimal64') number before MPFR can work
-     with it.
-
- -- Function: int mpfr_set_ui_2exp (mpfr_t ROP, unsigned long int OP,
-          mpfr_exp_t E, mpfr_rnd_t RND)
- -- Function: int mpfr_set_si_2exp (mpfr_t ROP, long int OP, mpfr_exp_t
-          E, mpfr_rnd_t RND)
- -- Function: int mpfr_set_uj_2exp (mpfr_t ROP, uintmax_t OP, intmax_t
-          E, mpfr_rnd_t RND)
- -- Function: int mpfr_set_sj_2exp (mpfr_t ROP, intmax_t OP, intmax_t
-          E, mpfr_rnd_t RND)
- -- Function: int mpfr_set_z_2exp (mpfr_t ROP, mpz_t OP, mpfr_exp_t E,
-          mpfr_rnd_t RND)
-     Set the value of ROP from OP multiplied by two to the power E,
-     rounded toward the given direction RND.  Note that the input 0 is
-     converted to +0.
-
- -- Function: int mpfr_set_str (mpfr_t ROP, const char *S, int BASE,
-          mpfr_rnd_t RND)
-     Set ROP to the value of the string S in base BASE, rounded in the
-     direction RND.  See the documentation of `mpfr_strtofr' for a
-     detailed description of the valid string formats.  Contrary to
-     `mpfr_strtofr', `mpfr_set_str' requires the _whole_ string to
-     represent a valid floating-point number.
-
-     The meaning of the return value differs from other MPFR functions:
-     it is 0 if the entire string up to the final null character is a
-     valid number in base BASE; otherwise it is -1, and ROP may have
-     changed (users interested in the *note ternary value:: should use
-     `mpfr_strtofr' instead).
-
-     Note: it is preferable to use `mpfr_set_str' if one wants to
-     distinguish between an infinite ROP value coming from an infinite
-     S or from an overflow.
-
- -- Function: int mpfr_strtofr (mpfr_t ROP, const char *NPTR, char
-          **ENDPTR, int BASE, mpfr_rnd_t RND)
-     Read a floating-point number from a string NPTR in base BASE,
-     rounded in the direction RND; BASE must be either 0 (to detect the
-     base, as described below) or a number from 2 to 62 (otherwise the
-     behavior is undefined). If NPTR starts with valid data, the result
-     is stored in ROP and `*ENDPTR' points to the character just after
-     the valid data (if ENDPTR is not a null pointer); otherwise ROP is
-     set to zero (for consistency with `strtod') and the value of NPTR
-     is stored in the location referenced by ENDPTR (if ENDPTR is not a
-     null pointer). The usual ternary value is returned.
-
-     Parsing follows the standard C `strtod' function with some
-     extensions.  After optional leading whitespace, one has a subject
-     sequence consisting of an optional sign (`+' or `-'), and either
-     numeric data or special data. The subject sequence is defined as
-     the longest initial subsequence of the input string, starting with
-     the first non-whitespace character, that is of the expected form.
-
-     The form of numeric data is a non-empty sequence of significand
-     digits with an optional decimal point, and an optional exponent
-     consisting of an exponent prefix followed by an optional sign and
-     a non-empty sequence of decimal digits. A significand digit is
-     either a decimal digit or a Latin letter (62 possible characters),
-     with `A' = 10, `B' = 11, ..., `Z' = 35; case is ignored in bases
-     less or equal to 36, in bases larger than 36, `a' = 36, `b' = 37,
-     ..., `z' = 61.  The value of a significand digit must be strictly
-     less than the base.  The decimal point can be either the one
-     defined by the current locale or the period (the first one is
-     accepted for consistency with the C standard and the practice, the
-     second one is accepted to allow the programmer to provide MPFR
-     numbers from strings in a way that does not depend on the current
-     locale).  The exponent prefix can be `e' or `E' for bases up to
-     10, or `@' in any base; it indicates a multiplication by a power
-     of the base. In bases 2 and 16, the exponent prefix can also be
-     `p' or `P', in which case the exponent, called _binary exponent_,
-     indicates a multiplication by a power of 2 instead of the base
-     (there is a difference only for base 16); in base 16 for example
-     `1p2' represents 4 whereas `1@2' represents 256. The value of an
-     exponent is always written in base 10.
-
-     If the argument BASE is 0, then the base is automatically detected
-     as follows. If the significand starts with `0b' or `0B', base 2 is
-     assumed. If the significand starts with `0x' or `0X', base 16 is
-     assumed. Otherwise base 10 is assumed.
-
-     Note: The exponent (if present) must contain at least a digit.
-     Otherwise the possible exponent prefix and sign are not part of
-     the number (which ends with the significand). Similarly, if `0b',
-     `0B', `0x' or `0X' is not followed by a binary/hexadecimal digit,
-     then the subject sequence stops at the character `0', thus 0 is
-     read.
-
-     Special data (for infinities and NaN) can be `@inf@' or
-     `@nan@(n-char-sequence-opt)', and if BASE <= 16, it can also be
-     `infinity', `inf', `nan' or `nan(n-char-sequence-opt)', all case
-     insensitive.  A `n-char-sequence-opt' is a possibly empty string
-     containing only digits, Latin letters and the underscore (0, 1, 2,
-     ..., 9, a, b, ..., z, A, B, ..., Z, _). Note: one has an optional
-     sign for all data, even NaN.  For example,
-     `-@nAn@(This_Is_Not_17)' is a valid representation for NaN in base
-     17.
-
-
- -- Function: void mpfr_set_nan (mpfr_t X)
- -- Function: void mpfr_set_inf (mpfr_t X, int SIGN)
- -- Function: void mpfr_set_zero (mpfr_t X, int SIGN)
-     Set the variable X to NaN (Not-a-Number), infinity or zero
-     respectively.  In `mpfr_set_inf' or `mpfr_set_zero', X is set to
-     plus infinity or plus zero iff SIGN is nonnegative; in
-     `mpfr_set_nan', the sign bit of the result is unspecified.
-
- -- Function: void mpfr_swap (mpfr_t X, mpfr_t Y)
-     Swap the values X and Y efficiently. Warning: the precisions are
-     exchanged too; in case the precisions are different, `mpfr_swap'
-     is thus not equivalent to three `mpfr_set' calls using a third
-     auxiliary variable.
-
-
-File: mpfr.info,  Node: Combined Initialization and Assignment Functions,  Next: Conversion Functions,  Prev: Assignment Functions,  Up: MPFR Interface
-
-5.3 Combined Initialization and Assignment Functions
-====================================================
-
- -- Macro: int mpfr_init_set (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Macro: int mpfr_init_set_ui (mpfr_t ROP, unsigned long int OP,
-          mpfr_rnd_t RND)
- -- Macro: int mpfr_init_set_si (mpfr_t ROP, long int OP, mpfr_rnd_t
-          RND)
- -- Macro: int mpfr_init_set_d (mpfr_t ROP, double OP, mpfr_rnd_t RND)
- -- Macro: int mpfr_init_set_ld (mpfr_t ROP, long double OP, mpfr_rnd_t
-          RND)
- -- Macro: int mpfr_init_set_z (mpfr_t ROP, mpz_t OP, mpfr_rnd_t RND)
- -- Macro: int mpfr_init_set_q (mpfr_t ROP, mpq_t OP, mpfr_rnd_t RND)
- -- Macro: int mpfr_init_set_f (mpfr_t ROP, mpf_t OP, mpfr_rnd_t RND)
-     Initialize ROP and set its value from OP, rounded in the direction
-     RND.  The precision of ROP will be taken from the active default
-     precision, as set by `mpfr_set_default_prec'.
-
- -- Function: int mpfr_init_set_str (mpfr_t X, const char *S, int BASE,
-          mpfr_rnd_t RND)
-     Initialize X and set its value from the string S in base BASE,
-     rounded in the direction RND.  See `mpfr_set_str'.
-
-
-File: mpfr.info,  Node: Conversion Functions,  Next: Basic Arithmetic Functions,  Prev: Combined Initialization and Assignment Functions,  Up: MPFR Interface
-
-5.4 Conversion Functions
-========================
-
- -- Function: float mpfr_get_flt (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: double mpfr_get_d (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: long double mpfr_get_ld (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: _Decimal64 mpfr_get_decimal64 (mpfr_t OP, mpfr_rnd_t RND)
-     Convert OP to a `float' (respectively `double', `long double' or
-     `_Decimal64'), using the rounding mode RND.  If OP is NaN, some
-     fixed NaN (either quiet or signaling) or the result of 0.0/0.0 is
-     returned. If OP is Inf, an infinity of the same sign or the
-     result of 1.0/0.0 is returned. If OP is zero, these functions
-     return a zero, trying to preserve its sign, if possible.  The
-     `mpfr_get_decimal64' function is built only under some conditions:
-     see the documentation of `mpfr_set_decimal64'.
-
- -- Function: long mpfr_get_si (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: unsigned long mpfr_get_ui (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: intmax_t mpfr_get_sj (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: uintmax_t mpfr_get_uj (mpfr_t OP, mpfr_rnd_t RND)
-     Convert OP to a `long', an `unsigned long', an `intmax_t' or an
-     `uintmax_t' (respectively) after rounding it with respect to RND.
-     If OP is NaN, 0 is returned and the _erange_ flag is set.  If OP
-     is too big for the return type, the function returns the maximum
-     or the minimum of the corresponding C type, depending on the
-     direction of the overflow; the _erange_ flag is set too.  See also
-     `mpfr_fits_slong_p', `mpfr_fits_ulong_p', `mpfr_fits_intmax_p' and
-     `mpfr_fits_uintmax_p'.
-
- -- Function: double mpfr_get_d_2exp (long *EXP, mpfr_t OP, mpfr_rnd_t
-          RND)
- -- Function: long double mpfr_get_ld_2exp (long *EXP, mpfr_t OP,
-          mpfr_rnd_t RND)
-     Return D and set EXP (formally, the value pointed to by EXP) such
-     that 0.5<=abs(D)<1 and D times 2 raised to EXP equals OP rounded
-     to double (resp. long double) precision, using the given rounding
-     mode.  If OP is zero, then a zero of the same sign (or an unsigned
-     zero, if the implementation does not have signed zeros) is
-     returned, and EXP is set to 0.  If OP is NaN or an infinity, then
-     the corresponding double precision (resp. long-double precision)
-     value is returned, and EXP is undefined.
-
- -- Function: int mpfr_frexp (mpfr_exp_t *EXP, mpfr_t Y, mpfr_t X,
-          mpfr_rnd_t RND)
-     Set EXP (formally, the value pointed to by EXP) and Y such that
-     0.5<=abs(Y)<1 and Y times 2 raised to EXP equals X rounded to the
-     precision of Y, using the given rounding mode.  If X is zero, then
-     Y is set to a zero of the same sign and EXP is set to 0.  If X is
-     NaN or an infinity, then Y is set to the same value and EXP is
-     undefined.
-
- -- Function: mpfr_exp_t mpfr_get_z_2exp (mpz_t ROP, mpfr_t OP)
-     Put the scaled significand of OP (regarded as an integer, with the
-     precision of OP) into ROP, and return the exponent EXP (which may
-     be outside the current exponent range) such that OP exactly equals
-     ROP times 2 raised to the power EXP.  If OP is zero, the minimal
-     exponent `emin' is returned.  If OP is NaN or an infinity, the
-     _erange_ flag is set, ROP is set to 0, and the the minimal
-     exponent `emin' is returned.  The returned exponent may be less
-     than the minimal exponent `emin' of MPFR numbers in the current
-     exponent range; in case the exponent is not representable in the
-     `mpfr_exp_t' type, the _erange_ flag is set and the minimal value
-     of the `mpfr_exp_t' type is returned.
-
- -- Function: int mpfr_get_z (mpz_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Convert OP to a `mpz_t', after rounding it with respect to RND. If
-     OP is NaN or an infinity, the _erange_ flag is set, ROP is set to
-     0, and 0 is returned.
-
- -- Function: int mpfr_get_f (mpf_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Convert OP to a `mpf_t', after rounding it with respect to RND.
-     The _erange_ flag is set if OP is NaN or an infinity, which do not
-     exist in MPF.  If OP is NaN, then ROP is undefined.  If OP is an
-     +Inf (resp. -Inf), then ROP is set to the maximum (resp. minimum)
-     value in the precision of the MPF number; if a future MPF version
-     supports infinities, this behavior will be considered incorrect
-     and will change (portable programs should assume that ROP is set
-     either to this finite number or to an infinite number).  Note that
-     since MPFR currently has the same exponent type as MPF (but not
-     with the same radix), the range of values is much larger in MPF
-     than in MPFR, so that an overflow or underflow is not possible.
-
- -- Function: char * mpfr_get_str (char *STR, mpfr_exp_t *EXPPTR, int
-          B, size_t N, mpfr_t OP, mpfr_rnd_t RND)
-     Convert OP to a string of digits in base B, with rounding in the
-     direction RND, where N is either zero (see below) or the number of
-     significant digits output in the string; in the latter case, N
-     must be greater or equal to 2. The base may vary from 2 to 62.  If
-     the input number is an ordinary number, the exponent is written
-     through the pointer EXPPTR (for input 0, the current minimal
-     exponent is written).
-
-     The generated string is a fraction, with an implicit radix point
-     immediately to the left of the first digit.  For example, the
-     number -3.1416 would be returned as "-31416" in the string and 1
-     written at EXPPTR.  If RND is to nearest, and OP is exactly in the
-     middle of two consecutive possible outputs, the one with an even
-     significand is chosen, where both significands are considered with
-     the exponent of OP.  Note that for an odd base, this may not
-     correspond to an even last digit: for example with 2 digits in
-     base 7, (14) and a half is rounded to (15) which is 12 in decimal,
-     (16) and a half is rounded to (20) which is 14 in decimal, and
-     (26) and a half is rounded to (26) which is 20 in decimal.
-
-     If N is zero, the number of digits of the significand is chosen
-     large enough so that re-reading the printed value with the same
-     precision, assuming both output and input use rounding to nearest,
-     will recover the original value of OP.  More precisely, in most
-     cases, the chosen precision of STR is the minimal precision m
-     depending only on P = PREC(OP) and B that satisfies the above
-     property, i.e., m = 1 + ceil(P*log(2)/log(B)), with P replaced by
-     P-1 if B is a power of 2, but in some very rare cases, it might be
-     m+1 (the smallest case for bases up to 62 is when P equals
-     186564318007 for bases 7 and 49).
-
-     If STR is a null pointer, space for the significand is allocated
-     using the current allocation function, and a pointer to the string
-     is returned.  To free the returned string, you must use
-     `mpfr_free_str'.
-
-     If STR is not a null pointer, it should point to a block of storage
-     large enough for the significand, i.e., at least `max(N + 2, 7)'.
-     The extra two bytes are for a possible minus sign, and for the
-     terminating null character, and the value 7 accounts for `-@Inf@'
-     plus the terminating null character.
-
-     A pointer to the string is returned, unless there is an error, in
-     which case a null pointer is returned.
-
- -- Function: void mpfr_free_str (char *STR)
-     Free a string allocated by `mpfr_get_str' using the current
-     unallocation function.  The block is assumed to be `strlen(STR)+1'
-     bytes.  For more information about how it is done: *note Custom
-     Allocation: (gmp.info)Custom Allocation.
-
- -- Function: int mpfr_fits_ulong_p (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_fits_slong_p (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_fits_uint_p (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_fits_sint_p (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_fits_ushort_p (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_fits_sshort_p (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_fits_uintmax_p (mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_fits_intmax_p (mpfr_t OP, mpfr_rnd_t RND)
-     Return non-zero if OP would fit in the respective C data type,
-     respectively `unsigned long', `long', `unsigned int', `int',
-     `unsigned short', `short', `uintmax_t', `intmax_t', when rounded
-     to an integer in the direction RND.
-
-
-File: mpfr.info,  Node: Basic Arithmetic Functions,  Next: Comparison Functions,  Prev: Conversion Functions,  Up: MPFR Interface
-
-5.5 Basic Arithmetic Functions
-==============================
-
- -- Function: int mpfr_add (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_add_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_add_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_add_d (mpfr_t ROP, mpfr_t OP1, double OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_add_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_add_q (mpfr_t ROP, mpfr_t OP1, mpq_t OP2,
-          mpfr_rnd_t RND)
-     Set ROP to OP1 + OP2 rounded in the direction RND. For types
-     having no signed zero, it is considered unsigned (i.e., (+0) + 0 =
-     (+0) and (-0) + 0 = (-0)).  The `mpfr_add_d' function assumes that
-     the radix of the `double' type is a power of 2, with a precision
-     at most that declared by the C implementation (macro
-     `IEEE_DBL_MANT_DIG', and if not defined 53 bits).
-
- -- Function: int mpfr_sub (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_ui_sub (mpfr_t ROP, unsigned long int OP1,
-          mpfr_t OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_sub_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_si_sub (mpfr_t ROP, long int OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_sub_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_d_sub (mpfr_t ROP, double OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_sub_d (mpfr_t ROP, mpfr_t OP1, double OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_z_sub (mpfr_t ROP, mpz_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_sub_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_sub_q (mpfr_t ROP, mpfr_t OP1, mpq_t OP2,
-          mpfr_rnd_t RND)
-     Set ROP to OP1 - OP2 rounded in the direction RND. For types
-     having no signed zero, it is considered unsigned (i.e., (+0) - 0 =
-     (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).  The
-     same restrictions than for `mpfr_add_d' apply to `mpfr_d_sub' and
-     `mpfr_sub_d'.
-
- -- Function: int mpfr_mul (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_mul_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_mul_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_mul_d (mpfr_t ROP, mpfr_t OP1, double OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_mul_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_mul_q (mpfr_t ROP, mpfr_t OP1, mpq_t OP2,
-          mpfr_rnd_t RND)
-     Set ROP to OP1 times OP2 rounded in the direction RND.  When a
-     result is zero, its sign is the product of the signs of the
-     operands (for types having no signed zero, it is considered
-     positive).  The same restrictions than for `mpfr_add_d' apply to
-     `mpfr_mul_d'.
-
- -- Function: int mpfr_sqr (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the square of OP rounded in the direction RND.
-
- -- Function: int mpfr_div (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_ui_div (mpfr_t ROP, unsigned long int OP1,
-          mpfr_t OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_div_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_si_div (mpfr_t ROP, long int OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_div_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_d_div (mpfr_t ROP, double OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_div_d (mpfr_t ROP, mpfr_t OP1, double OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_div_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_div_q (mpfr_t ROP, mpfr_t OP1, mpq_t OP2,
-          mpfr_rnd_t RND)
-     Set ROP to OP1/OP2 rounded in the direction RND.  When a result is
-     zero, its sign is the product of the signs of the operands (for
-     types having no signed zero, it is considered positive).  The same
-     restrictions than for `mpfr_add_d' apply to `mpfr_d_div' and
-     `mpfr_div_d'.
-
- -- Function: int mpfr_sqrt (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_sqrt_ui (mpfr_t ROP, unsigned long int OP,
-          mpfr_rnd_t RND)
-     Set ROP to the square root of OP rounded in the direction RND (set
-     ROP to -0 if OP is -0, to be consistent with the IEEE 754
-     standard).  Set ROP to NaN if OP is negative.
-
- -- Function: int mpfr_rec_sqrt (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the reciprocal square root of OP rounded in the
-     direction RND. Set ROP to +Inf if OP is 0, +0 if OP is +Inf, and
-     NaN if OP is negative.
-
- -- Function: int mpfr_cbrt (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_root (mpfr_t ROP, mpfr_t OP, unsigned long int
-          K, mpfr_rnd_t RND)
-     Set ROP to the cubic root (resp. the Kth root) of OP rounded in
-     the direction RND.  For K odd (resp. even) and OP negative
-     (including -Inf), set ROP to a negative number (resp. NaN).  The
-     Kth root of -0 is defined to be -0, whatever the parity of K.
-
- -- Function: int mpfr_pow (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_pow_ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_pow_si (mpfr_t ROP, mpfr_t OP1, long int OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_pow_z (mpfr_t ROP, mpfr_t OP1, mpz_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_ui_pow_ui (mpfr_t ROP, unsigned long int OP1,
-          unsigned long int OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_ui_pow (mpfr_t ROP, unsigned long int OP1,
-          mpfr_t OP2, mpfr_rnd_t RND)
-     Set ROP to OP1 raised to OP2, rounded in the direction RND.
-     Special values are handled as described in the ISO C99 and IEEE
-     754-2008 standards for the `pow' function:
-        * `pow(0, Y)' returns plus or minus infinity for Y a negative
-          odd integer.
-
-        * `pow(0, Y)' returns plus infinity for Y negative and not an
-          odd integer.
-
-        * `pow(0, Y)' returns plus or minus zero for Y a positive odd
-          integer.
-
-        * `pow(0, Y)' returns plus zero for Y positive and not an odd
-          integer.
-
-        * `pow(-1, Inf)' returns 1.
-
-        * `pow(+1, Y)' returns 1 for any Y, even a NaN.
-
-        * `pow(X, 0)' returns 1 for any X, even a NaN.
-
-        * `pow(X, Y)' returns NaN for finite negative X and finite
-          non-integer Y.
-
-        * `pow(X, -Inf)' returns plus infinity for 0 < abs(x) < 1, and
-          plus zero for abs(x) > 1.
-
-        * `pow(X, +Inf)' returns plus zero for 0 < abs(x) < 1, and plus
-          infinity for abs(x) > 1.
-
-        * `pow(-Inf, Y)' returns minus zero for Y a negative odd
-          integer.
-
-        * `pow(-Inf, Y)' returns plus zero for Y negative and not an
-          odd integer.
-
-        * `pow(-Inf, Y)' returns minus infinity for Y a positive odd
-          integer.
-
-        * `pow(-Inf, Y)' returns plus infinity for Y positive and not
-          an odd integer.
-
-        * `pow(+Inf, Y)' returns plus zero for Y negative, and plus
-          infinity for Y positive.
-
- -- Function: int mpfr_neg (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_abs (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to -OP and the absolute value of OP respectively, rounded
-     in the direction RND.  Just changes or adjusts the sign if ROP and
-     OP are the same variable, otherwise a rounding might occur if the
-     precision of ROP is less than that of OP.
-
- -- Function: int mpfr_dim (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
-     Set ROP to the positive difference of OP1 and OP2, i.e., OP1 - OP2
-     rounded in the direction RND if OP1 > OP2, +0 if OP1 <= OP2, and
-     NaN if OP1 or OP2 is NaN.
-
- -- Function: int mpfr_mul_2ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_mul_2si (mpfr_t ROP, mpfr_t OP1, long int OP2,
-          mpfr_rnd_t RND)
-     Set ROP to OP1 times 2 raised to OP2 rounded in the direction RND.
-     Just increases the exponent by OP2 when ROP and OP1 are identical.
-
- -- Function: int mpfr_div_2ui (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_div_2si (mpfr_t ROP, mpfr_t OP1, long int OP2,
-          mpfr_rnd_t RND)
-     Set ROP to OP1 divided by 2 raised to OP2 rounded in the direction
-     RND. Just decreases the exponent by OP2 when ROP and OP1 are
-     identical.
-
-
-File: mpfr.info,  Node: Comparison Functions,  Next: Special Functions,  Prev: Basic Arithmetic Functions,  Up: MPFR Interface
-
-5.6 Comparison Functions
-========================
-
- -- Function: int mpfr_cmp (mpfr_t OP1, mpfr_t OP2)
- -- Function: int mpfr_cmp_ui (mpfr_t OP1, unsigned long int OP2)
- -- Function: int mpfr_cmp_si (mpfr_t OP1, long int OP2)
- -- Function: int mpfr_cmp_d (mpfr_t OP1, double OP2)
- -- Function: int mpfr_cmp_ld (mpfr_t OP1, long double OP2)
- -- Function: int mpfr_cmp_z (mpfr_t OP1, mpz_t OP2)
- -- Function: int mpfr_cmp_q (mpfr_t OP1, mpq_t OP2)
- -- Function: int mpfr_cmp_f (mpfr_t OP1, mpf_t OP2)
-     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
-     if OP1 = OP2, and a negative value if OP1 < OP2.  Both OP1 and OP2
-     are considered to their full own precision, which may differ.  If
-     one of the operands is NaN, set the _erange_ flag and return zero.
-
-     Note: These functions may be useful to distinguish the three
-     possible cases.  If you need to distinguish two cases only, it is
-     recommended to use the predicate functions (e.g., `mpfr_equal_p'
-     for the equality) described below; they behave like the IEEE 754
-     comparisons, in particular when one or both arguments are NaN. But
-     only floating-point numbers can be compared (you may need to do a
-     conversion first).
-
- -- Function: int mpfr_cmp_ui_2exp (mpfr_t OP1, unsigned long int OP2,
-          mpfr_exp_t E)
- -- Function: int mpfr_cmp_si_2exp (mpfr_t OP1, long int OP2,
-          mpfr_exp_t E)
-     Compare OP1 and OP2 multiplied by two to the power E. Similar as
-     above.
-
- -- Function: int mpfr_cmpabs (mpfr_t OP1, mpfr_t OP2)
-     Compare |OP1| and |OP2|.  Return a positive value if |OP1| >
-     |OP2|, zero if |OP1| = |OP2|, and a negative value if |OP1| <
-     |OP2|.  If one of the operands is NaN, set the _erange_ flag and
-     return zero.
-
- -- Function: int mpfr_nan_p (mpfr_t OP)
- -- Function: int mpfr_inf_p (mpfr_t OP)
- -- Function: int mpfr_number_p (mpfr_t OP)
- -- Function: int mpfr_zero_p (mpfr_t OP)
- -- Function: int mpfr_regular_p (mpfr_t OP)
-     Return non-zero if OP is respectively NaN, an infinity, an ordinary
-     number (i.e., neither NaN nor an infinity), zero, or a regular
-     number (i.e., neither NaN, nor an infinity nor zero). Return zero
-     otherwise.
-
- -- Macro: int mpfr_sgn (mpfr_t OP)
-     Return a positive value if OP > 0, zero if OP = 0, and a negative
-     value if OP < 0.  If the operand is NaN, set the _erange_ flag and
-     return zero.  This is equivalent to `mpfr_cmp_ui (op, 0)', but
-     more efficient.
-
- -- Function: int mpfr_greater_p (mpfr_t OP1, mpfr_t OP2)
- -- Function: int mpfr_greaterequal_p (mpfr_t OP1, mpfr_t OP2)
- -- Function: int mpfr_less_p (mpfr_t OP1, mpfr_t OP2)
- -- Function: int mpfr_lessequal_p (mpfr_t OP1, mpfr_t OP2)
- -- Function: int mpfr_equal_p (mpfr_t OP1, mpfr_t OP2)
-     Return non-zero if OP1 > OP2, OP1 >= OP2, OP1 < OP2, OP1 <= OP2,
-     OP1 = OP2 respectively, and zero otherwise.  Those functions
-     return zero whenever OP1 and/or OP2 is NaN.
-
- -- Function: int mpfr_lessgreater_p (mpfr_t OP1, mpfr_t OP2)
-     Return non-zero if OP1 < OP2 or OP1 > OP2 (i.e., neither OP1, nor
-     OP2 is NaN, and OP1 <> OP2), zero otherwise (i.e., OP1 and/or OP2
-     is NaN, or OP1 = OP2).
-
- -- Function: int mpfr_unordered_p (mpfr_t OP1, mpfr_t OP2)
-     Return non-zero if OP1 or OP2 is a NaN (i.e., they cannot be
-     compared), zero otherwise.
-
-
-File: mpfr.info,  Node: Special Functions,  Next: Input and Output Functions,  Prev: Comparison Functions,  Up: MPFR Interface
-
-5.7 Special Functions
-=====================
-
-All those functions, except explicitly stated (for example
-`mpfr_sin_cos'), return a *note ternary value::, i.e., zero for an
-exact return value, a positive value for a return value larger than the
-exact result, and a negative value otherwise.
-
-   Important note: in some domains, computing special functions (either
-with correct or incorrect rounding) is expensive, even for small
-precision, for example the trigonometric and Bessel functions for large
-argument.
-
- -- Function: int mpfr_log (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_log2 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_log10 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the natural logarithm of OP, log2(OP) or log10(OP),
-     respectively, rounded in the direction RND.  Set ROP to -Inf if OP
-     is -0 (i.e., the sign of the zero has no influence on the result).
-
- -- Function: int mpfr_exp (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_exp2 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_exp10 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the exponential of OP,  to 2 power of OP or to 10 power
-     of OP, respectively, rounded in the direction RND.
-
- -- Function: int mpfr_cos (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_sin (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_tan (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the cosine of OP, sine of OP, tangent of OP, rounded in
-     the direction RND.
-
- -- Function: int mpfr_sin_cos (mpfr_t SOP, mpfr_t COP, mpfr_t OP,
-          mpfr_rnd_t RND)
-     Set simultaneously SOP to the sine of OP and COP to the cosine of
-     OP, rounded in the direction RND with the corresponding precisions
-     of SOP and COP, which must be different variables.  Return 0 iff
-     both results are exact, more precisely it returns s+4c where s=0
-     if SOP is exact, s=1 if SOP is larger than the sine of OP, s=2 if
-     SOP is smaller than the sine of OP, and similarly for c and the
-     cosine of OP.
-
- -- Function: int mpfr_sec (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_csc (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_cot (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the secant of OP, cosecant of OP, cotangent of OP,
-     rounded in the direction RND.
-
- -- Function: int mpfr_acos (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_asin (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_atan (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the arc-cosine, arc-sine or arc-tangent of OP, rounded
-     in the direction RND.  Note that since `acos(-1)' returns the
-     floating-point number closest to Pi according to the given
-     rounding mode, this number might not be in the output range 0 <=
-     ROP < \pi of the arc-cosine function; still, the result lies in
-     the image of the output range by the rounding function.  The same
-     holds for `asin(-1)', `asin(1)', `atan(-Inf)', `atan(+Inf)' or for
-     `atan(op)' with large OP and small precision of ROP.
-
- -- Function: int mpfr_atan2 (mpfr_t ROP, mpfr_t Y, mpfr_t X,
-          mpfr_rnd_t RND)
-     Set ROP to the arc-tangent2 of Y and X, rounded in the direction
-     RND: if `x > 0', `atan2(y, x) = atan (y/x)'; if `x < 0', `atan2(y,
-     x) = sign(y)*(Pi - atan (abs(y/x)))', thus a number from -Pi to Pi.
-     As for `atan', in case the exact mathematical result is +Pi or -Pi,
-     its rounded result might be outside the function output range.
-
-     `atan2(y, 0)' does not raise any floating-point exception.
-     Special values are handled as described in the ISO C99 and IEEE
-     754-2008 standards for the `atan2' function:
-        * `atan2(+0, -0)' returns +Pi.
-
-        * `atan2(-0, -0)' returns -Pi.
-
-        * `atan2(+0, +0)' returns +0.
-
-        * `atan2(-0, +0)' returns -0.
-
-        * `atan2(+0, x)' returns +Pi for x < 0.
-
-        * `atan2(-0, x)' returns -Pi for x < 0.
-
-        * `atan2(+0, x)' returns +0 for x > 0.
-
-        * `atan2(-0, x)' returns -0 for x > 0.
-
-        * `atan2(y, 0)' returns -Pi/2 for y < 0.
-
-        * `atan2(y, 0)' returns +Pi/2 for y > 0.
-
-        * `atan2(+Inf, -Inf)' returns +3*Pi/4.
-
-        * `atan2(-Inf, -Inf)' returns -3*Pi/4.
-
-        * `atan2(+Inf, +Inf)' returns +Pi/4.
-
-        * `atan2(-Inf, +Inf)' returns -Pi/4.
-
-        * `atan2(+Inf, x)' returns +Pi/2 for finite x.
-
-        * `atan2(-Inf, x)' returns -Pi/2 for finite x.
-
-        * `atan2(y, -Inf)' returns +Pi for finite y > 0.
-
-        * `atan2(y, -Inf)' returns -Pi for finite y < 0.
-
-        * `atan2(y, +Inf)' returns +0 for finite y > 0.
-
-        * `atan2(y, +Inf)' returns -0 for finite y < 0.
-
- -- Function: int mpfr_cosh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_sinh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_tanh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the hyperbolic cosine, sine or tangent of OP, rounded
-     in the direction RND.
-
- -- Function: int mpfr_sinh_cosh (mpfr_t SOP, mpfr_t COP, mpfr_t OP,
-          mpfr_rnd_t RND)
-     Set simultaneously SOP to the hyperbolic sine of OP and COP to the
-     hyperbolic cosine of OP, rounded in the direction RND with the
-     corresponding precision of SOP and COP, which must be different
-     variables.  Return 0 iff both results are exact (see
-     `mpfr_sin_cos' for a more detailed description of the return
-     value).
-
- -- Function: int mpfr_sech (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_csch (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_coth (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the hyperbolic secant of OP, cosecant of OP, cotangent
-     of OP, rounded in the direction RND.
-
- -- Function: int mpfr_acosh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_asinh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_atanh (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the inverse hyperbolic cosine, sine or tangent of OP,
-     rounded in the direction RND.
-
- -- Function: int mpfr_fac_ui (mpfr_t ROP, unsigned long int OP,
-          mpfr_rnd_t RND)
-     Set ROP to the factorial of OP, rounded in the direction RND.
-
- -- Function: int mpfr_log1p (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the logarithm of one plus OP, rounded in the direction
-     RND.
-
- -- Function: int mpfr_expm1 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the exponential of OP followed by a subtraction by one,
-     rounded in the direction RND.
-
- -- Function: int mpfr_eint (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the exponential integral of OP, rounded in the
-     direction RND.  For positive OP, the exponential integral is the
-     sum of Euler's constant, of the logarithm of OP, and of the sum
-     for k from 1 to infinity of OP to the power k, divided by k and
-     factorial(k).  For negative OP, ROP is set to NaN (this definition
-     for negative argument follows formula 5.1.2 from the Handbook of
-     Mathematical Functions from Abramowitz and Stegun, a future
-     version might use another definition).
-
- -- Function: int mpfr_li2 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to real part of the dilogarithm of OP, rounded in the
-     direction RND. MPFR defines the dilogarithm function as the
-     integral of -log(1-t)/t from 0 to OP.
-
- -- Function: int mpfr_gamma (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the value of the Gamma function on OP, rounded in the
-     direction RND. When OP is a negative integer, ROP is set to NaN.
-
- -- Function: int mpfr_lngamma (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the value of the logarithm of the Gamma function on OP,
-     rounded in the direction RND.  When -2K-1 <= OP <= -2K, K being a
-     non-negative integer, ROP is set to NaN.  See also `mpfr_lgamma'.
-
- -- Function: int mpfr_lgamma (mpfr_t ROP, int *SIGNP, mpfr_t OP,
-          mpfr_rnd_t RND)
-     Set ROP to the value of the logarithm of the absolute value of the
-     Gamma function on OP, rounded in the direction RND. The sign (1 or
-     -1) of Gamma(OP) is returned in the object pointed to by SIGNP.
-     When OP is an infinity or a non-positive integer, set ROP to +Inf.
-     When OP is NaN, -Inf or a negative integer, *SIGNP is undefined,
-     and when OP is 0, *SIGNP is the sign of the zero.
-
- -- Function: int mpfr_digamma (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the value of the Digamma (sometimes also called Psi)
-     function on OP, rounded in the direction RND.  When OP is a
-     negative integer, set ROP to NaN.
-
- -- Function: int mpfr_zeta (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_zeta_ui (mpfr_t ROP, unsigned long OP,
-          mpfr_rnd_t RND)
-     Set ROP to the value of the Riemann Zeta function on OP, rounded
-     in the direction RND.
-
- -- Function: int mpfr_erf (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_erfc (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the value of the error function on OP (resp. the
-     complementary error function on OP) rounded in the direction RND.
-
- -- Function: int mpfr_j0 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_j1 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_jn (mpfr_t ROP, long N, mpfr_t OP, mpfr_rnd_t
-          RND)
-     Set ROP to the value of the first kind Bessel function of order 0,
-     (resp. 1 and N) on OP, rounded in the direction RND. When OP is
-     NaN, ROP is always set to NaN. When OP is plus or minus Infinity,
-     ROP is set to +0. When OP is zero, and N is not zero, ROP is set
-     to +0 or -0 depending on the parity and sign of N, and the sign of
-     OP.
-
- -- Function: int mpfr_y0 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_y1 (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_yn (mpfr_t ROP, long N, mpfr_t OP, mpfr_rnd_t
-          RND)
-     Set ROP to the value of the second kind Bessel function of order 0
-     (resp. 1 and N) on OP, rounded in the direction RND. When OP is
-     NaN or negative, ROP is always set to NaN. When OP is +Inf, ROP is
-     set to +0. When OP is zero, ROP is set to +Inf or -Inf depending
-     on the parity and sign of N.
-
- -- Function: int mpfr_fma (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2, mpfr_t
-          OP3, mpfr_rnd_t RND)
- -- Function: int mpfr_fms (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2, mpfr_t
-          OP3, mpfr_rnd_t RND)
-     Set ROP to (OP1 times OP2) + OP3 (resp. (OP1 times OP2) - OP3)
-     rounded in the direction RND.
-
- -- Function: int mpfr_agm (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
-     Set ROP to the arithmetic-geometric mean of OP1 and OP2, rounded
-     in the direction RND.  The arithmetic-geometric mean is the common
-     limit of the sequences U_N and V_N, where U_0=OP1, V_0=OP2,
-     U_(N+1) is the arithmetic mean of U_N and V_N, and V_(N+1) is the
-     geometric mean of U_N and V_N.  If any operand is negative, set
-     ROP to NaN.
-
- -- Function: int mpfr_hypot (mpfr_t ROP, mpfr_t X, mpfr_t Y,
-          mpfr_rnd_t RND)
-     Set ROP to the Euclidean norm of X and Y, i.e., the square root of
-     the sum of the squares of X and Y, rounded in the direction RND.
-     Special values are handled as described in Section F.9.4.3 of the
-     ISO C99 and IEEE 754-2008 standards: If X or Y is an infinity,
-     then +Inf is returned in ROP, even if the other number is NaN.
-
- -- Function: int mpfr_ai (mpfr_t ROP, mpfr_t X, mpfr_rnd_t RND)
-     Set ROP to the value of the Airy function Ai  on X, rounded in the
-     direction RND.  When X is NaN, ROP is always set to NaN. When X is
-     +Inf or -Inf, ROP is +0.  The current implementation is not
-     intended to be used with large arguments.  It works with abs(X)
-     typically smaller than 500. For larger arguments, other methods
-     should be used and will be implemented in a future version.
-
- -- Function: int mpfr_const_log2 (mpfr_t ROP, mpfr_rnd_t RND)
- -- Function: int mpfr_const_pi (mpfr_t ROP, mpfr_rnd_t RND)
- -- Function: int mpfr_const_euler (mpfr_t ROP, mpfr_rnd_t RND)
- -- Function: int mpfr_const_catalan (mpfr_t ROP, mpfr_rnd_t RND)
-     Set ROP to the logarithm of 2, the value of Pi, of Euler's
-     constant 0.577..., of Catalan's constant 0.915..., respectively,
-     rounded in the direction RND. These functions cache the computed
-     values to avoid other calculations if a lower or equal precision
-     is requested. To free these caches, use `mpfr_free_cache'.
-
- -- Function: void mpfr_free_cache (void)
-     Free various caches used by MPFR internally, in particular the
-     caches used by the functions computing constants
-     (`mpfr_const_log2', `mpfr_const_pi', `mpfr_const_euler' and
-     `mpfr_const_catalan').  You should call this function before
-     terminating a thread, even if you did not call these functions
-     directly (they could have been called internally).
-
- -- Function: int mpfr_sum (mpfr_t ROP, mpfr_ptr const TAB[], unsigned
-          long int N, mpfr_rnd_t RND)
-     Set ROP to the sum of all elements of TAB, whose size is N,
-     rounded in the direction RND. Warning: for efficiency reasons, TAB
-     is an array of pointers to `mpfr_t', not an array of `mpfr_t'.  If
-     the returned `int' value is zero, ROP is guaranteed to be the
-     exact sum; otherwise ROP might be smaller than, equal to, or
-     larger than the exact sum (in accordance to the rounding mode).
-     However, `mpfr_sum' does guarantee the result is correctly rounded.
-
-
-File: mpfr.info,  Node: Input and Output Functions,  Next: Formatted Output Functions,  Prev: Special Functions,  Up: MPFR Interface
-
-5.8 Input and Output Functions
-==============================
-
-This section describes functions that perform input from an input/output
-stream, and functions that output to an input/output stream.  Passing a
-null pointer for a `stream' to any of these functions will make them
-read from `stdin' and write to `stdout', respectively.
-
-   When using any of these functions, you must include the `<stdio.h>'
-standard header before `mpfr.h', to allow `mpfr.h' to define prototypes
-for these functions.
-
- -- Function: size_t mpfr_out_str (FILE *STREAM, int BASE, size_t N,
-          mpfr_t OP, mpfr_rnd_t RND)
-     Output OP on stream STREAM, as a string of digits in base BASE,
-     rounded in the direction RND.  The base may vary from 2 to 62.
-     Print N significant digits exactly, or if N is 0, enough digits so
-     that OP can be read back exactly (see `mpfr_get_str').
-
-     In addition to the significant digits, a decimal point (defined by
-     the current locale) at the right of the first digit and a trailing
-     exponent in base 10, in the form `eNNN', are printed. If BASE is
-     greater than 10, `@' will be used instead of `e' as exponent
-     delimiter.
-
-     Return the number of characters written, or if an error occurred,
-     return 0.
-
- -- Function: size_t mpfr_inp_str (mpfr_t ROP, FILE *STREAM, int BASE,
-          mpfr_rnd_t RND)
-     Input a string in base BASE from stream STREAM, rounded in the
-     direction RND, and put the read float in ROP.
-
-     This function reads a word (defined as a sequence of characters
-     between whitespace) and parses it using `mpfr_set_str'.  See the
-     documentation of `mpfr_strtofr' for a detailed description of the
-     valid string formats.
-
-     Return the number of bytes read, or if an error occurred, return 0.
-
-
-File: mpfr.info,  Node: Formatted Output Functions,  Next: Integer Related Functions,  Prev: Input and Output Functions,  Up: MPFR Interface
-
-5.9 Formatted Output Functions
-==============================
-
-5.9.1 Requirements
-------------------
-
-The class of `mpfr_printf' functions provides formatted output in a
-similar manner as the standard C `printf'. These functions are defined
-only if your system supports ISO C variadic functions and the
-corresponding argument access macros.
-
-   When using any of these functions, you must include the `<stdio.h>'
-standard header before `mpfr.h', to allow `mpfr.h' to define prototypes
-for these functions.
-
-5.9.2 Format String
--------------------
-
-The format specification accepted by `mpfr_printf' is an extension of
-the `printf' one. The conversion specification is of the form:
-     % [flags] [width] [.[precision]] [type] [rounding] conv
-   `flags', `width', and `precision' have the same meaning as for the
-standard `printf' (in particular, notice that the `precision' is
-related to the number of digits displayed in the base chosen by `conv'
-and not related to the internal precision of the `mpfr_t' variable).
-`mpfr_printf' accepts the same `type' specifiers as GMP (except the
-non-standard and deprecated `q', use `ll' instead), namely the length
-modifiers defined in the C standard:
-
-     `h'       `short'
-     `hh'      `char'
-     `j'       `intmax_t' or `uintmax_t'
-     `l'       `long' or `wchar_t'
-     `ll'      `long long'
-     `L'       `long double'
-     `t'       `ptrdiff_t'
-     `z'       `size_t'
-
-   and the `type' specifiers defined in GMP plus `R' and `P' specific
-to MPFR (the second column in the table below shows the type of the
-argument read in the argument list and the kind of `conv' specifier to
-use after the `type' specifier):
-
-     `F'       `mpf_t', float conversions
-     `Q'       `mpq_t', integer conversions
-     `M'       `mp_limb_t', integer conversions
-     `N'       `mp_limb_t' array, integer conversions
-     `Z'       `mpz_t', integer conversions
-     `P'       `mpfr_prec_t', integer conversions
-     `R'       `mpfr_t', float conversions
-
-   The `type' specifiers have the same restrictions as those mentioned
-in the GMP documentation: *note Formatted Output Strings:
-(gmp.info)Formatted Output Strings.  In particular, the `type'
-specifiers (except `R' and `P') are supported only if they are
-supported by `gmp_printf' in your GMP build; this implies that the
-standard specifiers, such as `t', must _also_ be supported by your C
-library if you want to use them.
-
-   The `rounding' field is specific to `mpfr_t' arguments and should
-not be used with other types.
-
-   With conversion specification not involving `P' and `R' types,
-`mpfr_printf' behaves exactly as `gmp_printf'.
-
-   The `P' type specifies that a following `o', `u', `x', or `X'
-conversion specifier applies to a `mpfr_prec_t' argument.  It is needed
-because the `mpfr_prec_t' type does not necessarily correspond to an
-`unsigned int' or any fixed standard type.  The `precision' field
-specifies the minimum number of digits to appear. The default
-`precision' is 1.  For example:
-     mpfr_t x;
-     mpfr_prec_t p;
-     mpfr_init (x);
-     ...
-     p = mpfr_get_prec (x);
-     mpfr_printf ("variable x with %Pu bits", p);
-
-   The `R' type specifies that a following `a', `A', `b', `e', `E',
-`f', `F', `g', `G', or `n' conversion specifier applies to a `mpfr_t'
-argument.  The `R' type can be followed by a `rounding' specifier
-denoted by one of the following characters:
-
-     `U'       round toward plus infinity
-     `D'       round toward minus infinity
-     `Y'       round away from zero
-     `Z'       round toward zero
-     `N'       round to nearest (with ties to even)
-     `*'       rounding mode indicated by the
-               `mpfr_rnd_t' argument just before the
-               corresponding `mpfr_t' variable.
-
-   The default rounding mode is rounding to nearest.  The following
-three examples are equivalent:
-     mpfr_t x;
-     mpfr_init (x);
-     ...
-     mpfr_printf ("%.128Rf", x);
-     mpfr_printf ("%.128RNf", x);
-     mpfr_printf ("%.128R*f", MPFR_RNDN, x);
-
-   Note that the rounding away from zero mode is specified with `Y'
-because ISO C reserves the `A' specifier for hexadecimal output (see
-below).
-
-   The output `conv' specifiers allowed with `mpfr_t' parameter are:
-
-     `a' `A'   hex float, C99 style
-     `b'       binary output
-     `e' `E'   scientific format float
-     `f' `F'   fixed point float
-     `g' `G'   fixed or scientific float
-
-   The conversion specifier `b' which displays the argument in binary is
-specific to `mpfr_t' arguments and should not be used with other types.
-Other conversion specifiers have the same meaning as for a `double'
-argument.
-
-   In case of non-decimal output, only the significand is written in the
-specified base, the exponent is always displayed in decimal.  Special
-values are always displayed as `nan', `-inf', and `inf' for `a', `b',
-`e', `f', and `g' specifiers and `NAN', `-INF', and `INF' for `A', `E',
-`F', and `G' specifiers.
-
-   If the `precision' field is not empty, the `mpfr_t' number is
-rounded to the given precision in the direction specified by the
-rounding mode.  If the precision is zero with rounding to nearest mode
-and one of the following `conv' specifiers: `a', `A', `b', `e', `E',
-tie case is rounded to even when it lies between two consecutive values
-at the wanted precision which have the same exponent, otherwise, it is
-rounded away from zero.  For instance, 85 is displayed as "8e+1" and 95
-is displayed as "1e+2" with the format specification `"%.0RNe"'.  This
-also applies when the `g' (resp. `G') conversion specifier uses the `e'
-(resp. `E') style.  If the precision is set to a value greater than the
-maximum value for an `int', it will be silently reduced down to
-`INT_MAX'.
-
-   If the `precision' field is empty (as in `%Re' or `%.RE') with
-`conv' specifier `e' and `E', the number is displayed with enough
-digits so that it can be read back exactly, assuming that the input and
-output variables have the same precision and that the input and output
-rounding modes are both rounding to nearest (as for `mpfr_get_str').
-The default precision for an empty `precision' field with `conv'
-specifiers `f', `F', `g', and `G' is 6.
-
-5.9.3 Functions
----------------
-
-For all the following functions, if the number of characters which
-ought to be written appears to exceed the maximum limit for an `int',
-nothing is written in the stream (resp. to `stdout', to BUF, to STR),
-the function returns -1, sets the _erange_ flag, and (in POSIX system
-only) `errno' is set to `EOVERFLOW'.
-
- -- Function: int mpfr_fprintf (FILE *STREAM, const char *TEMPLATE, ...)
- -- Function: int mpfr_vfprintf (FILE *STREAM, const char *TEMPLATE,
-          va_list AP)
-     Print to the stream STREAM the optional arguments under the
-     control of the template string TEMPLATE.  Return the number of
-     characters written or a negative value if an error occurred.
-
- -- Function: int mpfr_printf (const char *TEMPLATE, ...)
- -- Function: int mpfr_vprintf (const char *TEMPLATE, va_list AP)
-     Print to `stdout' the optional arguments under the control of the
-     template string TEMPLATE.  Return the number of characters written
-     or a negative value if an error occurred.
-
- -- Function: int mpfr_sprintf (char *BUF, const char *TEMPLATE, ...)
- -- Function: int mpfr_vsprintf (char *BUF, const char *TEMPLATE,
-          va_list AP)
-     Form a null-terminated string corresponding to the optional
-     arguments under the control of the template string TEMPLATE, and
-     print it in BUF. No overlap is permitted between BUF and the other
-     arguments.  Return the number of characters written in the array
-     BUF _not counting_ the terminating null character or a negative
-     value if an error occurred.
-
- -- Function: int mpfr_snprintf (char *BUF, size_t N, const char
-          *TEMPLATE, ...)
- -- Function: int mpfr_vsnprintf (char *BUF, size_t N, const char
-          *TEMPLATE, va_list AP)
-     Form a null-terminated string corresponding to the optional
-     arguments under the control of the template string TEMPLATE, and
-     print it in BUF. If N is zero, nothing is written and BUF may be a
-     null pointer, otherwise, the N-1 first characters are written in
-     BUF and the N-th is a null character.  Return the number of
-     characters that would have been written had N be sufficiently
-     large, _not counting_ the terminating null character, or a
-     negative value if an error occurred.
-
- -- Function: int mpfr_asprintf (char **STR, const char *TEMPLATE, ...)
- -- Function: int mpfr_vasprintf (char **STR, const char *TEMPLATE,
-          va_list AP)
-     Write their output as a null terminated string in a block of
-     memory allocated using the current allocation function. A pointer
-     to the block is stored in STR. The block of memory must be freed
-     using `mpfr_free_str'.  The return value is the number of
-     characters written in the string, excluding the null-terminator,
-     or a negative value if an error occurred.
-
-
-File: mpfr.info,  Node: Integer Related Functions,  Next: Rounding Related Functions,  Prev: Formatted Output Functions,  Up: MPFR Interface
-
-5.10 Integer and Remainder Related Functions
-============================================
-
- -- Function: int mpfr_rint (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_ceil (mpfr_t ROP, mpfr_t OP)
- -- Function: int mpfr_floor (mpfr_t ROP, mpfr_t OP)
- -- Function: int mpfr_round (mpfr_t ROP, mpfr_t OP)
- -- Function: int mpfr_trunc (mpfr_t ROP, mpfr_t OP)
-     Set ROP to OP rounded to an integer.  `mpfr_rint' rounds to the
-     nearest representable integer in the given direction RND,
-     `mpfr_ceil' rounds to the next higher or equal representable
-     integer, `mpfr_floor' to the next lower or equal representable
-     integer, `mpfr_round' to the nearest representable integer,
-     rounding halfway cases away from zero (as in the roundTiesToAway
-     mode of IEEE 754-2008), and `mpfr_trunc' to the next representable
-     integer toward zero.
-
-     The returned value is zero when the result is exact, positive when
-     it is greater than the original value of OP, and negative when it
-     is smaller.  More precisely, the returned value is 0 when OP is an
-     integer representable in ROP, 1 or -1 when OP is an integer that
-     is not representable in ROP, 2 or -2 when OP is not an integer.
-
-     Note that `mpfr_round' is different from `mpfr_rint' called with
-     the rounding to nearest mode (where halfway cases are rounded to
-     an even integer or significand). Note also that no double rounding
-     is performed; for instance, 10.5 (1010.1 in binary) is rounded by
-     `mpfr_rint' with rounding to nearest to 12 (1100 in binary) in
-     2-bit precision, because the two enclosing numbers representable
-     on two bits are 8 and 12, and the closest is 12.  (If one first
-     rounded to an integer, one would round 10.5 to 10 with even
-     rounding, and then 10 would be rounded to 8 again with even
-     rounding.)
-
- -- Function: int mpfr_rint_ceil (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
- -- Function: int mpfr_rint_floor (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t
-          RND)
- -- Function: int mpfr_rint_round (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t
-          RND)
- -- Function: int mpfr_rint_trunc (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t
-          RND)
-     Set ROP to OP rounded to an integer.  `mpfr_rint_ceil' rounds to
-     the next higher or equal integer, `mpfr_rint_floor' to the next
-     lower or equal integer, `mpfr_rint_round' to the nearest integer,
-     rounding halfway cases away from zero, and `mpfr_rint_trunc' to
-     the next integer toward zero.  If the result is not representable,
-     it is rounded in the direction RND.  The returned value is the
-     ternary value associated with the considered round-to-integer
-     function (regarded in the same way as any other mathematical
-     function).  Contrary to `mpfr_rint', those functions do perform a
-     double rounding: first OP is rounded to the nearest integer in the
-     direction given by the function name, then this nearest integer
-     (if not representable) is rounded in the given direction RND.  For
-     example, `mpfr_rint_round' with rounding to nearest and a precision
-     of two bits rounds 6.5 to 7 (halfway cases away from zero), then 7
-     is rounded to 8 by the round-even rule, despite the fact that 6 is
-     also representable on two bits, and is closer to 6.5 than 8.
-
- -- Function: int mpfr_frac (mpfr_t ROP, mpfr_t OP, mpfr_rnd_t RND)
-     Set ROP to the fractional part of OP, having the same sign as OP,
-     rounded in the direction RND (unlike in `mpfr_rint', RND affects
-     only how the exact fractional part is rounded, not how the
-     fractional part is generated).
-
- -- Function: int mpfr_modf (mpfr_t IOP, mpfr_t FOP, mpfr_t OP,
-          mpfr_rnd_t RND)
-     Set simultaneously IOP to the integral part of OP and FOP to the
-     fractional part of OP, rounded in the direction RND with the
-     corresponding precision of IOP and FOP (equivalent to
-     `mpfr_trunc(IOP, OP, RND)' and `mpfr_frac(FOP, OP, RND)'). The
-     variables IOP and FOP must be different. Return 0 iff both results
-     are exact (see `mpfr_sin_cos' for a more detailed description of
-     the return value).
-
- -- Function: int mpfr_fmod (mpfr_t R, mpfr_t X, mpfr_t Y, mpfr_rnd_t
-          RND)
- -- Function: int mpfr_remainder (mpfr_t R, mpfr_t X, mpfr_t Y,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_remquo (mpfr_t R, long* Q, mpfr_t X, mpfr_t Y,
-          mpfr_rnd_t RND)
-     Set R to the value of X - NY, rounded according to the direction
-     RND, where N is the integer quotient of X divided by Y, defined as
-     follows: N is rounded toward zero for `mpfr_fmod', and to the
-     nearest integer (ties rounded to even) for `mpfr_remainder' and
-     `mpfr_remquo'.
-
-     Special values are handled as described in Section F.9.7.1 of the
-     ISO C99 standard: If X is infinite or Y is zero, R is NaN.  If Y
-     is infinite and X is finite, R is X rounded to the precision of R.
-     If R is zero, it has the sign of X.  The return value is the
-     ternary value corresponding to R.
-
-     Additionally, `mpfr_remquo' stores the low significant bits from
-     the quotient N in *Q (more precisely the number of bits in a
-     `long' minus one), with the sign of X divided by Y (except if
-     those low bits are all zero, in which case zero is returned).
-     Note that X may be so large in magnitude relative to Y that an
-     exact representation of the quotient is not practical.  The
-     `mpfr_remainder' and `mpfr_remquo' functions are useful for
-     additive argument reduction.
-
- -- Function: int mpfr_integer_p (mpfr_t OP)
-     Return non-zero iff OP is an integer.
-
-
-File: mpfr.info,  Node: Rounding Related Functions,  Next: Miscellaneous Functions,  Prev: Integer Related Functions,  Up: MPFR Interface
-
-5.11 Rounding Related Functions
-===============================
-
- -- Function: void mpfr_set_default_rounding_mode (mpfr_rnd_t RND)
-     Set the default rounding mode to RND.  The default rounding mode
-     is to nearest initially.
-
- -- Function: mpfr_rnd_t mpfr_get_default_rounding_mode (void)
-     Get the default rounding mode.
-
- -- Function: int mpfr_prec_round (mpfr_t X, mpfr_prec_t PREC,
-          mpfr_rnd_t RND)
-     Round X according to RND with precision PREC, which must be an
-     integer between `MPFR_PREC_MIN' and `MPFR_PREC_MAX' (otherwise the
-     behavior is undefined).  If PREC is greater or equal to the
-     precision of X, then new space is allocated for the significand,
-     and it is filled with zeros.  Otherwise, the significand is
-     rounded to precision PREC with the given direction. In both cases,
-     the precision of X is changed to PREC.
-
-     Here is an example of how to use `mpfr_prec_round' to implement
-     Newton's algorithm to compute the inverse of A, assuming X is
-     already an approximation to N bits:
-            mpfr_set_prec (t, 2 * n);
-            mpfr_set (t, a, MPFR_RNDN);         /* round a to 2n bits */
-            mpfr_mul (t, t, x, MPFR_RNDN);      /* t is correct to 2n bits */
-            mpfr_ui_sub (t, 1, t, MPFR_RNDN);   /* high n bits cancel with 1 */
-            mpfr_prec_round (t, n, MPFR_RNDN);  /* t is correct to n bits */
-            mpfr_mul (t, t, x, MPFR_RNDN);      /* t is correct to n bits */
-            mpfr_prec_round (x, 2 * n, MPFR_RNDN); /* exact */
-            mpfr_add (x, x, t, MPFR_RNDN);      /* x is correct to 2n bits */
-
- -- Function: int mpfr_can_round (mpfr_t B, mpfr_exp_t ERR, mpfr_rnd_t
-          RND1, mpfr_rnd_t RND2, mpfr_prec_t PREC)
-     Assuming B is an approximation of an unknown number X in the
-     direction RND1 with error at most two to the power E(b)-ERR where
-     E(b) is the exponent of B, return a non-zero value if one is able
-     to round correctly X to precision PREC with the direction RND2,
-     and 0 otherwise (including for NaN and Inf).  This function *does
-     not modify* its arguments.
-
-     If RND1 is `MPFR_RNDN', then the sign of the error is unknown, but
-     its absolute value is the same, so that the possible range is
-     twice as large as with a directed rounding for RND1.
-
-     Note: if one wants to also determine the correct *note ternary
-     value:: when rounding B to precision PREC with rounding mode RND,
-     a useful trick is the following: if (mpfr_can_round (b, err, MPFR_RNDN, MPFR_RNDZ, prec + (rnd == MPFR_RNDN)))
-        ...
-      Indeed, if RND is `MPFR_RNDN', this will check if one can round
-     to PREC+1 bits with a directed rounding: if so, one can surely
-     round to nearest to PREC bits, and in addition one can determine
-     the correct ternary value, which would not be the case when B is
-     near from a value exactly representable on PREC bits.
-
- -- Function: mpfr_prec_t mpfr_min_prec (mpfr_t X)
-     Return the minimal number of bits required to store the
-     significand of X, and 0 for special values, including 0. (Warning:
-     the returned value can be less than `MPFR_PREC_MIN'.)
-
-     The function name is subject to change.
-
- -- Function: const char * mpfr_print_rnd_mode (mpfr_rnd_t RND)
-     Return a string ("MPFR_RNDD", "MPFR_RNDU", "MPFR_RNDN",
-     "MPFR_RNDZ", "MPFR_RNDA") corresponding to the rounding mode RND,
-     or a null pointer if RND is an invalid rounding mode.
-
-
-File: mpfr.info,  Node: Miscellaneous Functions,  Next: Exception Related Functions,  Prev: Rounding Related Functions,  Up: MPFR Interface
-
-5.12 Miscellaneous Functions
-============================
-
- -- Function: void mpfr_nexttoward (mpfr_t X, mpfr_t Y)
-     If X or Y is NaN, set X to NaN. If X and Y are equal, X is
-     unchanged. Otherwise, if X is different from Y, replace X by the
-     next floating-point number (with the precision of X and the
-     current exponent range) in the direction of Y (the infinite values
-     are seen as the smallest and largest floating-point numbers). If
-     the result is zero, it keeps the same sign. No underflow or
-     overflow is generated.
-
- -- Function: void mpfr_nextabove (mpfr_t X)
- -- Function: void mpfr_nextbelow (mpfr_t X)
-     Equivalent to `mpfr_nexttoward' where Y is plus infinity (resp.
-     minus infinity).
-
- -- Function: int mpfr_min (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
- -- Function: int mpfr_max (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
-     Set ROP to the minimum (resp. maximum) of OP1 and OP2. If OP1 and
-     OP2 are both NaN, then ROP is set to NaN. If OP1 or OP2 is NaN,
-     then ROP is set to the numeric value. If OP1 and OP2 are zeros of
-     different signs, then ROP is set to -0 (resp. +0).
-
- -- Function: int mpfr_urandomb (mpfr_t ROP, gmp_randstate_t STATE)
-     Generate a uniformly distributed random float in the interval 0 <=
-     ROP < 1. More precisely, the number can be seen as a float with a
-     random non-normalized significand and exponent 0, which is then
-     normalized (thus if E denotes the exponent after normalization,
-     then the least -E significant bits of the significand are always
-     0).
-
-     Return 0, unless the exponent is not in the current exponent
-     range, in which case ROP is set to NaN and a non-zero value is
-     returned (this should never happen in practice, except in very
-     specific cases). The second argument is a `gmp_randstate_t'
-     structure which should be created using the GMP `gmp_randinit'
-     function (see the GMP manual).
-
-     Note: for a given version of MPFR, the returned value of ROP and
-     the new value of STATE (which controls further random values) do
-     not depend on the machine word size.
-
- -- Function: int mpfr_urandom (mpfr_t ROP, gmp_randstate_t STATE,
-          mpfr_rnd_t RND)
-     Generate a uniformly distributed random float.  The floating-point
-     number ROP can be seen as if a random real number is generated
-     according to the continuous uniform distribution on the interval
-     [0, 1] and then rounded in the direction RND.
-
-     The second argument is a `gmp_randstate_t' structure which should
-     be created using the GMP `gmp_randinit' function (see the GMP
-     manual).
-
-     Note: the note for `mpfr_urandomb' holds too. In addition, the
-     exponent range and the rounding mode might have a side effect on
-     the next random state.
-
- -- Function: int mpfr_grandom (mpfr_t ROP1, mpfr_t ROP2,
-          gmp_randstate_t STATE, mpfr_rnd_t RND)
-     Generate two random floats according to a standard normal gaussian
-     distribution. If ROP2 is a null pointer, then only one value is
-     generated and stored in ROP1.
-
-     The floating-point number ROP1 (and ROP2) can be seen as if a
-     random real number were generated according to the standard normal
-     gaussian distribution and then rounded in the direction RND.
-
-     The third argument is a `gmp_randstate_t' structure, which should
-     be created using the GMP `gmp_randinit' function (see the GMP
-     manual).
-
-     Note: the note for `mpfr_urandomb' holds too. In addition, the
-     exponent range and the rounding mode might have a side effect on
-     the next random state.
-
- -- Function: mpfr_exp_t mpfr_get_exp (mpfr_t X)
-     Return the exponent of X, assuming that X is a non-zero ordinary
-     number and the significand is considered in [1/2,1). The behavior
-     for NaN, infinity or zero is undefined.
-
- -- Function: int mpfr_set_exp (mpfr_t X, mpfr_exp_t E)
-     Set the exponent of X if E is in the current exponent range, and
-     return 0 (even if X is not a non-zero ordinary number); otherwise,
-     return a non-zero value.  The significand is assumed to be in
-     [1/2,1).
-
- -- Function: int mpfr_signbit (mpfr_t OP)
-     Return a non-zero value iff OP has its sign bit set (i.e., if it is
-     negative, -0, or a NaN whose representation has its sign bit set).
-
- -- Function: int mpfr_setsign (mpfr_t ROP, mpfr_t OP, int S,
-          mpfr_rnd_t RND)
-     Set the value of ROP from OP, rounded toward the given direction
-     RND, then set (resp. clear) its sign bit if S is non-zero (resp.
-     zero), even when OP is a NaN.
-
- -- Function: int mpfr_copysign (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
-     Set the value of ROP from OP1, rounded toward the given direction
-     RND, then set its sign bit to that of OP2 (even when OP1 or OP2 is
-     a NaN). This function is equivalent to `mpfr_setsign (ROP, OP1,
-     mpfr_signbit (OP2), RND)'.
-
- -- Function: const char * mpfr_get_version (void)
-     Return the MPFR version, as a null-terminated string.
-
- -- Macro: MPFR_VERSION
- -- Macro: MPFR_VERSION_MAJOR
- -- Macro: MPFR_VERSION_MINOR
- -- Macro: MPFR_VERSION_PATCHLEVEL
- -- Macro: MPFR_VERSION_STRING
-     `MPFR_VERSION' is the version of MPFR as a preprocessing constant.
-     `MPFR_VERSION_MAJOR', `MPFR_VERSION_MINOR' and
-     `MPFR_VERSION_PATCHLEVEL' are respectively the major, minor and
-     patch level of MPFR version, as preprocessing constants.
-     `MPFR_VERSION_STRING' is the version (with an optional suffix, used
-     in development and pre-release versions) as a string constant,
-     which can be compared to the result of `mpfr_get_version' to check
-     at run time the header file and library used match:
-          if (strcmp (mpfr_get_version (), MPFR_VERSION_STRING))
-            fprintf (stderr, "Warning: header and library do not match\n");
-     Note: Obtaining different strings is not necessarily an error, as
-     in general, a program compiled with some old MPFR version can be
-     dynamically linked with a newer MPFR library version (if allowed
-     by the library versioning system).
-
- -- Macro: long MPFR_VERSION_NUM (MAJOR, MINOR, PATCHLEVEL)
-     Create an integer in the same format as used by `MPFR_VERSION'
-     from the given MAJOR, MINOR and PATCHLEVEL.  Here is an example of
-     how to check the MPFR version at compile time:
-          #if (!defined(MPFR_VERSION) || (MPFR_VERSION<MPFR_VERSION_NUM(3,0,0)))
-          # error "Wrong MPFR version."
-          #endif
-
- -- Function: const char * mpfr_get_patches (void)
-     Return a null-terminated string containing the ids of the patches
-     applied to the MPFR library (contents of the `PATCHES' file),
-     separated by spaces.  Note: If the program has been compiled with
-     an older MPFR version and is dynamically linked with a new MPFR
-     library version, the identifiers of the patches applied to the old
-     (compile-time) MPFR version are not available (however this
-     information should not have much interest in general).
-
- -- Function: int mpfr_buildopt_tls_p (void)
-     Return a non-zero value if MPFR was compiled as thread safe using
-     compiler-level Thread Local Storage (that is, MPFR was built with
-     the `--enable-thread-safe' configure option, see `INSTALL' file),
-     return zero otherwise.
-
- -- Function: int mpfr_buildopt_decimal_p (void)
-     Return a non-zero value if MPFR was compiled with decimal float
-     support (that is, MPFR was built with the `--enable-decimal-float'
-     configure option), return zero otherwise.
-
- -- Function: int mpfr_buildopt_gmpinternals_p (void)
-     Return a non-zero value if MPFR was compiled with GMP internals
-     (that is, MPFR was built with either `--with-gmp-build' or
-     `--enable-gmp-internals' configure option), return zero otherwise.
-
- -- Function: const char * mpfr_buildopt_tune_case (void)
-     Return a string saying which thresholds file has been used at
-     compile time.  This file is normally selected from the processor
-     type.
-
-
-File: mpfr.info,  Node: Exception Related Functions,  Next: Compatibility with MPF,  Prev: Miscellaneous Functions,  Up: MPFR Interface
-
-5.13 Exception Related Functions
-================================
-
- -- Function: mpfr_exp_t mpfr_get_emin (void)
- -- Function: mpfr_exp_t mpfr_get_emax (void)
-     Return the (current) smallest and largest exponents allowed for a
-     floating-point variable. The smallest positive value of a
-     floating-point variable is one half times 2 raised to the smallest
-     exponent and the largest value has the form (1 - epsilon) times 2
-     raised to the largest exponent, where epsilon depends on the
-     precision of the considered variable.
-
- -- Function: int mpfr_set_emin (mpfr_exp_t EXP)
- -- Function: int mpfr_set_emax (mpfr_exp_t EXP)
-     Set the smallest and largest exponents allowed for a
-     floating-point variable.  Return a non-zero value when EXP is not
-     in the range accepted by the implementation (in that case the
-     smallest or largest exponent is not changed), and zero otherwise.
-     If the user changes the exponent range, it is her/his
-     responsibility to check that all current floating-point variables
-     are in the new allowed range (for example using
-     `mpfr_check_range'), otherwise the subsequent behavior will be
-     undefined, in the sense of the ISO C standard.
-
- -- Function: mpfr_exp_t mpfr_get_emin_min (void)
- -- Function: mpfr_exp_t mpfr_get_emin_max (void)
- -- Function: mpfr_exp_t mpfr_get_emax_min (void)
- -- Function: mpfr_exp_t mpfr_get_emax_max (void)
-     Return the minimum and maximum of the exponents allowed for
-     `mpfr_set_emin' and `mpfr_set_emax' respectively.  These values
-     are implementation dependent, thus a program using
-     `mpfr_set_emax(mpfr_get_emax_max())' or
-     `mpfr_set_emin(mpfr_get_emin_min())' may not be portable.
-
- -- Function: int mpfr_check_range (mpfr_t X, int T, mpfr_rnd_t RND)
-     This function assumes that X is the correctly-rounded value of some
-     real value Y in the direction RND and some extended exponent
-     range, and that T is the corresponding *note ternary value::.  For
-     example, one performed `t = mpfr_log (x, u, rnd)', and Y is the
-     exact logarithm of U.  Thus T is negative if X is smaller than Y,
-     positive if X is larger than Y, and zero if X equals Y.  This
-     function modifies X if needed to be in the current range of
-     acceptable values: It generates an underflow or an overflow if the
-     exponent of X is outside the current allowed range; the value of T
-     may be used to avoid a double rounding. This function returns zero
-     if the new value of X equals the exact one Y, a positive value if
-     that new value is larger than Y, and a negative value if it is
-     smaller than Y.  Note that unlike most functions, the new result X
-     is compared to the (unknown) exact one Y, not the input value X,
-     i.e., the ternary value is propagated.
-
-     Note: If X is an infinity and T is different from zero (i.e., if
-     the rounded result is an inexact infinity), then the overflow flag
-     is set. This is useful because `mpfr_check_range' is typically
-     called (at least in MPFR functions) after restoring the flags that
-     could have been set due to internal computations.
-
- -- Function: int mpfr_subnormalize (mpfr_t X, int T, mpfr_rnd_t RND)
-     This function rounds X emulating subnormal number arithmetic: if X
-     is outside the subnormal exponent range, it just propagates the
-     *note ternary value:: T; otherwise, it rounds X to precision
-     `EXP(x)-emin+1' according to rounding mode RND and previous
-     ternary value T, avoiding double rounding problems.  More
-     precisely in the subnormal domain, denoting by E the value of
-     `emin', X is rounded in fixed-point arithmetic to an integer
-     multiple of two to the power E-1; as a consequence, 1.5 multiplied
-     by two to the power E-1 when T is zero is rounded to two to the
-     power E with rounding to nearest.
-
-     `PREC(x)' is not modified by this function.  RND and T must be the
-     rounding mode and the returned ternary value used when computing X
-     (as in `mpfr_check_range').  The subnormal exponent range is from
-     `emin' to `emin+PREC(x)-1'.  If the result cannot be represented
-     in the current exponent range (due to a too small `emax'), the
-     behavior is undefined.  Note that unlike most functions, the
-     result is compared to the exact one, not the input value X, i.e.,
-     the ternary value is propagated.
-
-     As usual, if the returned ternary value is non zero, the inexact
-     flag is set.  Moreover, if a second rounding occurred (because the
-     input X was in the subnormal range), the underflow flag is set.
-
-   This is an example of how to emulate binary double IEEE 754
-arithmetic (binary64 in IEEE 754-2008) using MPFR:
-
-     {
-       mpfr_t xa, xb; int i; volatile double a, b;
-
-       mpfr_set_default_prec (53);
-       mpfr_set_emin (-1073); mpfr_set_emax (1024);
-
-       mpfr_init (xa); mpfr_init (xb);
-
-       b = 34.3; mpfr_set_d (xb, b, MPFR_RNDN);
-       a = 0x1.1235P-1021; mpfr_set_d (xa, a, MPFR_RNDN);
-
-       a /= b;
-       i = mpfr_div (xa, xa, xb, MPFR_RNDN);
-       i = mpfr_subnormalize (xa, i, MPFR_RNDN); /* new ternary value */
-
-       mpfr_clear (xa); mpfr_clear (xb);
-     }
-
-   Warning: this emulates a double IEEE 754 arithmetic with correct
-rounding in the subnormal range, which may not be the case for your
-hardware.
-
- -- Function: void mpfr_clear_underflow (void)
- -- Function: void mpfr_clear_overflow (void)
- -- Function: void mpfr_clear_divby0 (void)
- -- Function: void mpfr_clear_nanflag (void)
- -- Function: void mpfr_clear_inexflag (void)
- -- Function: void mpfr_clear_erangeflag (void)
-     Clear the underflow, overflow, divide-by-zero, invalid, inexact
-     and _erange_ flags.
-
- -- Function: void mpfr_set_underflow (void)
- -- Function: void mpfr_set_overflow (void)
- -- Function: void mpfr_set_divby0 (void)
- -- Function: void mpfr_set_nanflag (void)
- -- Function: void mpfr_set_inexflag (void)
- -- Function: void mpfr_set_erangeflag (void)
-     Set the underflow, overflow, divide-by-zero, invalid, inexact and
-     _erange_ flags.
-
- -- Function: void mpfr_clear_flags (void)
-     Clear all global flags (underflow, overflow, divide-by-zero,
-     invalid, inexact, _erange_).
-
- -- Function: int mpfr_underflow_p (void)
- -- Function: int mpfr_overflow_p (void)
- -- Function: int mpfr_divby0_p (void)
- -- Function: int mpfr_nanflag_p (void)
- -- Function: int mpfr_inexflag_p (void)
- -- Function: int mpfr_erangeflag_p (void)
-     Return the corresponding (underflow, overflow, divide-by-zero,
-     invalid, inexact, _erange_) flag, which is non-zero iff the flag
-     is set.
-
-
-File: mpfr.info,  Node: Compatibility with MPF,  Next: Custom Interface,  Prev: Exception Related Functions,  Up: MPFR Interface
-
-5.14 Compatibility With MPF
-===========================
-
-A header file `mpf2mpfr.h' is included in the distribution of MPFR for
-compatibility with the GNU MP class MPF.  By inserting the following
-two lines after the `#include <gmp.h>' line,
-#include <mpfr.h>
-#include <mpf2mpfr.h>
- any program written for MPF can be compiled directly with MPFR without
-any changes (except the `gmp_printf' functions will not work for
-arguments of type `mpfr_t').  All operations are then performed with
-the default MPFR rounding mode, which can be reset with
-`mpfr_set_default_rounding_mode'.
-
-   Warning: the `mpf_init' and `mpf_init2' functions initialize to
-zero, whereas the corresponding MPFR functions initialize to NaN: this
-is useful to detect uninitialized values, but is slightly incompatible
-with MPF.
-
- -- Function: void mpfr_set_prec_raw (mpfr_t X, mpfr_prec_t PREC)
-     Reset the precision of X to be *exactly* PREC bits.  The only
-     difference with `mpfr_set_prec' is that PREC is assumed to be
-     small enough so that the significand fits into the current
-     allocated memory space for X. Otherwise the behavior is undefined.
-
- -- Function: int mpfr_eq (mpfr_t OP1, mpfr_t OP2, unsigned long int
-          OP3)
-     Return non-zero if OP1 and OP2 are both non-zero ordinary numbers
-     with the same exponent and the same first OP3 bits, both zero, or
-     both infinities of the same sign. Return zero otherwise.  This
-     function is defined for compatibility with MPF, we do not recommend
-     to use it otherwise.  Do not use it either if you want to know
-     whether two numbers are close to each other; for instance,
-     1.011111 and 1.100000 are regarded as different for any value of
-     OP3 larger than 1.
-
- -- Function: void mpfr_reldiff (mpfr_t ROP, mpfr_t OP1, mpfr_t OP2,
-          mpfr_rnd_t RND)
-     Compute the relative difference between OP1 and OP2 and store the
-     result in ROP.  This function does not guarantee the correct
-     rounding on the relative difference; it just computes
-     |OP1-OP2|/OP1, using the precision of ROP and the rounding mode
-     RND for all operations.
-
- -- Function: int mpfr_mul_2exp (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
- -- Function: int mpfr_div_2exp (mpfr_t ROP, mpfr_t OP1, unsigned long
-          int OP2, mpfr_rnd_t RND)
-     These functions are identical to `mpfr_mul_2ui' and `mpfr_div_2ui'
-     respectively.  These functions are only kept for compatibility
-     with MPF, one should prefer `mpfr_mul_2ui' and `mpfr_div_2ui'
-     otherwise.
-
-
-File: mpfr.info,  Node: Custom Interface,  Next: Internals,  Prev: Compatibility with MPF,  Up: MPFR Interface
-
-5.15 Custom Interface
-=====================
-
-Some applications use a stack to handle the memory and their objects.
-However, the MPFR memory design is not well suited for such a thing. So
-that such applications are able to use MPFR, an auxiliary memory
-interface has been created: the Custom Interface.
-
-   The following interface allows one to use MPFR in two ways:
-   * Either directly store a floating-point number as a `mpfr_t' on the
-     stack.
-
-   * Either store its own representation on the stack and construct a
-     new temporary `mpfr_t' each time it is needed.
-   Nothing has to be done to destroy the floating-point numbers except
-garbaging the used memory: all the memory management (allocating,
-destroying, garbaging) is left to the application.
-
-   Each function in this interface is also implemented as a macro for
-efficiency reasons: for example `mpfr_custom_init (s, p)' uses the
-macro, while `(mpfr_custom_init) (s, p)' uses the function.
-
-   Note 1: MPFR functions may still initialize temporary floating-point
-numbers using `mpfr_init' and similar functions. See Custom Allocation
-(GNU MP).
-
-   Note 2: MPFR functions may use the cached functions (`mpfr_const_pi'
-for example), even if they are not explicitly called. You have to call
-`mpfr_free_cache' each time you garbage the memory iff `mpfr_init',
-through GMP Custom Allocation, allocates its memory on the application
-stack.
-
- -- Function: size_t mpfr_custom_get_size (mpfr_prec_t PREC)
-     Return the needed size in bytes to store the significand of a
-     floating-point number of precision PREC.
-
- -- Function: void mpfr_custom_init (void *SIGNIFICAND, mpfr_prec_t
-          PREC)
-     Initialize a significand of precision PREC, where SIGNIFICAND must
-     be an area of `mpfr_custom_get_size (prec)' bytes at least and be
-     suitably aligned for an array of `mp_limb_t' (GMP type, *note
-     Internals::).
-
- -- Function: void mpfr_custom_init_set (mpfr_t X, int KIND, mpfr_exp_t
-          EXP, mpfr_prec_t PREC, void *SIGNIFICAND)
-     Perform a dummy initialization of a `mpfr_t' and set it to:
-        * if `ABS(kind) == MPFR_NAN_KIND', X is set to NaN;
-
-        * if `ABS(kind) == MPFR_INF_KIND', X is set to the infinity of
-          sign `sign(kind)';
-
-        * if `ABS(kind) == MPFR_ZERO_KIND', X is set to the zero of
-          sign `sign(kind)';
-
-        * if `ABS(kind) == MPFR_REGULAR_KIND', X is set to a regular
-          number: `x = sign(kind)*significand*2^exp'.
-     In all cases, it uses SIGNIFICAND directly for further computing
-     involving X. It will not allocate anything.  A floating-point
-     number initialized with this function cannot be resized using
-     `mpfr_set_prec' or `mpfr_prec_round', or cleared using
-     `mpfr_clear'!  The SIGNIFICAND must have been initialized with
-     `mpfr_custom_init' using the same precision PREC.
-
- -- Function: int mpfr_custom_get_kind (mpfr_t X)
-     Return the current kind of a `mpfr_t' as created by
-     `mpfr_custom_init_set'.  The behavior of this function for any
-     `mpfr_t' not initialized with `mpfr_custom_init_set' is undefined.
-
- -- Function: void * mpfr_custom_get_significand (mpfr_t X)
-     Return a pointer to the significand used by a `mpfr_t' initialized
-     with `mpfr_custom_init_set'.  The behavior of this function for
-     any `mpfr_t' not initialized with `mpfr_custom_init_set' is
-     undefined.
-
- -- Function: mpfr_exp_t mpfr_custom_get_exp (mpfr_t X)
-     Return the exponent of X, assuming that X is a non-zero ordinary
-     number. The return value for NaN, Infinity or zero is unspecified
-     but does not produce any trap.  The behavior of this function for
-     any `mpfr_t' not initialized with `mpfr_custom_init_set' is
-     undefined.
-
- -- Function: void mpfr_custom_move (mpfr_t X, void *NEW_POSITION)
-     Inform MPFR that the significand of X has moved due to a garbage
-     collect and update its new position to `new_position'.  However
-     the application has to move the significand and the `mpfr_t'
-     itself.  The behavior of this function for any `mpfr_t' not
-     initialized with `mpfr_custom_init_set' is undefined.
-
-
-File: mpfr.info,  Node: Internals,  Prev: Custom Interface,  Up: MPFR Interface
-
-5.16 Internals
-==============
-
-A "limb" means the part of a multi-precision number that fits in a
-single word. Usually a limb contains 32 or 64 bits.  The C data type
-for a limb is `mp_limb_t'.
-
-   The `mpfr_t' type is internally defined as a one-element array of a
-structure, and `mpfr_ptr' is the C data type representing a pointer to
-this structure.  The `mpfr_t' type consists of four fields:
-
-   * The `_mpfr_prec' field is used to store the precision of the
-     variable (in bits); this is not less than `MPFR_PREC_MIN'.
-
-   * The `_mpfr_sign' field is used to store the sign of the variable.
-
-   * The `_mpfr_exp' field stores the exponent.  An exponent of 0 means
-     a radix point just above the most significant limb.  Non-zero
-     values n are a multiplier 2^n relative to that point.  A NaN, an
-     infinity and a zero are indicated by special values of the exponent
-     field.
-
-   * Finally, the `_mpfr_d' field is a pointer to the limbs, least
-     significant limbs stored first.  The number of limbs in use is
-     controlled by `_mpfr_prec', namely
-     ceil(`_mpfr_prec'/`mp_bits_per_limb').  Non-singular (i.e.,
-     different from NaN, Infinity or zero) values always have the most
-     significant bit of the most significant limb set to 1.  When the
-     precision does not correspond to a whole number of limbs, the
-     excess bits at the low end of the data are zeros.
-
-
-
-File: mpfr.info,  Node: API Compatibility,  Next: Contributors,  Prev: MPFR Interface,  Up: Top
-
-6 API Compatibility
-*******************
-
-The goal of this section is to describe some API changes that occurred
-from one version of MPFR to another, and how to write code that can be
-compiled and run with older MPFR versions.  The minimum MPFR version
-that is considered here is 2.2.0 (released on 20 September 2005).
-
-   API changes can only occur between major or minor versions.  Thus the
-patchlevel (the third number in the MPFR version) will be ignored in
-the following.  If a program does not use MPFR internals, changes in
-the behavior between two versions differing only by the patchlevel
-should only result from what was regarded as a bug or unspecified
-behavior.
-
-   As a general rule, a program written for some MPFR version should
-work with later versions, possibly except at a new major version, where
-some features (described as obsolete for some time) can be removed.  In
-such a case, a failure should occur during compilation or linking.  If
-a result becomes incorrect because of such a change, please look at the
-various changes below (they are minimal, and most software should be
-unaffected), at the FAQ and at the MPFR web page for your version (a
-bug could have been introduced and be already fixed); and if the
-problem is not mentioned, please send us a bug report (*note Reporting
-Bugs::).
-
-   However, a program written for the current MPFR version (as
-documented by this manual) may not necessarily work with previous
-versions of MPFR.  This section should help developers to write
-portable code.
-
-   Note: Information given here may be incomplete.  API changes are
-also described in the NEWS file (for each version, instead of being
-classified like here), together with other changes.
-
-* Menu:
-
-* Type and Macro Changes::
-* Added Functions::
-* Changed Functions::
-* Removed Functions::
-* Other Changes::
-
-
-File: mpfr.info,  Node: Type and Macro Changes,  Next: Added Functions,  Prev: API Compatibility,  Up: API Compatibility
-
-6.1 Type and Macro Changes
-==========================
-
-The official type for exponent values changed from `mp_exp_t' to
-`mpfr_exp_t' in MPFR 3.0.  The type `mp_exp_t' will remain available as
-it comes from GMP (with a different meaning).  These types are
-currently the same (`mpfr_exp_t' is defined as `mp_exp_t' with
-`typedef'), so that programs can still use `mp_exp_t'; but this may
-change in the future.  Alternatively, using the following code after
-including `mpfr.h' will work with official MPFR versions, as
-`mpfr_exp_t' was never defined in MPFR 2.x:
-     #if MPFR_VERSION_MAJOR < 3
-     typedef mp_exp_t mpfr_exp_t;
-     #endif
-
-   The official types for precision values and for rounding modes
-respectively changed from `mp_prec_t' and `mp_rnd_t' to `mpfr_prec_t'
-and `mpfr_rnd_t' in MPFR 3.0.  This change was actually done a long
-time ago in MPFR, at least since MPFR 2.2.0, with the following code in
-`mpfr.h':
-     #ifndef mp_rnd_t
-     # define mp_rnd_t  mpfr_rnd_t
-     #endif
-     #ifndef mp_prec_t
-     # define mp_prec_t mpfr_prec_t
-     #endif
-   This means that it is safe to use the new official types
-`mpfr_prec_t' and `mpfr_rnd_t' in your programs.  The types `mp_prec_t'
-and `mp_rnd_t' (defined in MPFR only) may be removed in the future, as
-the prefix `mp_' is reserved by GMP.
-
-   The precision type `mpfr_prec_t' (`mp_prec_t') was unsigned before
-MPFR 3.0; it is now signed.  `MPFR_PREC_MAX' has not changed, though.
-Indeed the MPFR code requires that `MPFR_PREC_MAX' be representable in
-the exponent type, which may have the same size as `mpfr_prec_t' but
-has always been signed.  The consequence is that valid code that does
-not assume anything about the signedness of `mpfr_prec_t' should work
-with past and new MPFR versions.  This change was useful as the use of
-unsigned types tends to convert signed values to unsigned ones in
-expressions due to the usual arithmetic conversions, which can yield
-incorrect results if a negative value is converted in such a way.
-Warning!  A program assuming (intentionally or not) that `mpfr_prec_t'
-is signed may be affected by this problem when it is built and run
-against MPFR 2.x.
-
-   The rounding modes `GMP_RNDx' were renamed to `MPFR_RNDx' in MPFR
-3.0. However the old names `GMP_RNDx' have been kept for compatibility
-(this might change in future versions), using:
-     #define GMP_RNDN MPFR_RNDN
-     #define GMP_RNDZ MPFR_RNDZ
-     #define GMP_RNDU MPFR_RNDU
-     #define GMP_RNDD MPFR_RNDD
-   The rounding mode "round away from zero" (`MPFR_RNDA') was added in
-MPFR 3.0 (however no rounding mode `GMP_RNDA' exists).
-
-
-File: mpfr.info,  Node: Added Functions,  Next: Changed Functions,  Prev: Type and Macro Changes,  Up: API Compatibility
-
-6.2 Added Functions
-===================
-
-We give here in alphabetical order the functions that were added after
-MPFR 2.2, and in which MPFR version.
-
-   * `mpfr_add_d' in MPFR 2.4.
-
-   * `mpfr_ai' in MPFR 3.0 (incomplete, experimental).
-
-   * `mpfr_asprintf' in MPFR 2.4.
-
-   * `mpfr_buildopt_decimal_p' and `mpfr_buildopt_tls_p' in MPFR 3.0.
-
-   * `mpfr_buildopt_gmpinternals_p' and `mpfr_buildopt_tune_case' in
-     MPFR 3.1.
-
-   * `mpfr_clear_divby0' in MPFR 3.1 (new divide-by-zero exception).
-
-   * `mpfr_copysign' in MPFR 2.3.  Note: MPFR 2.2 had a `mpfr_copysign'
-     function that was available, but not documented, and with a slight
-     difference in the semantics (when the second input operand is a
-     NaN).
-
-   * `mpfr_custom_get_significand' in MPFR 3.0.  This function was
-     named `mpfr_custom_get_mantissa' in previous versions;
-     `mpfr_custom_get_mantissa' is still available via a macro in
-     `mpfr.h':
-          #define mpfr_custom_get_mantissa mpfr_custom_get_significand
-     Thus code that needs to work with both MPFR 2.x and MPFR 3.x should
-     use `mpfr_custom_get_mantissa'.
-
-   * `mpfr_d_div' and `mpfr_d_sub' in MPFR 2.4.
-
-   * `mpfr_digamma' in MPFR 3.0.
-
-   * `mpfr_divby0_p' in MPFR 3.1 (new divide-by-zero exception).
-
-   * `mpfr_div_d' in MPFR 2.4.
-
-   * `mpfr_fmod' in MPFR 2.4.
-
-   * `mpfr_fms' in MPFR 2.3.
-
-   * `mpfr_fprintf' in MPFR 2.4.
-
-   * `mpfr_frexp' in MPFR 3.1.
-
-   * `mpfr_get_flt' in MPFR 3.0.
-
-   * `mpfr_get_patches' in MPFR 2.3.
-
-   * `mpfr_get_z_2exp' in MPFR 3.0.  This function was named
-     `mpfr_get_z_exp' in previous versions; `mpfr_get_z_exp' is still
-     available via a macro in `mpfr.h':
-          #define mpfr_get_z_exp mpfr_get_z_2exp
-     Thus code that needs to work with both MPFR 2.x and MPFR 3.x should
-     use `mpfr_get_z_exp'.
-
-   * `mpfr_grandom' in MPFR 3.1.
-
-   * `mpfr_j0', `mpfr_j1' and `mpfr_jn' in MPFR 2.3.
-
-   * `mpfr_lgamma' in MPFR 2.3.
-
-   * `mpfr_li2' in MPFR 2.4.
-
-   * `mpfr_min_prec' in MPFR 3.0.
-
-   * `mpfr_modf' in MPFR 2.4.
-
-   * `mpfr_mul_d' in MPFR 2.4.
-
-   * `mpfr_printf' in MPFR 2.4.
-
-   * `mpfr_rec_sqrt' in MPFR 2.4.
-
-   * `mpfr_regular_p' in MPFR 3.0.
-
-   * `mpfr_remainder' and `mpfr_remquo' in MPFR 2.3.
-
-   * `mpfr_set_divby0' in MPFR 3.1 (new divide-by-zero exception).
-
-   * `mpfr_set_flt' in MPFR 3.0.
-
-   * `mpfr_set_z_2exp' in MPFR 3.0.
-
-   * `mpfr_set_zero' in MPFR 3.0.
-
-   * `mpfr_setsign' in MPFR 2.3.
-
-   * `mpfr_signbit' in MPFR 2.3.
-
-   * `mpfr_sinh_cosh' in MPFR 2.4.
-
-   * `mpfr_snprintf' and `mpfr_sprintf' in MPFR 2.4.
-
-   * `mpfr_sub_d' in MPFR 2.4.
-
-   * `mpfr_urandom' in MPFR 3.0.
-
-   * `mpfr_vasprintf', `mpfr_vfprintf', `mpfr_vprintf',
-     `mpfr_vsprintf' and `mpfr_vsnprintf' in MPFR 2.4.
-
-   * `mpfr_y0', `mpfr_y1' and `mpfr_yn' in MPFR 2.3.
-
-   * `mpfr_z_sub' in MPFR 3.1.
-
-
-
-File: mpfr.info,  Node: Changed Functions,  Next: Removed Functions,  Prev: Added Functions,  Up: API Compatibility
-
-6.3 Changed Functions
-=====================
-
-The following functions have changed after MPFR 2.2. Changes can affect
-the behavior of code written for some MPFR version when built and run
-against another MPFR version (older or newer), as described below.
-
-   * `mpfr_check_range' changed in MPFR 2.3.2 and MPFR 2.4.  If the
-     value is an inexact infinity, the overflow flag is now set (in
-     case it was lost), while it was previously left unchanged.  This
-     is really what is expected in practice (and what the MPFR code was
-     expecting), so that the previous behavior was regarded as a bug.
-     Hence the change in MPFR 2.3.2.
-
-   * `mpfr_get_f' changed in MPFR 3.0.  This function was returning
-     zero, except for NaN and Inf, which do not exist in MPF. The
-     _erange_ flag is now set in these cases, and `mpfr_get_f' now
-     returns the usual ternary value.
-
-   * `mpfr_get_si', `mpfr_get_sj', `mpfr_get_ui' and `mpfr_get_uj'
-     changed in MPFR 3.0.  In previous MPFR versions, the cases where
-     the _erange_ flag is set were unspecified.
-
-   * `mpfr_get_z' changed in MPFR 3.0.  The return type was `void'; it
-     is now `int', and the usual ternary value is returned.  Thus
-     programs that need to work with both MPFR 2.x and 3.x must not use
-     the return value.  Even in this case, C code using `mpfr_get_z' as
-     the second or third term of a conditional operator may also be
-     affected. For instance, the following is correct with MPFR 3.0,
-     but not with MPFR 2.x:
-            bool ? mpfr_get_z(...) : mpfr_add(...);
-     On the other hand, the following is correct with MPFR 2.x, but not
-     with MPFR 3.0:
-            bool ? mpfr_get_z(...) : (void) mpfr_add(...);
-     Portable code should cast `mpfr_get_z(...)' to `void' to use the
-     type `void' for both terms of the conditional operator, as in:
-            bool ? (void) mpfr_get_z(...) : (void) mpfr_add(...);
-     Alternatively, `if ... else' can be used instead of the
-     conditional operator.
-
-     Moreover the cases where the _erange_ flag is set were unspecified
-     in MPFR 2.x.
-
-   * `mpfr_get_z_exp' changed in MPFR 3.0.  In previous MPFR versions,
-     the cases where the _erange_ flag is set were unspecified.  Note:
-     this function has been renamed to `mpfr_get_z_2exp' in MPFR 3.0,
-     but `mpfr_get_z_exp' is still available for compatibility reasons.
-
-   * `mpfr_strtofr' changed in MPFR 2.3.1 and MPFR 2.4.  This was
-     actually a bug fix since the code and the documentation did not
-     match.  But both were changed in order to have a more consistent
-     and useful behavior.  The main changes in the code are as follows.
-     The binary exponent is now accepted even without the `0b' or `0x'
-     prefix.  Data corresponding to NaN can now have an optional sign
-     (such data were previously invalid).
-
-   * `mpfr_strtofr' changed in MPFR 3.0.  This function now accepts
-     bases from 37 to 62 (no changes for the other bases).  Note: if an
-     unsupported base is provided to this function, the behavior is
-     undefined; more precisely, in MPFR 2.3.1 and later, providing an
-     unsupported base yields an assertion failure (this behavior may
-     change in the future).
-
-   * `mpfr_subnormalize' changed in MPFR 3.1.  This was actually
-     regarded as a bug fix. The `mpfr_subnormalize' implementation up
-     to MPFR 3.0.0 did not change the flags. In particular, it did not
-     follow the generic rule concerning the inexact flag (and no
-     special behavior was specified). The case of the underflow flag
-     was more a lack of specification.
-
-   * `mpfr_urandom' and `mpfr_urandomb' changed in MPFR 3.1.  Their
-     behavior no longer depends on the platform (assuming this is also
-     true for GMP's random generator).  As a consequence, the returned
-     values can be different between MPFR 3.1 and previous MPFR
-     versions.  Note: as the reproducibility of these functions was not
-     specified before MPFR 3.1, the MPFR 3.1 behavior is _not_ regarded
-     as backward incompatible with previous versions.
-
-
-
-File: mpfr.info,  Node: Removed Functions,  Next: Other Changes,  Prev: Changed Functions,  Up: API Compatibility
-
-6.4 Removed Functions
-=====================
-
-Functions `mpfr_random' and `mpfr_random2' have been removed in MPFR
-3.0 (this only affects old code built against MPFR 3.0 or later).  (The
-function `mpfr_random' had been deprecated since at least MPFR 2.2.0,
-and `mpfr_random2' since MPFR 2.4.0.)
-
-
-File: mpfr.info,  Node: Other Changes,  Prev: Removed Functions,  Up: API Compatibility
-
-6.5 Other Changes
-=================
-
-For users of a C++ compiler, the way how the availability of `intmax_t'
-is detected has changed in MPFR 3.0.  In MPFR 2.x, if a macro
-`INTMAX_C' or `UINTMAX_C' was defined (e.g. when the
-`__STDC_CONSTANT_MACROS' macro had been defined before `<stdint.h>' or
-`<inttypes.h>' has been included), `intmax_t' was assumed to be defined.
-However this was not always the case (more precisely, `intmax_t' can be
-defined only in the namespace `std', as with Boost), so that
-compilations could fail.  Thus the check for `INTMAX_C' or `UINTMAX_C'
-is now disabled for C++ compilers, with the following consequences:
-
-   * Programs written for MPFR 2.x that need `intmax_t' may no longer
-     be compiled against MPFR 3.0: a `#define MPFR_USE_INTMAX_T' may be
-     necessary before `mpfr.h' is included.
-
-   * The compilation of programs that work with MPFR 3.0 may fail with
-     MPFR 2.x due to the problem described above.  Workarounds are
-     possible, such as defining `intmax_t' and `uintmax_t' in the global
-     namespace, though this is not clean.
-
-
-   The divide-by-zero exception is new in MPFR 3.1. However it should
-not introduce incompatible changes for programs that strictly follow
-the MPFR API since the exception can only be seen via new functions.
-
-   As of MPFR 3.1, the `mpfr.h' header can be included several times,
-while still supporting optional functions (*note Headers and
-Libraries::).
-
-
-File: mpfr.info,  Node: Contributors,  Next: References,  Prev: API Compatibility,  Up: Top
-
-Contributors
-************
-
-The main developers of MPFR are Guillaume Hanrot, Vincent Lefvre,
-Patrick Plissier, Philippe Thveny and Paul Zimmermann.
-
-   Sylvie Boldo from ENS-Lyon, France, contributed the functions
-`mpfr_agm' and `mpfr_log'.  Sylvain Chevillard contributed the
-`mpfr_ai' function.  David Daney contributed the hyperbolic and inverse
-hyperbolic functions, the base-2 exponential, and the factorial
-function.  Alain Delplanque contributed the new version of the
-`mpfr_get_str' function.  Mathieu Dutour contributed the functions
-`mpfr_acos', `mpfr_asin' and `mpfr_atan', and a previous version of
-`mpfr_gamma'.  Laurent Fousse contributed the `mpfr_sum' function.
-Emmanuel Jeandel, from ENS-Lyon too, contributed the generic
-hypergeometric code, as well as the internal function `mpfr_exp3', a
-first implementation of the sine and cosine, and improved versions of
-`mpfr_const_log2' and `mpfr_const_pi'.  Ludovic Meunier helped in the
-design of the `mpfr_erf' code.  Jean-Luc Rmy contributed the
-`mpfr_zeta' code.  Fabrice Rouillier contributed the `mpfr_xxx_z' and
-`mpfr_xxx_q' functions, and helped to the Microsoft Windows porting.
-Damien Stehl contributed the `mpfr_get_ld_2exp' function.
-
-   We would like to thank Jean-Michel Muller and Joris van der Hoeven
-for very fruitful discussions at the beginning of that project,
-Torbjrn Granlund and Kevin Ryde for their help about design issues,
-and Nathalie Revol for her careful reading of a previous version of
-this documentation. In particular Kevin Ryde did a tremendous job for
-the portability of MPFR in 2002-2004.
-
-   The development of the MPFR library would not have been possible
-without the continuous support of INRIA, and of the LORIA (Nancy,
-France) and LIP (Lyon, France) laboratories. In particular the main
-authors were or are members of the PolKA, Spaces, Cacao and Caramel
-project-teams at LORIA and of the Arnaire project-team at LIP.  This
-project was started during the Fiable (reliable in French) action
-supported by INRIA, and continued during the AOC action.  The
-development of MPFR was also supported by a grant (202F0659 00 MPN 121)
-from the Conseil Rgional de Lorraine in 2002, from INRIA by an
-"associate engineer" grant (2003-2005), an "opration de dveloppement
-logiciel" grant (2007-2009), and the post-doctoral grant of Sylvain
-Chevillard in 2009-2010.
-
-
-File: mpfr.info,  Node: References,  Next: GNU Free Documentation License,  Prev: Contributors,  Up: Top
-
-References
-**********
-
-   * Richard Brent and Paul Zimmermann, "Modern Computer Arithmetic",
-     Cambridge University Press (to appear), also available from the
-     authors' web pages.
-
-   * Laurent Fousse, Guillaume Hanrot, Vincent Lefvre, Patrick
-     Plissier and Paul Zimmermann, "MPFR: A Multiple-Precision Binary
-     Floating-Point Library With Correct Rounding", ACM Transactions on
-     Mathematical Software, volume 33, issue 2, article 13, 15 pages,
-     2007, `http://doi.acm.org/10.1145/1236463.1236468'.
-
-   * Torbjrn Granlund, "GNU MP: The GNU Multiple Precision Arithmetic
-     Library",   version 5.0.1, 2010, `http://gmplib.org'.
-
-   * IEEE standard for binary floating-point arithmetic, Technical
-     Report ANSI-IEEE Standard 754-1985, New York, 1985.  Approved
-     March 21, 1985: IEEE Standards Board; approved July 26,   1985:
-     American National Standards Institute, 18 pages.
-
-   * IEEE Standard for Floating-Point Arithmetic, ANSI-IEEE Standard
-     754-2008, 2008.  Revision of ANSI-IEEE Standard 754-1985, approved
-     June 12, 2008: IEEE Standards Board, 70 pages.
-
-   * Donald E. Knuth, "The Art of Computer Programming", vol 2,
-     "Seminumerical Algorithms", 2nd edition, Addison-Wesley, 1981.
-
-   * Jean-Michel Muller, "Elementary Functions, Algorithms and
-     Implementation", Birkhuser, Boston, 2nd edition, 2006.
-
-   * Jean-Michel Muller, Nicolas Brisebarre, Florent de Dinechin,
-     Claude-Pierre Jeannerod, Vincent Lefvre, Guillaume Melquiond,
-     Nathalie Revol, Damien Stehl and Serge Torrs, "Handbook of
-     Floating-Point Arithmetic", Birkhuser, Boston, 2009.
-
-
-
-File: mpfr.info,  Node: GNU Free Documentation License,  Next: Concept Index,  Prev: References,  Up: Top
-
-Appendix A GNU Free Documentation License
-*****************************************
-
-                      Version 1.2, November 2002
-
-     Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
-     51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA
-
-     Everyone is permitted to copy and distribute verbatim copies
-     of this license document, but changing it is not allowed.
-
-  0. PREAMBLE
-
-     The purpose of this License is to make a manual, textbook, or other
-     functional and useful document "free" in the sense of freedom: to
-     assure everyone the effective freedom to copy and redistribute it,
-     with or without modifying it, either commercially or
-     noncommercially.  Secondarily, this License preserves for the
-     author and publisher a way to get credit for their work, while not
-     being considered responsible for modifications made by others.
-
-     This License is a kind of "copyleft", which means that derivative
-     works of the document must themselves be free in the same sense.
-     It complements the GNU General Public License, which is a copyleft
-     license designed for free software.
-
-     We have designed this License in order to use it for manuals for
-     free software, because free software needs free documentation: a
-     free program should come with manuals providing the same freedoms
-     that the software does.  But this License is not limited to
-     software manuals; it can be used for any textual work, regardless
-     of subject matter or whether it is published as a printed book.
-     We recommend this License principally for works whose purpose is
-     instruction or reference.
-
-  1. APPLICABILITY AND DEFINITIONS
-
-     This License applies to any manual or other work, in any medium,
-     that contains a notice placed by the copyright holder saying it
-     can be distributed under the terms of this License.  Such a notice
-     grants a world-wide, royalty-free license, unlimited in duration,
-     to use that work under the conditions stated herein.  The
-     "Document", below, refers to any such manual or work.  Any member
-     of the public is a licensee, and is addressed as "you".  You
-     accept the license if you copy, modify or distribute the work in a
-     way requiring permission under copyright law.
-
-     A "Modified Version" of the Document means any work containing the
-     Document or a portion of it, either copied verbatim, or with
-     modifications and/or translated into another language.
-
-     A "Secondary Section" is a named appendix or a front-matter section
-     of the Document that deals exclusively with the relationship of the
-     publishers or authors of the Document to the Document's overall
-     subject (or to related matters) and contains nothing that could
-     fall directly within that overall subject.  (Thus, if the Document
-     is in part a textbook of mathematics, a Secondary Section may not
-     explain any mathematics.)  The relationship could be a matter of
-     historical connection with the subject or with related matters, or
-     of legal, commercial, philosophical, ethical or political position
-     regarding them.
-
-     The "Invariant Sections" are certain Secondary Sections whose
-     titles are designated, as being those of Invariant Sections, in
-     the notice that says that the Document is released under this
-     License.  If a section does not fit the above definition of
-     Secondary then it is not allowed to be designated as Invariant.
-     The Document may contain zero Invariant Sections.  If the Document
-     does not identify any Invariant Sections then there are none.
-
-     The "Cover Texts" are certain short passages of text that are
-     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
-     that says that the Document is released under this License.  A
-     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
-     be at most 25 words.
-
-     A "Transparent" copy of the Document means a machine-readable copy,
-     represented in a format whose specification is available to the
-     general public, that is suitable for revising the document
-     straightforwardly with generic text editors or (for images
-     composed of pixels) generic paint programs or (for drawings) some
-     widely available drawing editor, and that is suitable for input to
-     text formatters or for automatic translation to a variety of
-     formats suitable for input to text formatters.  A copy made in an
-     otherwise Transparent file format whose markup, or absence of
-     markup, has been arranged to thwart or discourage subsequent
-     modification by readers is not Transparent.  An image format is
-     not Transparent if used for any substantial amount of text.  A
-     copy that is not "Transparent" is called "Opaque".
-
-     Examples of suitable formats for Transparent copies include plain
-     ASCII without markup, Texinfo input format, LaTeX input format,
-     SGML or XML using a publicly available DTD, and
-     standard-conforming simple HTML, PostScript or PDF designed for
-     human modification.  Examples of transparent image formats include
-     PNG, XCF and JPG.  Opaque formats include proprietary formats that
-     can be read and edited only by proprietary word processors, SGML or
-     XML for which the DTD and/or processing tools are not generally
-     available, and the machine-generated HTML, PostScript or PDF
-     produced by some word processors for output purposes only.
-
-     The "Title Page" means, for a printed book, the title page itself,
-     plus such following pages as are needed to hold, legibly, the
-     material this License requires to appear in the title page.  For
-     works in formats which do not have any title page as such, "Title
-     Page" means the text near the most prominent appearance of the
-     work's title, preceding the beginning of the body of the text.
-
-     A section "Entitled XYZ" means a named subunit of the Document
-     whose title either is precisely XYZ or contains XYZ in parentheses
-     following text that translates XYZ in another language.  (Here XYZ
-     stands for a specific section name mentioned below, such as
-     "Acknowledgements", "Dedications", "Endorsements", or "History".)
-     To "Preserve the Title" of such a section when you modify the
-     Document means that it remains a section "Entitled XYZ" according
-     to this definition.
-
-     The Document may include Warranty Disclaimers next to the notice
-     which states that this License applies to the Document.  These
-     Warranty Disclaimers are considered to be included by reference in
-     this License, but only as regards disclaiming warranties: any other
-     implication that these Warranty Disclaimers may have is void and
-     has no effect on the meaning of this License.
-
-  2. VERBATIM COPYING
-
-     You may copy and distribute the Document in any medium, either
-     commercially or noncommercially, provided that this License, the
-     copyright notices, and the license notice saying this License
-     applies to the Document are reproduced in all copies, and that you
-     add no other conditions whatsoever to those of this License.  You
-     may not use technical measures to obstruct or control the reading
-     or further copying of the copies you make or distribute.  However,
-     you may accept compensation in exchange for copies.  If you
-     distribute a large enough number of copies you must also follow
-     the conditions in section 3.
-
-     You may also lend copies, under the same conditions stated above,
-     and you may publicly display copies.
-
-  3. COPYING IN QUANTITY
-
-     If you publish printed copies (or copies in media that commonly
-     have printed covers) of the Document, numbering more than 100, and
-     the Document's license notice requires Cover Texts, you must
-     enclose the copies in covers that carry, clearly and legibly, all
-     these Cover Texts: Front-Cover Texts on the front cover, and
-     Back-Cover Texts on the back cover.  Both covers must also clearly
-     and legibly identify you as the publisher of these copies.  The
-     front cover must present the full title with all words of the
-     title equally prominent and visible.  You may add other material
-     on the covers in addition.  Copying with changes limited to the
-     covers, as long as they preserve the title of the Document and
-     satisfy these conditions, can be treated as verbatim copying in
-     other respects.
-
-     If the required texts for either cover are too voluminous to fit
-     legibly, you should put the first ones listed (as many as fit
-     reasonably) on the actual cover, and continue the rest onto
-     adjacent pages.
-
-     If you publish or distribute Opaque copies of the Document
-     numbering more than 100, you must either include a
-     machine-readable Transparent copy along with each Opaque copy, or
-     state in or with each Opaque copy a computer-network location from
-     which the general network-using public has access to download
-     using public-standard network protocols a complete Transparent
-     copy of the Document, free of added material.  If you use the
-     latter option, you must take reasonably prudent steps, when you
-     begin distribution of Opaque copies in quantity, to ensure that
-     this Transparent copy will remain thus accessible at the stated
-     location until at least one year after the last time you
-     distribute an Opaque copy (directly or through your agents or
-     retailers) of that edition to the public.
-
-     It is requested, but not required, that you contact the authors of
-     the Document well before redistributing any large number of
-     copies, to give them a chance to provide you with an updated
-     version of the Document.
-
-  4. MODIFICATIONS
-
-     You may copy and distribute a Modified Version of the Document
-     under the conditions of sections 2 and 3 above, provided that you
-     release the Modified Version under precisely this License, with
-     the Modified Version filling the role of the Document, thus
-     licensing distribution and modification of the Modified Version to
-     whoever possesses a copy of it.  In addition, you must do these
-     things in the Modified Version:
-
-       A. Use in the Title Page (and on the covers, if any) a title
-          distinct from that of the Document, and from those of
-          previous versions (which should, if there were any, be listed
-          in the History section of the Document).  You may use the
-          same title as a previous version if the original publisher of
-          that version gives permission.
-
-       B. List on the Title Page, as authors, one or more persons or
-          entities responsible for authorship of the modifications in
-          the Modified Version, together with at least five of the
-          principal authors of the Document (all of its principal
-          authors, if it has fewer than five), unless they release you
-          from this requirement.
-
-       C. State on the Title page the name of the publisher of the
-          Modified Version, as the publisher.
-
-       D. Preserve all the copyright notices of the Document.
-
-       E. Add an appropriate copyright notice for your modifications
-          adjacent to the other copyright notices.
-
-       F. Include, immediately after the copyright notices, a license
-          notice giving the public permission to use the Modified
-          Version under the terms of this License, in the form shown in
-          the Addendum below.
-
-       G. Preserve in that license notice the full lists of Invariant
-          Sections and required Cover Texts given in the Document's
-          license notice.
-
-       H. Include an unaltered copy of this License.
-
-       I. Preserve the section Entitled "History", Preserve its Title,
-          and add to it an item stating at least the title, year, new
-          authors, and publisher of the Modified Version as given on
-          the Title Page.  If there is no section Entitled "History" in
-          the Document, create one stating the title, year, authors,
-          and publisher of the Document as given on its Title Page,
-          then add an item describing the Modified Version as stated in
-          the previous sentence.
-
-       J. Preserve the network location, if any, given in the Document
-          for public access to a Transparent copy of the Document, and
-          likewise the network locations given in the Document for
-          previous versions it was based on.  These may be placed in
-          the "History" section.  You may omit a network location for a
-          work that was published at least four years before the
-          Document itself, or if the original publisher of the version
-          it refers to gives permission.
-
-       K. For any section Entitled "Acknowledgements" or "Dedications",
-          Preserve the Title of the section, and preserve in the
-          section all the substance and tone of each of the contributor
-          acknowledgements and/or dedications given therein.
-
-       L. Preserve all the Invariant Sections of the Document,
-          unaltered in their text and in their titles.  Section numbers
-          or the equivalent are not considered part of the section
-          titles.
-
-       M. Delete any section Entitled "Endorsements".  Such a section
-          may not be included in the Modified Version.
-
-       N. Do not retitle any existing section to be Entitled
-          "Endorsements" or to conflict in title with any Invariant
-          Section.
-
-       O. Preserve any Warranty Disclaimers.
-
-     If the Modified Version includes new front-matter sections or
-     appendices that qualify as Secondary Sections and contain no
-     material copied from the Document, you may at your option
-     designate some or all of these sections as invariant.  To do this,
-     add their titles to the list of Invariant Sections in the Modified
-     Version's license notice.  These titles must be distinct from any
-     other section titles.
-
-     You may add a section Entitled "Endorsements", provided it contains
-     nothing but endorsements of your Modified Version by various
-     parties--for example, statements of peer review or that the text
-     has been approved by an organization as the authoritative
-     definition of a standard.
-
-     You may add a passage of up to five words as a Front-Cover Text,
-     and a passage of up to 25 words as a Back-Cover Text, to the end
-     of the list of Cover Texts in the Modified Version.  Only one
-     passage of Front-Cover Text and one of Back-Cover Text may be
-     added by (or through arrangements made by) any one entity.  If the
-     Document already includes a cover text for the same cover,
-     previously added by you or by arrangement made by the same entity
-     you are acting on behalf of, you may not add another; but you may
-     replace the old one, on explicit permission from the previous
-     publisher that added the old one.
-
-     The author(s) and publisher(s) of the Document do not by this
-     License give permission to use their names for publicity for or to
-     assert or imply endorsement of any Modified Version.
-
-  5. COMBINING DOCUMENTS
-
-     You may combine the Document with other documents released under
-     this License, under the terms defined in section 4 above for
-     modified versions, provided that you include in the combination
-     all of the Invariant Sections of all of the original documents,
-     unmodified, and list them all as Invariant Sections of your
-     combined work in its license notice, and that you preserve all
-     their Warranty Disclaimers.
-
-     The combined work need only contain one copy of this License, and
-     multiple identical Invariant Sections may be replaced with a single
-     copy.  If there are multiple Invariant Sections with the same name
-     but different contents, make the title of each such section unique
-     by adding at the end of it, in parentheses, the name of the
-     original author or publisher of that section if known, or else a
-     unique number.  Make the same adjustment to the section titles in
-     the list of Invariant Sections in the license notice of the
-     combined work.
-
-     In the combination, you must combine any sections Entitled
-     "History" in the various original documents, forming one section
-     Entitled "History"; likewise combine any sections Entitled
-     "Acknowledgements", and any sections Entitled "Dedications".  You
-     must delete all sections Entitled "Endorsements."
-
-  6. COLLECTIONS OF DOCUMENTS
-
-     You may make a collection consisting of the Document and other
-     documents released under this License, and replace the individual
-     copies of this License in the various documents with a single copy
-     that is included in the collection, provided that you follow the
-     rules of this License for verbatim copying of each of the
-     documents in all other respects.
-
-     You may extract a single document from such a collection, and
-     distribute it individually under this License, provided you insert
-     a copy of this License into the extracted document, and follow
-     this License in all other respects regarding verbatim copying of
-     that document.
-
-  7. AGGREGATION WITH INDEPENDENT WORKS
-
-     A compilation of the Document or its derivatives with other
-     separate and independent documents or works, in or on a volume of
-     a storage or distribution medium, is called an "aggregate" if the
-     copyright resulting from the compilation is not used to limit the
-     legal rights of the compilation's users beyond what the individual
-     works permit.  When the Document is included in an aggregate, this
-     License does not apply to the other works in the aggregate which
-     are not themselves derivative works of the Document.
-
-     If the Cover Text requirement of section 3 is applicable to these
-     copies of the Document, then if the Document is less than one half
-     of the entire aggregate, the Document's Cover Texts may be placed
-     on covers that bracket the Document within the aggregate, or the
-     electronic equivalent of covers if the Document is in electronic
-     form.  Otherwise they must appear on printed covers that bracket
-     the whole aggregate.
-
-  8. TRANSLATION
-
-     Translation is considered a kind of modification, so you may
-     distribute translations of the Document under the terms of section
-     4.  Replacing Invariant Sections with translations requires special
-     permission from their copyright holders, but you may include
-     translations of some or all Invariant Sections in addition to the
-     original versions of these Invariant Sections.  You may include a
-     translation of this License, and all the license notices in the
-     Document, and any Warranty Disclaimers, provided that you also
-     include the original English version of this License and the
-     original versions of those notices and disclaimers.  In case of a
-     disagreement between the translation and the original version of
-     this License or a notice or disclaimer, the original version will
-     prevail.
-
-     If a section in the Document is Entitled "Acknowledgements",
-     "Dedications", or "History", the requirement (section 4) to
-     Preserve its Title (section 1) will typically require changing the
-     actual title.
-
-  9. TERMINATION
-
-     You may not copy, modify, sublicense, or distribute the Document
-     except as expressly provided for under this License.  Any other
-     attempt to copy, modify, sublicense or distribute the Document is
-     void, and will automatically terminate your rights under this
-     License.  However, parties who have received copies, or rights,
-     from you under this License will not have their licenses
-     terminated so long as such parties remain in full compliance.
-
- 10. FUTURE REVISIONS OF THIS LICENSE
-
-     The Free Software Foundation may publish new, revised versions of
-     the GNU Free Documentation License from time to time.  Such new
-     versions will be similar in spirit to the present version, but may
-     differ in detail to address new problems or concerns.  See
-     `http://www.gnu.org/copyleft/'.
-
-     Each version of the License is given a distinguishing version
-     number.  If the Document specifies that a particular numbered
-     version of this License "or any later version" applies to it, you
-     have the option of following the terms and conditions either of
-     that specified version or of any later version that has been
-     published (not as a draft) by the Free Software Foundation.  If
-     the Document does not specify a version number of this License,
-     you may choose any version ever published (not as a draft) by the
-     Free Software Foundation.
-
-A.1 ADDENDUM: How to Use This License For Your Documents
-========================================================
-
-To use this License in a document you have written, include a copy of
-the License in the document and put the following copyright and license
-notices just after the title page:
-
-       Copyright (C)  YEAR  YOUR NAME.
-       Permission is granted to copy, distribute and/or modify this document
-       under the terms of the GNU Free Documentation License, Version 1.2
-       or any later version published by the Free Software Foundation;
-       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
-       Texts.  A copy of the license is included in the section entitled ``GNU
-       Free Documentation License''.
-
-   If you have Invariant Sections, Front-Cover Texts and Back-Cover
-Texts, replace the "with...Texts." line with this:
-
-         with the Invariant Sections being LIST THEIR TITLES, with
-         the Front-Cover Texts being LIST, and with the Back-Cover Texts
-         being LIST.
-
-   If you have Invariant Sections without Cover Texts, or some other
-combination of the three, merge those two alternatives to suit the
-situation.
-
-   If your document contains nontrivial examples of program code, we
-recommend releasing these examples in parallel under your choice of
-free software license, such as the GNU General Public License, to
-permit their use in free software.
-
-
-File: mpfr.info,  Node: Concept Index,  Next: Function and Type Index,  Prev: GNU Free Documentation License,  Up: Top
-
-Concept Index
-*************
-
- [index ]
-* Menu:
-
-* Accuracy:                              MPFR Interface.       (line 25)
-* Arithmetic functions:                  Basic Arithmetic Functions.
-                                                               (line  3)
-* Assignment functions:                  Assignment Functions. (line  3)
-* Basic arithmetic functions:            Basic Arithmetic Functions.
-                                                               (line  3)
-* Combined initialization and assignment functions: Combined Initialization and Assignment Functions.
-                                                               (line  3)
-* Comparison functions:                  Comparison Functions. (line  3)
-* Compatibility with MPF:                Compatibility with MPF.
-                                                               (line  3)
-* Conditions for copying MPFR:           Copying.              (line  6)
-* Conversion functions:                  Conversion Functions. (line  3)
-* Copying conditions:                    Copying.              (line  6)
-* Custom interface:                      Custom Interface.     (line  3)
-* Exception related functions:           Exception Related Functions.
-                                                               (line  3)
-* Float arithmetic functions:            Basic Arithmetic Functions.
-                                                               (line  3)
-* Float comparisons functions:           Comparison Functions. (line  3)
-* Float functions:                       MPFR Interface.       (line  6)
-* Float input and output functions:      Input and Output Functions.
-                                                               (line  3)
-* Float output functions:                Formatted Output Functions.
-                                                               (line  3)
-* Floating-point functions:              MPFR Interface.       (line  6)
-* Floating-point number:                 Nomenclature and Types.
-                                                               (line  6)
-* GNU Free Documentation License:        GNU Free Documentation License.
-                                                               (line  6)
-* I/O functions <1>:                     Formatted Output Functions.
-                                                               (line  3)
-* I/O functions:                         Input and Output Functions.
-                                                               (line  3)
-* Initialization functions:              Initialization Functions.
-                                                               (line  3)
-* Input functions:                       Input and Output Functions.
-                                                               (line  3)
-* Installation:                          Installing MPFR.      (line  6)
-* Integer related functions:             Integer Related Functions.
-                                                               (line  3)
-* Internals:                             Internals.            (line  3)
-* intmax_t:                              Headers and Libraries.
-                                                               (line 22)
-* inttypes.h:                            Headers and Libraries.
-                                                               (line 22)
-* libmpfr:                               Headers and Libraries.
-                                                               (line 50)
-* Libraries:                             Headers and Libraries.
-                                                               (line 50)
-* Libtool:                               Headers and Libraries.
-                                                               (line 56)
-* Limb:                                  Internals.            (line  6)
-* Linking:                               Headers and Libraries.
-                                                               (line 50)
-* Miscellaneous float functions:         Miscellaneous Functions.
-                                                               (line  3)
-* mpfr.h:                                Headers and Libraries.
-                                                               (line  6)
-* Output functions <1>:                  Formatted Output Functions.
-                                                               (line  3)
-* Output functions:                      Input and Output Functions.
-                                                               (line  3)
-* Precision <1>:                         MPFR Interface.       (line 17)
-* Precision:                             Nomenclature and Types.
-                                                               (line 20)
-* Reporting bugs:                        Reporting Bugs.       (line  6)
-* Rounding mode related functions:       Rounding Related Functions.
-                                                               (line  3)
-* Rounding Modes:                        Nomenclature and Types.
-                                                               (line 34)
-* Special functions:                     Special Functions.    (line  3)
-* stdarg.h:                              Headers and Libraries.
-                                                               (line 19)
-* stdint.h:                              Headers and Libraries.
-                                                               (line 22)
-* stdio.h:                               Headers and Libraries.
-                                                               (line 12)
-* Ternary value:                         Rounding Modes.       (line 29)
-* uintmax_t:                             Headers and Libraries.
-                                                               (line 22)
-
-
-File: mpfr.info,  Node: Function and Type Index,  Prev: Concept Index,  Up: Top
-
-Function and Type Index
-***********************
-
- [index ]
-* Menu:
-
-* mpfr_abs:                              Basic Arithmetic Functions.
-                                                              (line 175)
-* mpfr_acos:                             Special Functions.   (line  52)
-* mpfr_acosh:                            Special Functions.   (line 136)
-* mpfr_add:                              Basic Arithmetic Functions.
-                                                              (line   8)
-* mpfr_add_d:                            Basic Arithmetic Functions.
-                                                              (line  14)
-* mpfr_add_q:                            Basic Arithmetic Functions.
-                                                              (line  18)
-* mpfr_add_si:                           Basic Arithmetic Functions.
-                                                              (line  12)
-* mpfr_add_ui:                           Basic Arithmetic Functions.
-                                                              (line  10)
-* mpfr_add_z:                            Basic Arithmetic Functions.
-                                                              (line  16)
-* mpfr_agm:                              Special Functions.   (line 232)
-* mpfr_ai:                               Special Functions.   (line 248)
-* mpfr_asin:                             Special Functions.   (line  53)
-* mpfr_asinh:                            Special Functions.   (line 137)
-* mpfr_asprintf:                         Formatted Output Functions.
-                                                              (line 194)
-* mpfr_atan:                             Special Functions.   (line  54)
-* mpfr_atan2:                            Special Functions.   (line  65)
-* mpfr_atanh:                            Special Functions.   (line 138)
-* mpfr_buildopt_decimal_p:               Miscellaneous Functions.
-                                                              (line 156)
-* mpfr_buildopt_gmpinternals_p:          Miscellaneous Functions.
-                                                              (line 161)
-* mpfr_buildopt_tls_p:                   Miscellaneous Functions.
-                                                              (line 150)
-* mpfr_buildopt_tune_case:               Miscellaneous Functions.
-                                                              (line 166)
-* mpfr_can_round:                        Rounding Related Functions.
-                                                              (line  37)
-* mpfr_cbrt:                             Basic Arithmetic Functions.
-                                                              (line 109)
-* mpfr_ceil:                             Integer Related Functions.
-                                                              (line   8)
-* mpfr_check_range:                      Exception Related Functions.
-                                                              (line  38)
-* mpfr_clear:                            Initialization Functions.
-                                                              (line  31)
-* mpfr_clear_divby0:                     Exception Related Functions.
-                                                              (line 113)
-* mpfr_clear_erangeflag:                 Exception Related Functions.
-                                                              (line 116)
-* mpfr_clear_flags:                      Exception Related Functions.
-                                                              (line 129)
-* mpfr_clear_inexflag:                   Exception Related Functions.
-                                                              (line 115)
-* mpfr_clear_nanflag:                    Exception Related Functions.
-                                                              (line 114)
-* mpfr_clear_overflow:                   Exception Related Functions.
-                                                              (line 112)
-* mpfr_clear_underflow:                  Exception Related Functions.
-                                                              (line 111)
-* mpfr_clears:                           Initialization Functions.
-                                                              (line  36)
-* mpfr_cmp:                              Comparison Functions.
-                                                              (line   7)
-* mpfr_cmp_d:                            Comparison Functions.
-                                                              (line  10)
-* mpfr_cmp_f:                            Comparison Functions.
-                                                              (line  14)
-* mpfr_cmp_ld:                           Comparison Functions.
-                                                              (line  11)
-* mpfr_cmp_q:                            Comparison Functions.
-                                                              (line  13)
-* mpfr_cmp_si:                           Comparison Functions.
-                                                              (line   9)
-* mpfr_cmp_si_2exp:                      Comparison Functions.
-                                                              (line  31)
-* mpfr_cmp_ui:                           Comparison Functions.
-                                                              (line   8)
-* mpfr_cmp_ui_2exp:                      Comparison Functions.
-                                                              (line  29)
-* mpfr_cmp_z:                            Comparison Functions.
-                                                              (line  12)
-* mpfr_cmpabs:                           Comparison Functions.
-                                                              (line  35)
-* mpfr_const_catalan:                    Special Functions.   (line 259)
-* mpfr_const_euler:                      Special Functions.   (line 258)
-* mpfr_const_log2:                       Special Functions.   (line 256)
-* mpfr_const_pi:                         Special Functions.   (line 257)
-* mpfr_copysign:                         Miscellaneous Functions.
-                                                              (line 104)
-* mpfr_cos:                              Special Functions.   (line  30)
-* mpfr_cosh:                             Special Functions.   (line 115)
-* mpfr_cot:                              Special Functions.   (line  48)
-* mpfr_coth:                             Special Functions.   (line 132)
-* mpfr_csc:                              Special Functions.   (line  47)
-* mpfr_csch:                             Special Functions.   (line 131)
-* mpfr_custom_get_exp:                   Custom Interface.    (line  78)
-* mpfr_custom_get_kind:                  Custom Interface.    (line  67)
-* mpfr_custom_get_significand:           Custom Interface.    (line  72)
-* mpfr_custom_get_size:                  Custom Interface.    (line  36)
-* mpfr_custom_init:                      Custom Interface.    (line  41)
-* mpfr_custom_init_set:                  Custom Interface.    (line  48)
-* mpfr_custom_move:                      Custom Interface.    (line  85)
-* mpfr_d_div:                            Basic Arithmetic Functions.
-                                                              (line  84)
-* mpfr_d_sub:                            Basic Arithmetic Functions.
-                                                              (line  37)
-* MPFR_DECL_INIT:                        Initialization Functions.
-                                                              (line  75)
-* mpfr_digamma:                          Special Functions.   (line 187)
-* mpfr_dim:                              Basic Arithmetic Functions.
-                                                              (line 182)
-* mpfr_div:                              Basic Arithmetic Functions.
-                                                              (line  74)
-* mpfr_div_2exp:                         Compatibility with MPF.
-                                                              (line  51)
-* mpfr_div_2si:                          Basic Arithmetic Functions.
-                                                              (line 197)
-* mpfr_div_2ui:                          Basic Arithmetic Functions.
-                                                              (line 195)
-* mpfr_div_d:                            Basic Arithmetic Functions.
-                                                              (line  86)
-* mpfr_div_q:                            Basic Arithmetic Functions.
-                                                              (line  90)
-* mpfr_div_si:                           Basic Arithmetic Functions.
-                                                              (line  82)
-* mpfr_div_ui:                           Basic Arithmetic Functions.
-                                                              (line  78)
-* mpfr_div_z:                            Basic Arithmetic Functions.
-                                                              (line  88)
-* mpfr_divby0_p:                         Exception Related Functions.
-                                                              (line 135)
-* mpfr_eint:                             Special Functions.   (line 154)
-* mpfr_eq:                               Compatibility with MPF.
-                                                              (line  30)
-* mpfr_equal_p:                          Comparison Functions.
-                                                              (line  61)
-* mpfr_erangeflag_p:                     Exception Related Functions.
-                                                              (line 138)
-* mpfr_erf:                              Special Functions.   (line 198)
-* mpfr_erfc:                             Special Functions.   (line 199)
-* mpfr_exp:                              Special Functions.   (line  24)
-* mpfr_exp10:                            Special Functions.   (line  26)
-* mpfr_exp2:                             Special Functions.   (line  25)
-* mpfr_expm1:                            Special Functions.   (line 150)
-* mpfr_fac_ui:                           Special Functions.   (line 143)
-* mpfr_fits_intmax_p:                    Conversion Functions.
-                                                              (line 146)
-* mpfr_fits_sint_p:                      Conversion Functions.
-                                                              (line 142)
-* mpfr_fits_slong_p:                     Conversion Functions.
-                                                              (line 140)
-* mpfr_fits_sshort_p:                    Conversion Functions.
-                                                              (line 144)
-* mpfr_fits_uint_p:                      Conversion Functions.
-                                                              (line 141)
-* mpfr_fits_uintmax_p:                   Conversion Functions.
-                                                              (line 145)
-* mpfr_fits_ulong_p:                     Conversion Functions.
-                                                              (line 139)
-* mpfr_fits_ushort_p:                    Conversion Functions.
-                                                              (line 143)
-* mpfr_floor:                            Integer Related Functions.
-                                                              (line   9)
-* mpfr_fma:                              Special Functions.   (line 225)
-* mpfr_fmod:                             Integer Related Functions.
-                                                              (line  79)
-* mpfr_fms:                              Special Functions.   (line 227)
-* mpfr_fprintf:                          Formatted Output Functions.
-                                                              (line 158)
-* mpfr_frac:                             Integer Related Functions.
-                                                              (line  62)
-* mpfr_free_cache:                       Special Functions.   (line 266)
-* mpfr_free_str:                         Conversion Functions.
-                                                              (line 133)
-* mpfr_frexp:                            Conversion Functions.
-                                                              (line  47)
-* mpfr_gamma:                            Special Functions.   (line 169)
-* mpfr_get_d:                            Conversion Functions.
-                                                              (line   8)
-* mpfr_get_d_2exp:                       Conversion Functions.
-                                                              (line  34)
-* mpfr_get_decimal64:                    Conversion Functions.
-                                                              (line  10)
-* mpfr_get_default_prec:                 Initialization Functions.
-                                                              (line 114)
-* mpfr_get_default_rounding_mode:        Rounding Related Functions.
-                                                              (line  11)
-* mpfr_get_emax:                         Exception Related Functions.
-                                                              (line   8)
-* mpfr_get_emax_max:                     Exception Related Functions.
-                                                              (line  31)
-* mpfr_get_emax_min:                     Exception Related Functions.
-                                                              (line  30)
-* mpfr_get_emin:                         Exception Related Functions.
-                                                              (line   7)
-* mpfr_get_emin_max:                     Exception Related Functions.
-                                                              (line  29)
-* mpfr_get_emin_min:                     Exception Related Functions.
-                                                              (line  28)
-* mpfr_get_exp:                          Miscellaneous Functions.
-                                                              (line  82)
-* mpfr_get_f:                            Conversion Functions.
-                                                              (line  73)
-* mpfr_get_flt:                          Conversion Functions.
-                                                              (line   7)
-* mpfr_get_ld:                           Conversion Functions.
-                                                              (line   9)
-* mpfr_get_ld_2exp:                      Conversion Functions.
-                                                              (line  36)
-* mpfr_get_patches:                      Miscellaneous Functions.
-                                                              (line 141)
-* mpfr_get_prec:                         Initialization Functions.
-                                                              (line 147)
-* mpfr_get_si:                           Conversion Functions.
-                                                              (line  20)
-* mpfr_get_sj:                           Conversion Functions.
-                                                              (line  22)
-* mpfr_get_str:                          Conversion Functions.
-                                                              (line  87)
-* mpfr_get_ui:                           Conversion Functions.
-                                                              (line  21)
-* mpfr_get_uj:                           Conversion Functions.
-                                                              (line  23)
-* mpfr_get_version:                      Miscellaneous Functions.
-                                                              (line 110)
-* mpfr_get_z:                            Conversion Functions.
-                                                              (line  68)
-* mpfr_get_z_2exp:                       Conversion Functions.
-                                                              (line  55)
-* mpfr_grandom:                          Miscellaneous Functions.
-                                                              (line  65)
-* mpfr_greater_p:                        Comparison Functions.
-                                                              (line  57)
-* mpfr_greaterequal_p:                   Comparison Functions.
-                                                              (line  58)
-* mpfr_hypot:                            Special Functions.   (line 241)
-* mpfr_inexflag_p:                       Exception Related Functions.
-                                                              (line 137)
-* mpfr_inf_p:                            Comparison Functions.
-                                                              (line  42)
-* mpfr_init:                             Initialization Functions.
-                                                              (line  54)
-* mpfr_init2:                            Initialization Functions.
-                                                              (line  11)
-* mpfr_init_set:                         Combined Initialization and Assignment Functions.
-                                                              (line   7)
-* mpfr_init_set_d:                       Combined Initialization and Assignment Functions.
-                                                              (line  12)
-* mpfr_init_set_f:                       Combined Initialization and Assignment Functions.
-                                                              (line  17)
-* mpfr_init_set_ld:                      Combined Initialization and Assignment Functions.
-                                                              (line  14)
-* mpfr_init_set_q:                       Combined Initialization and Assignment Functions.
-                                                              (line  16)
-* mpfr_init_set_si:                      Combined Initialization and Assignment Functions.
-                                                              (line  11)
-* mpfr_init_set_str:                     Combined Initialization and Assignment Functions.
-                                                              (line  23)
-* mpfr_init_set_ui:                      Combined Initialization and Assignment Functions.
-                                                              (line   9)
-* mpfr_init_set_z:                       Combined Initialization and Assignment Functions.
-                                                              (line  15)
-* mpfr_inits:                            Initialization Functions.
-                                                              (line  63)
-* mpfr_inits2:                           Initialization Functions.
-                                                              (line  23)
-* mpfr_inp_str:                          Input and Output Functions.
-                                                              (line  33)
-* mpfr_integer_p:                        Integer Related Functions.
-                                                              (line 105)
-* mpfr_j0:                               Special Functions.   (line 203)
-* mpfr_j1:                               Special Functions.   (line 204)
-* mpfr_jn:                               Special Functions.   (line 206)
-* mpfr_less_p:                           Comparison Functions.
-                                                              (line  59)
-* mpfr_lessequal_p:                      Comparison Functions.
-                                                              (line  60)
-* mpfr_lessgreater_p:                    Comparison Functions.
-                                                              (line  66)
-* mpfr_lgamma:                           Special Functions.   (line 179)
-* mpfr_li2:                              Special Functions.   (line 164)
-* mpfr_lngamma:                          Special Functions.   (line 173)
-* mpfr_log:                              Special Functions.   (line  17)
-* mpfr_log10:                            Special Functions.   (line  19)
-* mpfr_log1p:                            Special Functions.   (line 146)
-* mpfr_log2:                             Special Functions.   (line  18)
-* mpfr_max:                              Miscellaneous Functions.
-                                                              (line  24)
-* mpfr_min:                              Miscellaneous Functions.
-                                                              (line  22)
-* mpfr_min_prec:                         Rounding Related Functions.
-                                                              (line  59)
-* mpfr_modf:                             Integer Related Functions.
-                                                              (line  69)
-* mpfr_mul:                              Basic Arithmetic Functions.
-                                                              (line  53)
-* mpfr_mul_2exp:                         Compatibility with MPF.
-                                                              (line  49)
-* mpfr_mul_2si:                          Basic Arithmetic Functions.
-                                                              (line 190)
-* mpfr_mul_2ui:                          Basic Arithmetic Functions.
-                                                              (line 188)
-* mpfr_mul_d:                            Basic Arithmetic Functions.
-                                                              (line  59)
-* mpfr_mul_q:                            Basic Arithmetic Functions.
-                                                              (line  63)
-* mpfr_mul_si:                           Basic Arithmetic Functions.
-                                                              (line  57)
-* mpfr_mul_ui:                           Basic Arithmetic Functions.
-                                                              (line  55)
-* mpfr_mul_z:                            Basic Arithmetic Functions.
-                                                              (line  61)
-* mpfr_nan_p:                            Comparison Functions.
-                                                              (line  41)
-* mpfr_nanflag_p:                        Exception Related Functions.
-                                                              (line 136)
-* mpfr_neg:                              Basic Arithmetic Functions.
-                                                              (line 174)
-* mpfr_nextabove:                        Miscellaneous Functions.
-                                                              (line  16)
-* mpfr_nextbelow:                        Miscellaneous Functions.
-                                                              (line  17)
-* mpfr_nexttoward:                       Miscellaneous Functions.
-                                                              (line   7)
-* mpfr_number_p:                         Comparison Functions.
-                                                              (line  43)
-* mpfr_out_str:                          Input and Output Functions.
-                                                              (line  17)
-* mpfr_overflow_p:                       Exception Related Functions.
-                                                              (line 134)
-* mpfr_pow:                              Basic Arithmetic Functions.
-                                                              (line 118)
-* mpfr_pow_si:                           Basic Arithmetic Functions.
-                                                              (line 122)
-* mpfr_pow_ui:                           Basic Arithmetic Functions.
-                                                              (line 120)
-* mpfr_pow_z:                            Basic Arithmetic Functions.
-                                                              (line 124)
-* mpfr_prec_round:                       Rounding Related Functions.
-                                                              (line  15)
-* mpfr_prec_t:                           Nomenclature and Types.
-                                                              (line  20)
-* mpfr_print_rnd_mode:                   Rounding Related Functions.
-                                                              (line  66)
-* mpfr_printf:                           Formatted Output Functions.
-                                                              (line 165)
-* mpfr_rec_sqrt:                         Basic Arithmetic Functions.
-                                                              (line 104)
-* mpfr_regular_p:                        Comparison Functions.
-                                                              (line  45)
-* mpfr_reldiff:                          Compatibility with MPF.
-                                                              (line  41)
-* mpfr_remainder:                        Integer Related Functions.
-                                                              (line  81)
-* mpfr_remquo:                           Integer Related Functions.
-                                                              (line  83)
-* mpfr_rint:                             Integer Related Functions.
-                                                              (line   7)
-* mpfr_rint_ceil:                        Integer Related Functions.
-                                                              (line  38)
-* mpfr_rint_floor:                       Integer Related Functions.
-                                                              (line  40)
-* mpfr_rint_round:                       Integer Related Functions.
-                                                              (line  42)
-* mpfr_rint_trunc:                       Integer Related Functions.
-                                                              (line  44)
-* mpfr_rnd_t:                            Nomenclature and Types.
-                                                              (line  34)
-* mpfr_root:                             Basic Arithmetic Functions.
-                                                              (line 111)
-* mpfr_round:                            Integer Related Functions.
-                                                              (line  10)
-* mpfr_sec:                              Special Functions.   (line  46)
-* mpfr_sech:                             Special Functions.   (line 130)
-* mpfr_set:                              Assignment Functions.
-                                                              (line  10)
-* mpfr_set_d:                            Assignment Functions.
-                                                              (line  17)
-* mpfr_set_decimal64:                    Assignment Functions.
-                                                              (line  21)
-* mpfr_set_default_prec:                 Initialization Functions.
-                                                              (line 101)
-* mpfr_set_default_rounding_mode:        Rounding Related Functions.
-                                                              (line   7)
-* mpfr_set_divby0:                       Exception Related Functions.
-                                                              (line 122)
-* mpfr_set_emax:                         Exception Related Functions.
-                                                              (line  17)
-* mpfr_set_emin:                         Exception Related Functions.
-                                                              (line  16)
-* mpfr_set_erangeflag:                   Exception Related Functions.
-                                                              (line 125)
-* mpfr_set_exp:                          Miscellaneous Functions.
-                                                              (line  87)
-* mpfr_set_f:                            Assignment Functions.
-                                                              (line  24)
-* mpfr_set_flt:                          Assignment Functions.
-                                                              (line  16)
-* mpfr_set_inexflag:                     Exception Related Functions.
-                                                              (line 124)
-* mpfr_set_inf:                          Assignment Functions.
-                                                              (line 145)
-* mpfr_set_ld:                           Assignment Functions.
-                                                              (line  19)
-* mpfr_set_nan:                          Assignment Functions.
-                                                              (line 144)
-* mpfr_set_nanflag:                      Exception Related Functions.
-                                                              (line 123)
-* mpfr_set_overflow:                     Exception Related Functions.
-                                                              (line 121)
-* mpfr_set_prec:                         Initialization Functions.
-                                                              (line 137)
-* mpfr_set_prec_raw:                     Compatibility with MPF.
-                                                              (line  23)
-* mpfr_set_q:                            Assignment Functions.
-                                                              (line  23)
-* mpfr_set_si:                           Assignment Functions.
-                                                              (line  13)
-* mpfr_set_si_2exp:                      Assignment Functions.
-                                                              (line  51)
-* mpfr_set_sj:                           Assignment Functions.
-                                                              (line  15)
-* mpfr_set_sj_2exp:                      Assignment Functions.
-                                                              (line  55)
-* mpfr_set_str:                          Assignment Functions.
-                                                              (line  63)
-* mpfr_set_ui:                           Assignment Functions.
-                                                              (line  12)
-* mpfr_set_ui_2exp:                      Assignment Functions.
-                                                              (line  49)
-* mpfr_set_uj:                           Assignment Functions.
-                                                              (line  14)
-* mpfr_set_uj_2exp:                      Assignment Functions.
-                                                              (line  53)
-* mpfr_set_underflow:                    Exception Related Functions.
-                                                              (line 120)
-* mpfr_set_z:                            Assignment Functions.
-                                                              (line  22)
-* mpfr_set_z_2exp:                       Assignment Functions.
-                                                              (line  57)
-* mpfr_set_zero:                         Assignment Functions.
-                                                              (line 146)
-* mpfr_setsign:                          Miscellaneous Functions.
-                                                              (line  98)
-* mpfr_sgn:                              Comparison Functions.
-                                                              (line  51)
-* mpfr_si_div:                           Basic Arithmetic Functions.
-                                                              (line  80)
-* mpfr_si_sub:                           Basic Arithmetic Functions.
-                                                              (line  33)
-* mpfr_signbit:                          Miscellaneous Functions.
-                                                              (line  93)
-* mpfr_sin:                              Special Functions.   (line  31)
-* mpfr_sin_cos:                          Special Functions.   (line  37)
-* mpfr_sinh:                             Special Functions.   (line 116)
-* mpfr_sinh_cosh:                        Special Functions.   (line 122)
-* mpfr_snprintf:                         Formatted Output Functions.
-                                                              (line 182)
-* mpfr_sprintf:                          Formatted Output Functions.
-                                                              (line 171)
-* mpfr_sqr:                              Basic Arithmetic Functions.
-                                                              (line  70)
-* mpfr_sqrt:                             Basic Arithmetic Functions.
-                                                              (line  97)
-* mpfr_sqrt_ui:                          Basic Arithmetic Functions.
-                                                              (line  99)
-* mpfr_strtofr:                          Assignment Functions.
-                                                              (line  81)
-* mpfr_sub:                              Basic Arithmetic Functions.
-                                                              (line  27)
-* mpfr_sub_d:                            Basic Arithmetic Functions.
-                                                              (line  39)
-* mpfr_sub_q:                            Basic Arithmetic Functions.
-                                                              (line  45)
-* mpfr_sub_si:                           Basic Arithmetic Functions.
-                                                              (line  35)
-* mpfr_sub_ui:                           Basic Arithmetic Functions.
-                                                              (line  31)
-* mpfr_sub_z:                            Basic Arithmetic Functions.
-                                                              (line  43)
-* mpfr_subnormalize:                     Exception Related Functions.
-                                                              (line  61)
-* mpfr_sum:                              Special Functions.   (line 275)
-* mpfr_swap:                             Assignment Functions.
-                                                              (line 152)
-* mpfr_t:                                Nomenclature and Types.
-                                                              (line   6)
-* mpfr_tan:                              Special Functions.   (line  32)
-* mpfr_tanh:                             Special Functions.   (line 117)
-* mpfr_trunc:                            Integer Related Functions.
-                                                              (line  11)
-* mpfr_ui_div:                           Basic Arithmetic Functions.
-                                                              (line  76)
-* mpfr_ui_pow:                           Basic Arithmetic Functions.
-                                                              (line 128)
-* mpfr_ui_pow_ui:                        Basic Arithmetic Functions.
-                                                              (line 126)
-* mpfr_ui_sub:                           Basic Arithmetic Functions.
-                                                              (line  29)
-* mpfr_underflow_p:                      Exception Related Functions.
-                                                              (line 133)
-* mpfr_unordered_p:                      Comparison Functions.
-                                                              (line  71)
-* mpfr_urandom:                          Miscellaneous Functions.
-                                                              (line  50)
-* mpfr_urandomb:                         Miscellaneous Functions.
-                                                              (line  30)
-* mpfr_vasprintf:                        Formatted Output Functions.
-                                                              (line 196)
-* MPFR_VERSION:                          Miscellaneous Functions.
-                                                              (line 113)
-* MPFR_VERSION_MAJOR:                    Miscellaneous Functions.
-                                                              (line 114)
-* MPFR_VERSION_MINOR:                    Miscellaneous Functions.
-                                                              (line 115)
-* MPFR_VERSION_NUM:                      Miscellaneous Functions.
-                                                              (line 133)
-* MPFR_VERSION_PATCHLEVEL:               Miscellaneous Functions.
-                                                              (line 116)
-* MPFR_VERSION_STRING:                   Miscellaneous Functions.
-                                                              (line 117)
-* mpfr_vfprintf:                         Formatted Output Functions.
-                                                              (line 160)
-* mpfr_vprintf:                          Formatted Output Functions.
-                                                              (line 166)
-* mpfr_vsnprintf:                        Formatted Output Functions.
-                                                              (line 184)
-* mpfr_vsprintf:                         Formatted Output Functions.
-                                                              (line 173)
-* mpfr_y0:                               Special Functions.   (line 214)
-* mpfr_y1:                               Special Functions.   (line 215)
-* mpfr_yn:                               Special Functions.   (line 217)
-* mpfr_z_sub:                            Basic Arithmetic Functions.
-                                                              (line  41)
-* mpfr_zero_p:                           Comparison Functions.
-                                                              (line  44)
-* mpfr_zeta:                             Special Functions.   (line 192)
-* mpfr_zeta_ui:                          Special Functions.   (line 194)
-
-
-
-Tag Table:
-Node: Top880
-Node: Copying2219
-Node: Introduction to MPFR3979
-Node: Installing MPFR6068
-Node: Reporting Bugs10890
-Node: MPFR Basics12823
-Node: Headers and Libraries13139
-Node: Nomenclature and Types16123
-Node: MPFR Variable Conventions18127
-Node: Rounding Modes19657
-Ref: ternary value20754
-Node: Floating-Point Values on Special Numbers22707
-Node: Exceptions25683
-Node: Memory Handling28835
-Node: MPFR Interface29967
-Node: Initialization Functions32063
-Node: Assignment Functions38977
-Node: Combined Initialization and Assignment Functions47511
-Node: Conversion Functions48804
-Node: Basic Arithmetic Functions57356
-Node: Comparison Functions66364
-Node: Special Functions69846
-Node: Input and Output Functions83599
-Node: Formatted Output Functions85522
-Node: Integer Related Functions94641
-Node: Rounding Related Functions100403
-Node: Miscellaneous Functions104017
-Node: Exception Related Functions112207
-Node: Compatibility with MPF118961
-Node: Custom Interface121649
-Node: Internals125894
-Node: API Compatibility127378
-Node: Type and Macro Changes129308
-Node: Added Functions132029
-Node: Changed Functions134972
-Node: Removed Functions139167
-Node: Other Changes139579
-Node: Contributors141108
-Node: References143574
-Node: GNU Free Documentation License145315
-Node: Concept Index167758
-Node: Function and Type Index173677
-
-End Tag Table
-
-
-Local Variables:
-coding: utf-8
-End:
diff --git a/mpfr/src/get_patches.c b/mpfr/src/get_patches.c
deleted file mode 100644
index 23de4c6..0000000
--- a/mpfr/src/get_patches.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* mpfr_get_patches -- Patches that have been applied
-
-Copyright 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
-Contributed by the Arenaire and Caramel projects, INRIA.
-
-This file is part of the GNU MPFR Library.
-
-The GNU MPFR Library is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-The GNU MPFR Library is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
-License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with the GNU MPFR Library; see the file COPYING.LESSER.  If not, see
-http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
-51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA. */
-
-#include "mpfr-impl.h"
-
-const char *
-mpfr_get_patches (void)
-{
-  return "";
-}
-- 
1.7.9.5

